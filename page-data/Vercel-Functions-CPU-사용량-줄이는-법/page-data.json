{"componentChunkName":"component---src-templates-post-jsx","path":"/Vercel-Functions-CPU-사용량-줄이는-법/","result":{"data":{"site":{"siteMetadata":{"title":"SharkniA"}},"markdownRemark":{"id":"c8f0ea2c-1d83-534c-ad21-31df4417fc05","excerpt":"코드 최적화보다 강력한 한 줄: 하마터면 서버 비용을 낭비할 뻔했다 최근 'AI 판사'라는 새로운 토이 프로젝트를 시작했습니다. 사용자가 다투고 있는 내용을 입력하면 LLM이 판사가 되어 판결을 내려주는 서비스입니다. 빠른 아이디어 검증을 위해 Next.js 16 (App Router), Supabase의 조합으로 서비스를 구축하고 Vercel에 배포했습…","html":"<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/a7dd1984425942e175ce85e5fc5ca4d5/42a19/image1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 42.35294117647059%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB80lEQVR42gHoARf+AAcFIxwWMTAgNy0XLScMIyAHIBYFIAsEIQYEIwMFJAAFIwEHJgIHJwIRNAkxUwMUNw8iQStScR40VwULKQAUDilBL0FiQk5yQUhRHSlLFyQ6EiMaBiAPBSIDAR0BBCIDCiwMMFIuY4BnlpYwaoRAiqlywNxdmMEZMVMARRgpOyAwaTg9jEE4ijctfiopZB4lNw4iDwAdGS1NESZHAAInJVFuhKCZtMChiaSXO3ueRIOnP32fFTdYACkQJUMgMGcpLZI0KqI2KIIjIpY8LIkxLG0fI09ohDiAoidTcjZujVt8kIuZllt9j0OfwEmZuTt/oxc5WQA6Fyk+HS5qKyqjRzKpPimQKCOeQjGPNi2DTlFAU3I2d5oycZI+e5RRkKxBhq1LlLNUrstYs81BkbQYOFoAPBgqUSMwazI2i0Q6eCwpdSImey0sMgogGydKCxY3HElrEDZcHkFecoeEdpGNcY+OQYKnNHObOXOdGDRZABQLJkwjMV4yPGAsN1QaJUwWJDIMIRcEIAoBHAMCHwABHwEGKAopTSdSbl5yci1UbSBUfTVokDNljhImSgADAyISCycrFSwnDSUsDCIqCyEUBCANBCEFBCMCBSQBBSQCBygBBykEEzYOMFMEFzsDDS8RI0YPGj0PEC5fKHlRoed/mgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image1' title='' src='/static/a7dd1984425942e175ce85e5fc5ca4d5/ca1dc/image1.png' srcset='/static/a7dd1984425942e175ce85e5fc5ca4d5/e7570/image1.png 170w,\n/static/a7dd1984425942e175ce85e5fc5ca4d5/f46e7/image1.png 340w,\n/static/a7dd1984425942e175ce85e5fc5ca4d5/ca1dc/image1.png 680w,\n/static/a7dd1984425942e175ce85e5fc5ca4d5/02d09/image1.png 1020w,\n/static/a7dd1984425942e175ce85e5fc5ca4d5/42a19/image1.png 1024w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>코드 최적화보다 강력한 한 줄: 하마터면 서버 비용을 낭비할 뻔했다</h2>\n<p>최근 '<a href=\"https://ai.tuum.day/\">AI 판사</a>'라는 새로운 토이 프로젝트를 시작했습니다. 사용자가 다투고 있는 내용을 입력하면 LLM이 판사가 되어 판결을 내려주는 서비스입니다.</p>\n<p>빠른 아이디어 검증을 위해 Next.js 16 (App Router), Supabase의 조합으로 서비스를 구축하고 Vercel에 배포했습니다. 그런데 프로젝트를 오픈하고 얼마 지나지 않아 Vercel 대시보드에서 예상치 못한 지표를 마주했습니다.</p>\n<p>이 글은 코드를 열심히 깎는 것보다 '제대로 된 캐싱 전략' 하나가 얼마나 강력한 성능 개선과 비용 절감을 가져다주는지에 대한 기록입니다.</p>\n<h2>문제의 발견: Vercel Functions 지표</h2>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/5cc5292950170e567bdf03dcd3f4e579/c3dd4/image2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAACW0lEQVR42pWUW67iMBBEDQRIyBMIJBDeb35AQuyFLbIMNsCaenJa4wy6Ileaj8Im6ZSrqm0b3/clCAKJokjCMBT+/w9Op5Pc73dFnudi+Ller3I+n+V2u8nlcpFer6fFjN/AO9d1JY5jeT6f8nq95P1+y+PxEENB8LfAFne7Xel0OuJ53q/gm+VyKcfjUZUOBgMxzW4ovXQts2ku02lRYiqTyUTm87m0220xxtTCcRzp9/sal3Vkun4sfj+X8SiV0WikSNNUhsOhKoC0Drggd5Qx0gvDJMtyzXC32ykOh4OqRAH267LENupms5kKQYRptzvih3H5sFBlWM6yTAsgxRL2Go2GotlsVnOeQwwpdWoZwiAIS6JJRUjnsWFHPoToE61WS0ktYZIkmqOJoljySSGbzUaxXq8r2/v9XrtHF21GRVHIarVSMKd5i8VCR0iN63oShJH6ByhitM1hdbKiCTZTC5qCQuxWTaHQ6/lKMC1XtNlhHQUQ/rZ1+B7CatuQ32ic6QYF2+22skUErIrCnyeFGuqxihP+a94UJElfOwtQRgENAexFrH2CZ6iyEXEEmWPbOE67VBHJeDxWMlZkTnN0X32xiUJqgD0piFDLvEzKh8vlQmWTn71J7Hm1+GwI7xiJBGI6rHmT4XCY6m5HFbmxEmHbTtr5t8sBuzjDjR6CVssp1QTlXpqrQl5CbruMYsIn37pOQ0x+LGI8zy3lxvox0mkEo70g2EYEj7W6S0Jj+3dSIiWzJ4NTwumwcy4NyLFed+myIC5020Bogeyfc0YI7Wn4rP+ste/+AJkM3pnptm2bAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image2' title='' src='/static/5cc5292950170e567bdf03dcd3f4e579/ca1dc/image2.png' srcset='/static/5cc5292950170e567bdf03dcd3f4e579/e7570/image2.png 170w,\n/static/5cc5292950170e567bdf03dcd3f4e579/f46e7/image2.png 340w,\n/static/5cc5292950170e567bdf03dcd3f4e579/ca1dc/image2.png 680w,\n/static/5cc5292950170e567bdf03dcd3f4e579/c3dd4/image2.png 788w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\nVercel은 서버리스 함수(Functions)의 실행 시간을 기준으로 과금을 합니다. </p>\n<p>Vercel의 최신 Fluid Compute 모델은 메모리 사용량(GB-Hours)과 별개로 순수 CPU 실행 시간(Active CPU)을 측정합니다. 무료 플랜은 이 CPU 시간이 월 4시간으로 제한되는데 아직 사용자가 많지 않음에도 불구하고 이 시간을 빠르게 소모하고 있었습니다.</p>\n<p>특히 최근에는 하루에 10분 이상의 컴퓨팅 시간을 사용하고 있어 30일간 5시간 정도를 쓰게 돼 무료 사용량을 넘길 판이었습니다. </p>\n<p>이에 제한적인 지표지만 지난 12시간 어떤 페이지가 컴퓨팅 시간을 많이 소모하는지를 찾아봤습니다. </p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/4d43b4ad19e5b2433b17a0f5de703f36/d9349/image3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 95.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACGUlEQVR42n1U25KjQAjtVBK1r2pr22Zq9v8/k+Wg9JrM1D5QIHI5HFDT9z3N80zDMBDsJl1HPftijGQt65Qo5/wec0oMgcZxlBrGey+B3jmC7Vg759mO8hw42HsnOnFR+D4lTzMtSxbbaAeH5JjIWUsucLFxZXugkCZp4N4avotFDuuu64+C6BzSTHHZD1TjTGP5Q54Lp/LN7/LRMPxEF06BjVrm+XxS4vnjXMhPC6NLFKfMxV/k4kQhV0p5ExTjmA6kDois6OCtTJJSFGrM4/GQpSAQiwC56Db0nSwkxSA0gEMIiEcsbGtd4xl+gBOE+743Z6218bJtG5WyCSXLsrQYaDRDHADo9gHOdIwKLxAIG05ota/PEAD4FI35V5BhazLkfr+L1gSghcBW9PakAch0IcgzCMjMIQKEMx4PAj8KIFDHRfNSShtXKcAztCCMvJ26V0lCIS16HPRxDuB4XdfGJXx65HrwWtwkPoX9tUtnBINkPWJNmKapLQLvjxMamw/vFaWBURkBNoptfX4FWhRFYOuJIU+bKkI5bHz0S1kl8BPddSTlDHHXkRV1GxkcLhsTHWJDcRUkgAotKD8S9muRcP5p2siBjVI36QzRDV5HBhptplN8joznY2Qs5etFdavS/brd30bG8q4If4zs+Q8CDvPJIZxX0V8TusPGRuFH0euBt5Fx3c8Hf9TGiNxut//KbzGooYf9F7CprAYjt7i0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image3' title='' src='/static/4d43b4ad19e5b2433b17a0f5de703f36/ca1dc/image3.png' srcset='/static/4d43b4ad19e5b2433b17a0f5de703f36/e7570/image3.png 170w,\n/static/4d43b4ad19e5b2433b17a0f5de703f36/f46e7/image3.png 340w,\n/static/4d43b4ad19e5b2433b17a0f5de703f36/ca1dc/image3.png 680w,\n/static/4d43b4ad19e5b2433b17a0f5de703f36/02d09/image3.png 1020w,\n/static/4d43b4ad19e5b2433b17a0f5de703f36/9d567/image3.png 1360w,\n/static/4d43b4ad19e5b2433b17a0f5de703f36/d9349/image3.png 2040w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li><code class=\"language-text\">/verdicts/[id]/opengraph-image-Block1</code>: Active CPU 2m (98 invocations)</li>\n<li><code class=\"language-text\">/verdicts/[id]</code>: Active CPU 16s (149 invocations)</li>\n</ul>\n<p>가장 큰 원인은 소셜 미디어 공유용 미리보기 이미지를 만드는 OG(OpenGraph) 이미지 생성 함수였습니다. 고작 88번 호출되었는데 무려 2분의 CPU 시간을 점유하고 있었습니다. 단순 텍스트 조회인 판결 상세 페이지 역시 CPU 사용량이 비정상적으로 높았습니다.</p>\n<p>AI 판사의 판결 결과는 한 번 생성되면 변하지 않는 정적인 데이터입니다. 그럼에도 불구하고 왜 이런 비효율이 발생했을까? 처음에는 \"비효율적인 쿼리나 무거운 라이브러리 문제일 것\"이라고 가정하고 분석을 시작했습니다. 하지만 코드를 열어보고 나서야 이 가정이 틀렸음을 깨달았습니다.</p>\n<h2>분석: 캐싱 정책의 부재</h2>\n<p>코드를 분석하면서 발견한 근본적인 문제는 로직의 효율성이 아니라 '캐싱 정책의 부재'였습니다.</p>\n<h3>1. 1회성 데이터를 위해 매번 가동되는 무거운 엔진 (OG Image)</h3>\n<p>AI 판사는 공유 기능을 위해 결과를 즉석에서 동적 이미지로 생성합니다. Next.js의 <code class=\"language-text\">ImageResponse</code>를 사용하면 HTML/CSS 코드를 이미지로 변환해 주는데, 이 과정은 생각보다 무거운 연산입니다.</p>\n<ol>\n<li>DB에서 데이터를 조회</li>\n<li>폰트 로드</li>\n<li>Satori 엔진을 통한 SVG 변환 (CPU 집약적)</li>\n<li>PNG 인코딩</li>\n</ol>\n<p>제 코드는 봇이 링크를 긁어갈 때마다 이 무거운 4단계 공정을 매번 처음부터 다시 수행하고 있었습니다. 판결 결과는 불변 데이터임에도 불구하고 말입니다.</p>\n<h3>2. 한 페이지에서 두 번 발생하는 쿼리</h3>\n<p>판결 상세 페이지에서도 비효율이 발견되었습니다. Next.js App Router는 '메타데이터 생성(<code class=\"language-text\">generateMetadata</code>)'과 'UI 렌더링(<code class=\"language-text\">Page</code>)'을 분리해서 처리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 1. 메타데이터 생성 시 호출</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">generateMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> params <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> verdict <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getBotVerdictById</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> title<span class=\"token operator\">:</span> verdict<span class=\"token punctuation\">.</span>title <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 2. 페이지 렌더링 시 호출</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Page</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> params <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> verdict <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getBotVerdictById</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>VerdictContent data<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>verdict<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반적인 <code class=\"language-text\">fetch</code>를 사용했다면 Next.js가 자동으로 중복 요청을 제거(deduplication)해주었겠지만, 저는 Supabase 클라이언트를 직접 사용하고 있어 이 기능이 동작하지 않았습니다. 결과적으로 사용자가 페이지를 한 번 볼 때마다 서버는 동일한 데이터를 위해 DB를 두 번 호출하고 있었습니다.</p>\n<h2>해결: 코드가 아닌 정책을 재설계하다</h2>\n<p>문제를 해결하기 위해 로직을 최적화하는 대신 프레임워크와 인프라가 제공하는 캐싱 기능을 적재적소에 배치하기로 했습니다.</p>\n<h3>1. OG 이미지: 24시간 캐시</h3>\n<p>가장 무거운 OG 이미지에는 과감하게 24시간(<code class=\"language-text\">revalidate = 86400</code>) 캐시를 적용했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> revalidate <span class=\"token operator\">=</span> <span class=\"token number\">86400</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 24시간</span></code></pre></div>\n<p>판결 내용은 불변이므로 기술적으로는 영구 캐싱도 가능합니다. 하지만 현재 트래픽 패턴상 최신 글은 하루 정도 조회가 발생하고 이후 급격히 줄어드는 점을 고려하여, 24시간이면 충분히 효율적이라 판단했습니다. 이 설정으로 봇이 수백 번 방문해도 서버(함수)는 단 한 번만 실행됩니다.</p>\n<h3>2. Request Deduplication: React.cache</h3>\n<p>중복 DB 호출 문제는 React의 <code class=\"language-text\">cache</code> 함수를 도입하여 해결했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> cache <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getBotVerdictByIdRaw</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 요청 주기(Request Cycle) 동안만 유효한 메모리 캐시</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> getBotVerdictById <span class=\"token operator\">=</span> <span class=\"token function\">cache</span><span class=\"token punctuation\">(</span>getBotVerdictByIdRaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 함수는 '한 번의 요청 주기(Request Cycle)' 내에서 결과를 메모리에 기억합니다. 이제 메타데이터 함수와 페이지 컴포넌트가 각각 호출하더라도 실제 DB 쿼리는 처음에 딱 한 번만 실행됩니다.</p>\n<h3>3. On-Demand ISR</h3>\n<p>페이지 캐싱 전략에서 가장 고민되었던 부분은 '변하지 않는 판결'과 '계속 변하는 투표/댓글'의 공존이었습니다. 이 문제를 해결하기 위해 두 가지 선택지를 놓고 저울질했습니다.</p>\n<h4>선택지 A: KV(Redis)를 이용한 Write-Through 캐싱</h4>\n<ul>\n<li>장점: 데이터만 갱신하므로 빠르고 효율적입니다.</li>\n<li>단점: 별도의 저장소(Redis) 비용이 들고, 캐시 조회/무효화 로직을 직접 구현해야 해서 복잡도가 올라갑니다.</li>\n</ul>\n<h4>선택지 B: On-Demand ISR (주문형 재검증)</h4>\n<ul>\n<li>장점: 구현이 매우 단순하고 외부 저장소 비용이 없습니다. 데이터 정합성이 보장됩니다.</li>\n<li>단점: 댓글 하나가 달릴 때마다 페이지 전체(HTML)를 다시 빌드해야 하므로, 페이지가 무겁다면 서버 부담이 될 수 있습니다.\n\"AI 판사\"의 판결 페이지는 텍스트 위주의 단순한 구조라 빌드 비용이 매우 낮습니다. 또한 아직 트래픽이 폭발적인 단계는 아니기에, 저는 구현의 단순함과 비용 효율성을 선택하여 B안(On-Demand ISR)을 택했습니다.\nNext.js에서는 이를 코드 한 줄로 구현할 수 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 평소에는 24시간 정적 캐싱 (CPU 사용 0)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> revalidate <span class=\"token operator\">=</span> <span class=\"token number\">86400</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 댓글/투표 발생 시에만 캐시 무효화</span>\n<span class=\"token function\">revalidatePath</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/verdicts/[id]'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 전략을 통해 평소에는 24시간 캐싱된 정적 HTML을 서빙하여 서버 리소스를 극단적으로 아끼고, 사용자가 댓글을 달거나 투표를 하는 이벤트가 발생할 때만 즉시 페이지를 갱신하도록 구현했습니다.\n결과적으로 복잡한 KV 인프라 구축 없이도, 정적 페이지의 성능과 동적 페이지의 실시간성이라는 두 마리 토끼를 모두 잡을 수 있었습니다.</p>\n<h2>기대 효과 및 결론</h2>\n<p>이러한 최적화 전략의 도입으로 다음과 같은 효과를 기대하고 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>항목</th>\n<th>최적화 전</th>\n<th>최적화 후 (예상)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OG 이미지 생성</td>\n<td>60초 (Active CPU)</td>\n<td><strong>6초</strong></td>\n</tr>\n<tr>\n<td>DB 호출</td>\n<td>2회/요청</td>\n<td><strong>1회/요청</strong></td>\n</tr>\n<tr>\n<td>페이지 응답 (평소)</td>\n<td>실행마다 생성</td>\n<td><strong>정적 캐시 서빙 (0ms)</strong></td>\n</tr>\n<tr>\n<td>페이지 응답 (이벤트)</td>\n<td>실행마다 생성</td>\n<td><strong>필요할 때만 1회 생성</strong></td>\n</tr>\n</tbody>\n</table>\n<p>전체적으로 CPU 사용량을 75% 이상 절감할 수 있을 것으로 예상됩니다. 이는 단순히 성능을 높이는 것을 넘어, Vercel 무료 플랜의 제한된 리소스(월 4시간) 내에서 안정적으로 서비스를 운영하기 위한 필수적인 조치입니다.</p>\n<p>이번 경험은 서버리스 환경에서 '무엇을 계산할 것인가'보다 '무엇을 저장하고 재사용할 것인가'가 비용에 훨씬 더 직접적인 영향을 미친다는 사실을 명확히 보여주었습니다. 코드 레벨의 최적화 이전에 아키텍처와 정책 레벨에서의 효율성을 먼저 고민하는 것의 중요성을 다시 한번 깨닫게 된 계기였습니다.</p>","frontmatter":{"title":"Vercel Functions CPU 사용량 줄이는 법","date":"January 08, 2026","update":"January 08, 2026","tags":["DevOps","BackEnd","Vercel","Hobby","Next.js","Typescript"],"series":null},"fields":{"slug":"/Vercel-Functions-CPU-사용량-줄이는-법/","readingTime":{"minutes":11.72}}},"seriesList":{"edges":[{"node":{"id":"b1fa34d8-79a6-5920-b77c-fbf3bc57100b","fields":{"slug":"/화상상담을-위한-Janus-구성/"},"frontmatter":{"title":"화상상담을 위한 Janus 구성"}}},{"node":{"id":"36ed6446-4d80-5d51-87fe-7cbb02582980","fields":{"slug":"/JavaScript의-특징-브라우저-동작-원리/"},"frontmatter":{"title":"JavaScript의 특징, 브라우저 동작 원리"}}},{"node":{"id":"1890a1d7-34c1-53bd-a8bd-9bdfd39e91c3","fields":{"slug":"/JavaScript-기본-문법/"},"frontmatter":{"title":"JavaScript 기본 문법"}}},{"node":{"id":"61ba989b-e166-5573-a895-1f71aa176358","fields":{"slug":"/JavaScript의-변수/"},"frontmatter":{"title":"JavaScript의 변수"}}},{"node":{"id":"09afa1c5-5d39-532c-8dbb-5ba9e4af5b42","fields":{"slug":"/JavaScript의-타입-변환과-단축-평가/"},"frontmatter":{"title":"JavaScript의 타입 변환과 단축 평가"}}},{"node":{"id":"a81f1c25-10c3-52c4-8594-54806409ea15","fields":{"slug":"/JavaScript-클로저/"},"frontmatter":{"title":"JavaScript 클로저"}}},{"node":{"id":"6f1a58a9-6d27-5238-a531-618fc2d38f6a","fields":{"slug":"/NestJS-소개/"},"frontmatter":{"title":"NestJS 소개"}}},{"node":{"id":"6a1bda4f-ebe2-5b4f-980e-0484f92834f9","fields":{"slug":"/MORETHAN-LOG-설치/"},"frontmatter":{"title":"MORETHAN-LOG 설치"}}},{"node":{"id":"b1b9709f-6909-592c-b003-7ff67d3ca0fe","fields":{"slug":"/DB-튜닝-경험/"},"frontmatter":{"title":"DB 튜닝 경험"}}},{"node":{"id":"192dff3e-aa73-5307-a245-65393ab4e1d9","fields":{"slug":"/RDB관계형-데이터베이스-RDBMS/"},"frontmatter":{"title":"RDB(관계형 데이터베이스) + RDBMS"}}},{"node":{"id":"7ac316a8-f6ea-52cc-a790-b5be80f2bec7","fields":{"slug":"/var와-letconst/"},"frontmatter":{"title":"var와 let,const"}}},{"node":{"id":"e86672d9-847c-55f9-a249-42b4d896508f","fields":{"slug":"/MORETHAN-LOG-수정/"},"frontmatter":{"title":"MORETHAN-LOG 수정"}}},{"node":{"id":"6a5ef575-d133-5b56-b0b6-4db4af7aa70d","fields":{"slug":"/NestJS-설치/"},"frontmatter":{"title":"NestJS 설치"}}},{"node":{"id":"c9c69060-c0a8-5657-b744-46feb11aa3bd","fields":{"slug":"/NestJS의-디렉토리-구조/"},"frontmatter":{"title":"NestJS의 디렉토리 구조"}}},{"node":{"id":"6c0e93ce-fab2-5cd8-b369-8c7e35114bd4","fields":{"slug":"/웹-사이트-프로젝트-vs-웹-응용-프로그램-프로젝트/"},"frontmatter":{"title":"웹 사이트 프로젝트 vs 웹 응용 프로그램 프로젝트"}}},{"node":{"id":"e6017a82-883c-5533-b084-e4d128fba3f5","fields":{"slug":"/Nuget-패키지-dll-추출/"},"frontmatter":{"title":"Nuget 패키지 dll 추출"}}},{"node":{"id":"0747e4e2-4d9c-5f2e-9ad4-db4690dc2756","fields":{"slug":"/무료-웹-호스팅-비교/"},"frontmatter":{"title":"무료 웹 호스팅 비교"}}},{"node":{"id":"dec52422-f02f-5520-bfe2-d277ddc7a455","fields":{"slug":"/PRG-패턴-PostRedirectGet/"},"frontmatter":{"title":"PRG 패턴 (Post/Redirect/Get)"}}},{"node":{"id":"ef3f3ed5-f90e-552f-8c1a-f24d1eeb0573","fields":{"slug":"/Python-venv-Windows/"},"frontmatter":{"title":"Python venv (Windows)"}}},{"node":{"id":"73f61a9c-4b13-5f3c-b288-9f971499e1c9","fields":{"slug":"/print와-pprint/"},"frontmatter":{"title":"print와 pprint"}}},{"node":{"id":"42d9a8c0-c330-548e-a36c-c8b97811df23","fields":{"slug":"/정규화와-역정규화/"},"frontmatter":{"title":"정규화와 역정규화"}}},{"node":{"id":"8bcc825c-89ec-552c-9144-ac6b2afced1e","fields":{"slug":"/트래픽-튜닝/"},"frontmatter":{"title":"트래픽 튜닝"}}},{"node":{"id":"1f906753-4b2c-58e9-8b1d-65dbacd5a5ed","fields":{"slug":"/npx/"},"frontmatter":{"title":"npx"}}},{"node":{"id":"90f8d06a-0a5c-5fa2-bcb7-7ac1b4fccbdc","fields":{"slug":"/Branch/"},"frontmatter":{"title":"Branch"}}},{"node":{"id":"3e072448-1152-518b-89a4-0154bf7ed441","fields":{"slug":"/DataTable-클래스/"},"frontmatter":{"title":"DataTable 클래스"}}},{"node":{"id":"4e96b425-fd44-57b0-a26c-205a2db9f3f9","fields":{"slug":"/Typescript-시작하기/"},"frontmatter":{"title":"Typescript 시작하기"}}},{"node":{"id":"825a1946-8a6a-559a-9e11-93447cdedcdf","fields":{"slug":"/gitignore/"},"frontmatter":{"title":"gitignore"}}},{"node":{"id":"c65d18a5-967b-591b-a184-2f380d3f7847","fields":{"slug":"/Factory-Pattern/"},"frontmatter":{"title":"Factory Pattern"}}},{"node":{"id":"ee0abcf0-eb6f-569e-a2df-26ef807ffd53","fields":{"slug":"/네이밍-규칙naming-conventions/"},"frontmatter":{"title":"네이밍 규칙(naming conventions)"}}},{"node":{"id":"b3e00fd2-84a2-5bbc-8976-a76d7948ba15","fields":{"slug":"/AWS-API-Gateway/"},"frontmatter":{"title":"AWS API Gateway"}}},{"node":{"id":"c1d28daf-f0b4-521c-926c-88c14a61a609","fields":{"slug":"/ColdStart/"},"frontmatter":{"title":"ColdStart"}}},{"node":{"id":"45a48b17-f235-5fcf-90c4-f186e96b788e","fields":{"slug":"/Serverless/"},"frontmatter":{"title":"Serverless"}}},{"node":{"id":"b1e5d38b-5dfb-5406-a693-d18281ac16f8","fields":{"slug":"/NoSQL/"},"frontmatter":{"title":"NoSQL"}}},{"node":{"id":"59b56ebf-8c53-5362-82a7-3deb113c9308","fields":{"slug":"/Dynamo-DB/"},"frontmatter":{"title":"Dynamo DB"}}},{"node":{"id":"97236b20-03d7-59be-b021-0cf4f12ba08f","fields":{"slug":"/REST/"},"frontmatter":{"title":"REST"}}},{"node":{"id":"67555ff4-c43d-50d6-91fc-7db62ae5324a","fields":{"slug":"/TypeError-non-default-argument-content-follows-default-argument/"},"frontmatter":{"title":"TypeError: non-default argument 'content' follows default argument"}}},{"node":{"id":"247e0d6c-cb1f-523b-a365-12fbdf26de54","fields":{"slug":"/브랜치-관리-전략/"},"frontmatter":{"title":"브랜치 관리 전략"}}},{"node":{"id":"fd68eada-5e64-5d6e-ad3e-e7cccc28c242","fields":{"slug":"/Unit-Test단위-테스트/"},"frontmatter":{"title":"Unit Test(단위 테스트)"}}},{"node":{"id":"8fc059ee-a057-5299-9416-e5fe9a21f3b5","fields":{"slug":"/__post_init__/"},"frontmatter":{"title":"__post_init__"}}},{"node":{"id":"facbb85b-b3b0-54f1-b2ac-5593cedf9d02","fields":{"slug":"/dataclass/"},"frontmatter":{"title":"dataclass"}}},{"node":{"id":"f517cf21-d25d-5ad1-90b2-7cd04bdc1de5","fields":{"slug":"/FastAPI와-DDD/"},"frontmatter":{"title":"FastAPI와 DDD"}}},{"node":{"id":"c76d3263-2674-5711-9753-c7b1884886a2","fields":{"slug":"/vercel-배포-자동화/"},"frontmatter":{"title":"vercel 배포 자동화"}}},{"node":{"id":"643a5e74-e453-5eaf-be99-4fe90007fc0d","fields":{"slug":"/AWS-ECSElastic-Container-Service/"},"frontmatter":{"title":"AWS ECS(Elastic Container Service)"}}},{"node":{"id":"295a3a5e-5f68-53dd-a096-99c650a09f85","fields":{"slug":"/Blue-Green-Deploy-전략/"},"frontmatter":{"title":"Blue Green Deploy 전략"}}},{"node":{"id":"ef099c50-5b09-5374-b773-1646367f1a07","fields":{"slug":"/CloudFront/"},"frontmatter":{"title":"CloudFront"}}},{"node":{"id":"f2c13448-7669-5227-8e74-c0db79f8efa6","fields":{"slug":"/Poetry/"},"frontmatter":{"title":"Poetry"}}},{"node":{"id":"327528cd-aa5a-5ecb-9d02-1747c311b92a","fields":{"slug":"/DynamoDB의-동시성-제어Concurrency-Control/"},"frontmatter":{"title":"DynamoDB의 동시성 제어(Concurrency Control)"}}},{"node":{"id":"c61f89ee-7345-5822-a5bb-1ee417382592","fields":{"slug":"/FastAPI/"},"frontmatter":{"title":"FastAPI"}}},{"node":{"id":"6fde18dc-7c77-5d99-8142-13ade8537ae3","fields":{"slug":"/Pydantic-모델/"},"frontmatter":{"title":"Pydantic 모델"}}},{"node":{"id":"f97d2d57-9678-56e0-a700-2bd7ef00aca3","fields":{"slug":"/FastAPI의-데코레이터/"},"frontmatter":{"title":"FastAPI의 데코레이터"}}},{"node":{"id":"9b37002b-b912-5345-b81b-46951cc4a970","fields":{"slug":"/생성기generate-패턴/"},"frontmatter":{"title":"생성기(generate) 패턴"}}},{"node":{"id":"483a498b-b542-5587-989a-52dab4c1214c","fields":{"slug":"/FastAPI에서-데코레이터와-Dependency/"},"frontmatter":{"title":"FastAPI에서 데코레이터와 Dependency"}}},{"node":{"id":"80de20ad-d374-517c-ac92-d2877e4c06a8","fields":{"slug":"/FastAPI와-asyncio/"},"frontmatter":{"title":"FastAPI와 asyncio"}}},{"node":{"id":"87a218c9-82b0-5f05-90fa-a0d9da888853","fields":{"slug":"/aiohttp/"},"frontmatter":{"title":"aiohttp"}}},{"node":{"id":"222a8a91-8da9-500a-9074-4dd115cbe21f","fields":{"slug":"/단축어로-SLACK-프로필-변경하기/"},"frontmatter":{"title":"단축어로 SLACK 프로필 변경하기"}}},{"node":{"id":"75fcb75f-0a52-533f-a038-0a8460398f25","fields":{"slug":"/PynamoDB와-boto3-PynamoDB의-커넥션/"},"frontmatter":{"title":"PynamoDB와 boto3, PynamoDB의 커넥션"}}},{"node":{"id":"f15732ca-1b29-5230-aa8f-d32fd8ce5769","fields":{"slug":"/FastAPI에서-Postgresql의-커넥션-관리/"},"frontmatter":{"title":"FastAPI에서 Postgresql의 커넥션 관리"}}},{"node":{"id":"e0b43964-5998-5379-becc-614d8c62f076","fields":{"slug":"/Sqlalchemy-비동기-엔진에서의-Postgresql-Pooler/"},"frontmatter":{"title":"Sqlalchemy 비동기 엔진에서의 Postgresql Pooler"}}},{"node":{"id":"ef31575e-f174-58f7-84b7-832d38e952f9","fields":{"slug":"/FastAPI의-Pagenation/"},"frontmatter":{"title":"FastAPI의 Pagenation"}}},{"node":{"id":"c661de9c-fcb1-5bc6-b987-28d7cd303acb","fields":{"slug":"/SqlAlchemy의-QueuePool/"},"frontmatter":{"title":"SqlAlchemy의 QueuePool"}}},{"node":{"id":"7591133a-cdeb-5c9a-ab49-4ca7c8f3dea7","fields":{"slug":"/Pydantic-Model의-응용/"},"frontmatter":{"title":"Pydantic Model의 응용"}}},{"node":{"id":"cf792859-1afc-5118-bf50-0752527a6569","fields":{"slug":"/Union-Type/"},"frontmatter":{"title":"Union Type"}}},{"node":{"id":"c2c531ea-1018-5ad8-87b3-c1c027e8f2ee","fields":{"slug":"/우분투-용량-관리/"},"frontmatter":{"title":"우분투 용량 관리"}}},{"node":{"id":"ccff0278-8778-54c6-a28a-ffad6d97612d","fields":{"slug":"/Sqlalchemy에서의-트랜잭션-격리-수준-구현/"},"frontmatter":{"title":"Sqlalchemy에서의 트랜잭션 격리 수준 구현"}}},{"node":{"id":"ee1bfa9e-9eeb-52a2-a33a-88916dcc9119","fields":{"slug":"/트랜잭션-격리-수준Transaction-Isolation-Level/"},"frontmatter":{"title":"트랜잭션 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"a7292f80-7079-5082-9645-3def2d6750b8","fields":{"slug":"/PostgreSQL-Advisory-Locks-트랜잭션-레벨에서-구현/"},"frontmatter":{"title":"PostgreSQL Advisory Locks 트랜잭션 레벨에서 구현"}}},{"node":{"id":"acd438b5-e05c-5772-9da1-3ea3a67cefe0","fields":{"slug":"/Sqlalchemy의-func/"},"frontmatter":{"title":"Sqlalchemy의 func"}}},{"node":{"id":"8221080c-9128-57cc-b79e-c8a9e7959a90","fields":{"slug":"/동시성-제어문제-해결/"},"frontmatter":{"title":"동시성 제어문제 해결"}}},{"node":{"id":"4e23a734-8707-55b2-824e-d120641e8f1a","fields":{"slug":"/vscode-quick-Suggestions/"},"frontmatter":{"title":"vscode-quick Suggestions"}}},{"node":{"id":"1f589451-3bb6-501a-a892-6492654e760c","fields":{"slug":"/Typescript의-열거형/"},"frontmatter":{"title":"Typescript의 열거형"}}},{"node":{"id":"a5babc02-b843-5c39-85e7-1b34cce43cdd","fields":{"slug":"/Github-Action-Output/"},"frontmatter":{"title":"Github Action Output"}}},{"node":{"id":"8b1f5d89-c5ae-52b6-b3c7-19a8d6afda7a","fields":{"slug":"/Github-Actions/"},"frontmatter":{"title":"Github Actions"}}},{"node":{"id":"b81485d3-7cab-52c0-adf9-f489724dc88f","fields":{"slug":"/Github-Actions-Job---needs/"},"frontmatter":{"title":"Github Actions Job - needs"}}},{"node":{"id":"72e50b04-cb8a-55a6-b4ac-636d3dce4b78","fields":{"slug":"/Github-Actions-Workflow-수동으로-실행하기/"},"frontmatter":{"title":"Github Actions Workflow 수동으로 실행하기"}}},{"node":{"id":"2b53a4ed-50b1-5166-bde5-00f56edc9436","fields":{"slug":"/Typescript의-Testcode-맛보기/"},"frontmatter":{"title":"Typescript의 Testcode 맛보기"}}},{"node":{"id":"dbdceb4a-2ed6-5dbc-aa20-7dc961d63f54","fields":{"slug":"/시맨틱-버전-관리/"},"frontmatter":{"title":"시맨틱 버전 관리"}}},{"node":{"id":"6e6deb6d-e36d-5d2f-b11a-55fbc674c2ea","fields":{"slug":"/SQLAlchemy-create_all-메소드로-데이터베이스-테이블-자동-생성하기/"},"frontmatter":{"title":"SQLAlchemy create_all() 메소드로 데이터베이스 테이블 자동 생성하기"}}},{"node":{"id":"dd65c1da-59ff-5d58-a092-3ecc81bdb4fd","fields":{"slug":"/Sqlalchemy의-index/"},"frontmatter":{"title":"Sqlalchemy의 index"}}},{"node":{"id":"2de5adbd-b426-5f30-8811-ebd7fc04ff66","fields":{"slug":"/위치-기반-검색-기능의-구현/"},"frontmatter":{"title":"위치 기반 검색 기능의 구현"}}},{"node":{"id":"50b9db01-3888-5f30-80bc-b2d8ffd25486","fields":{"slug":"/인앱결제에서-백엔드는-무엇을-준비해야-할까/"},"frontmatter":{"title":"인앱결제에서 백엔드는 무엇을 준비해야 할까?"}}},{"node":{"id":"bb95007b-56db-5930-a9b8-4c09e2e118c4","fields":{"slug":"/식별-관계와-비식별-관계-그리고-CASCADE-옵션의-이해/"},"frontmatter":{"title":"식별 관계와 비식별 관계, 그리고 CASCADE 옵션의 이해"}}},{"node":{"id":"f76f95c7-1554-5431-a30b-7d03c93ac41c","fields":{"slug":"/arc-browser/"},"frontmatter":{"title":"arc browser"}}},{"node":{"id":"fe32f546-1476-5dc1-99f4-355cd81fba19","fields":{"slug":"/FastAPI-프로젝트의-시작/"},"frontmatter":{"title":"FastAPI 프로젝트의 시작"}}},{"node":{"id":"ae4611cf-ac19-58f9-be47-e8452f25a2df","fields":{"slug":"/Apple-Silicon과-pyenv/"},"frontmatter":{"title":"Apple Silicon과 pyenv"}}},{"node":{"id":"7edd7ada-7dda-553b-b007-2e7eacdc0c25","fields":{"slug":"/Geocoder와-Reverse-Geocoder/"},"frontmatter":{"title":"Geocoder와 Reverse Geocoder"}}},{"node":{"id":"ef7e194d-396d-5189-87b2-9905aa8edea4","fields":{"slug":"/Postgresql의-JSON과-JSONB/"},"frontmatter":{"title":"Postgresql의 JSON과 JSONB"}}},{"node":{"id":"ad9ce5f7-33b5-5f19-9087-52c928903f92","fields":{"slug":"/SQLModel에서-unique_constraints-설정하기/"},"frontmatter":{"title":"SQLModel에서 unique_constraints 설정하기"}}},{"node":{"id":"fbd5faae-ec78-5d51-ac80-d809dc5137d2","fields":{"slug":"/Supabase-Local-Dev-환경-꾸미기/"},"frontmatter":{"title":"Supabase Local Dev 환경 꾸미기"}}},{"node":{"id":"939d0130-e4ea-5ae4-a169-be69c0f404f9","fields":{"slug":"/Supabase와-Row-Level-Security-RLS/"},"frontmatter":{"title":"Supabase와 Row-Level Security (RLS) "}}},{"node":{"id":"6c085c2e-fa7b-5dcc-a26f-df91cf9354ea","fields":{"slug":"/Supabase-Local-개발-환경-꾸미기---DB-세팅/"},"frontmatter":{"title":"Supabase Local 개발 환경 꾸미기 - DB 세팅"}}},{"node":{"id":"f1f51fb0-adac-5433-9a00-912141ff3182","fields":{"slug":"/Supabase-CLI-db-migration-이력-초기화하기/"},"frontmatter":{"title":"Supabase CLI db migration 이력 초기화하기"}}},{"node":{"id":"2a0b1ae0-7af6-5ce1-90ad-57af39dc2085","fields":{"slug":"/Supabase-EdgeFunction---Deno-개발환경-꾸미기/"},"frontmatter":{"title":"Supabase EdgeFunction  - Deno 개발환경 꾸미기"}}},{"node":{"id":"bbfd7494-2deb-5de4-88dd-5ffbdd240cf6","fields":{"slug":"/Postgresql-Function-Trigger-생성-쿼리문-확인하기/"},"frontmatter":{"title":"Postgresql Function, Trigger 생성 쿼리문 확인하기"}}},{"node":{"id":"e2d90afb-f1f2-5e1f-aab6-820a0d5cf41c","fields":{"slug":"/postgresql의-pg_jsonschema/"},"frontmatter":{"title":"postgresql의 pg_jsonschema"}}},{"node":{"id":"a692b906-efe4-5b06-a108-de1a09926ea9","fields":{"slug":"/Postgresql에서-ENUM-타입에서-값-삭제하기/"},"frontmatter":{"title":"Postgresql에서 ENUM 타입에서 값 삭제하기"}}},{"node":{"id":"d48736cc-957e-53f5-9f48-aac53d5598e4","fields":{"slug":"/PostgreSQL에서-테이블-로우를-JSON으로-변환하기/"},"frontmatter":{"title":"PostgreSQL에서 테이블 로우를 JSON으로 변환하기"}}},{"node":{"id":"02ae12df-41b7-5333-a060-ecc60974fbab","fields":{"slug":"/RLS에-대한-궁금증-모음/"},"frontmatter":{"title":"RLS에 대한 궁금증 모음"}}},{"node":{"id":"78c2562a-631b-572d-8dee-132c9ff9b074","fields":{"slug":"/Deno에서-URL의-쿼리-스트링Query-String-다루기/"},"frontmatter":{"title":" Deno에서 URL의 쿼리 스트링(Query String) 다루기"}}},{"node":{"id":"bab930ba-913e-596b-a917-bdd124dd36db","fields":{"slug":"/Supabase에서-뷰에도-RLS-적용하기/"},"frontmatter":{"title":"Supabase에서 뷰에도 RLS 적용하기"}}},{"node":{"id":"8c276d68-536a-5e9d-a09f-c0055c239046","fields":{"slug":"/supabase-custom-claims를-활용한-관리자-권한-관리/"},"frontmatter":{"title":"supabase-custom-claims를 활용한 관리자 권한 관리"}}},{"node":{"id":"d6698c34-32be-55f0-94d2-50b66aef1073","fields":{"slug":"/Supabase를-위한-Bitbucket-Pipelines-CICD-워크플로우-구축하기/"},"frontmatter":{"title":"Supabase를 위한 Bitbucket Pipelines CI/CD 워크플로우 구축하기"}}},{"node":{"id":"bc763a45-0f35-5420-9eed-9e6387ff48ee","fields":{"slug":"/Pyenv-local-실행을-했는데-파이썬-버전이-바뀌지-않는다/"},"frontmatter":{"title":"Pyenv local 실행을 했는데 파이썬 버전이 바뀌지 않는다"}}},{"node":{"id":"60b158b5-de2c-56a7-a158-53f3648b2889","fields":{"slug":"/Django-설치/"},"frontmatter":{"title":"Django 설치"}}},{"node":{"id":"711d4b8d-3afb-59f8-a47e-efe8b52f1665","fields":{"slug":"/docker-compose를-활용한-postgresql과-django-커넥션-만들기/"},"frontmatter":{"title":"docker-compose를 활용한 postgresql과 django 커넥션 만들기"}}},{"node":{"id":"3c997249-c541-501d-9479-558a653fc409","fields":{"slug":"/Nextjs-소개와-설치-간단-예제/"},"frontmatter":{"title":"Next.js 소개와 설치, 간단 예제"}}},{"node":{"id":"e04ee4b2-2742-5601-a3f7-147ad7074bc1","fields":{"slug":"/ngrok-로컬-서버를-쉽게-공개하는-도구/"},"frontmatter":{"title":"ngrok: 로컬 서버를 쉽게 공개하는 도구"}}},{"node":{"id":"286a5830-d62e-5ddd-99e9-d237161a5838","fields":{"slug":"/Django-Discord-소셜-회원가입-및-로그인-구현/"},"frontmatter":{"title":"Django Discord 소셜 회원가입 및 로그인 구현"}}},{"node":{"id":"e2facd8b-fe1b-5d7e-8134-327a36c58230","fields":{"slug":"/Nextjs-Supabase-회원가입-구현/"},"frontmatter":{"title":"Next.js + Supabase 회원가입 구현"}}},{"node":{"id":"987a5340-8662-50df-85c0-6b7c3732d791","fields":{"slug":"/Django-프로젝트에-Swagger-설정하기/"},"frontmatter":{"title":"Django 프로젝트에 Swagger 설정하기"}}},{"node":{"id":"989746e1-cdef-5498-8c00-2087bbb27bd7","fields":{"slug":"/Django-Rest-Framework에서-JWT를-이용한-사용자-인증-구현/"},"frontmatter":{"title":"Django Rest Framework에서 JWT를 이용한 사용자 인증 구현"}}},{"node":{"id":"11691347-100c-5676-9729-f22ce8a43272","fields":{"slug":"/Django의-Serializers/"},"frontmatter":{"title":"Django의 Serializers"}}},{"node":{"id":"910235bb-5188-5a17-a705-a552a6684e7d","fields":{"slug":"/Go-입문/"},"frontmatter":{"title":"Go 입문"}}},{"node":{"id":"a1ef6dd3-d896-5758-8f72-9e378dcab0f3","fields":{"slug":"/Go를-활용한-OAuth-20-구현/"},"frontmatter":{"title":"Go를 활용한 OAuth 2.0 구현"}}},{"node":{"id":"55e2a5f0-e2c2-5f20-9bc1-e6f52142b1ab","fields":{"slug":"/Django의-사용자-인증-시스템-커스터마이징/"},"frontmatter":{"title":"Django의 사용자 인증 시스템 커스터마이징"}}},{"node":{"id":"27fc9be6-e48b-52a8-bf6d-c0c664700209","fields":{"slug":"/DRF의-API-View/"},"frontmatter":{"title":"DRF의 API View"}}},{"node":{"id":"19273a3e-a109-5cb0-a53a-102a2c1f1f74","fields":{"slug":"/AWS-활용-테스트-서버-구현-1/"},"frontmatter":{"title":"AWS 활용 테스트 서버 구현 (1)"}}},{"node":{"id":"b443bdc5-d571-57ac-a75f-e433dc12f651","fields":{"slug":"/AWS에서-EC2-인스턴스-생성-및-Visual-Studio-Code로-원격-연결하기/"},"frontmatter":{"title":"AWS에서 EC2 인스턴스 생성 및 Visual Studio Code로 원격 연결하기"}}},{"node":{"id":"88f3a1cc-7ec0-50be-a43d-d969e27c4529","fields":{"slug":"/Django-REST-Framework에서-가상-필드-추가하기/"},"frontmatter":{"title":"Django REST Framework에서 가상 필드 추가하기"}}},{"node":{"id":"ae529d5f-12b2-59f1-89bc-e832cde40652","fields":{"slug":"/Mock과-Stub-Fixture/"},"frontmatter":{"title":"Mock과 Stub, Fixture"}}},{"node":{"id":"388f1fc6-4ef9-5391-ad7c-03a8e88d99e3","fields":{"slug":"/Install-Tailwind-CSS-with-Nextjs/"},"frontmatter":{"title":"Install Tailwind CSS with Next.js"}}},{"node":{"id":"dbba3bc0-4c3c-5d9d-87fa-c9c9650907df","fields":{"slug":"/Ubuntu-DLNA-서버-설정/"},"frontmatter":{"title":"Ubuntu DLNA 서버 설정"}}},{"node":{"id":"626fd5b3-36c4-5633-8916-46f9aeba4756","fields":{"slug":"/GitHub-Container-Registry-vs-Docker-Hub/"},"frontmatter":{"title":"GitHub Container Registry vs Docker Hub"}}},{"node":{"id":"a0117df3-8740-55e0-b9e9-d14f35c4e2a9","fields":{"slug":"/N1-문제/"},"frontmatter":{"title":"N+1 문제"}}},{"node":{"id":"e925ca86-1d32-5737-b469-6b04e049b5be","fields":{"slug":"/N1-문제의-해결방법/"},"frontmatter":{"title":"N+1 문제의 해결방법"}}},{"node":{"id":"7caa9886-de89-5549-a331-43a790e9be9d","fields":{"slug":"/Django의-관리자-페이지-만들기/"},"frontmatter":{"title":"Django의 관리자 페이지 만들기"}}},{"node":{"id":"4a03fdbb-525f-5955-a2f4-d2e3f37dab34","fields":{"slug":"/Django의-startapp/"},"frontmatter":{"title":"Django의 startapp"}}},{"node":{"id":"d02a3ccb-149b-5f4e-b724-2a5c694d9dd6","fields":{"slug":"/SD-카드-기반-디스크-오류-및-해결-과정/"},"frontmatter":{"title":"SD 카드 기반 디스크 오류 및 해결 과정"}}},{"node":{"id":"bd6bfd1a-0643-5893-b4fe-19074e66dee3","fields":{"slug":"/Docker에서-Python-환경-변수-관리/"},"frontmatter":{"title":"Docker에서 Python 환경 변수 관리"}}},{"node":{"id":"0baf5600-7bc6-5104-b434-352d0e8cf8fb","fields":{"slug":"/Python-Mocking시-patch-경로-문제-해결하기/"},"frontmatter":{"title":"Python Mocking시 patch 경로 문제 해결하기"}}},{"node":{"id":"ac8d2058-f151-5c32-bb36-494173ac916f","fields":{"slug":"/FastAPI의-의존성-주입Dependency-Injection/"},"frontmatter":{"title":"FastAPI의 의존성 주입(Dependency Injection)"}}},{"node":{"id":"7e134f83-d0a3-5e87-82cd-6877e6ba4567","fields":{"slug":"/FastAPI-의존성-주입의-심화-활용법과-주의점/"},"frontmatter":{"title":"FastAPI 의존성 주입의 심화 활용법과 주의점"}}},{"node":{"id":"06b9e98d-7766-587f-b48e-423e69c5a214","fields":{"slug":"/Typescript의-얇은-복사-vs-깊은-복사/"},"frontmatter":{"title":"Typescript의 얇은 복사 vs 깊은 복사"}}},{"node":{"id":"2dfdf2e4-9e64-596a-a6d6-cb81c682ef09","fields":{"slug":"/React-Native-설치/"},"frontmatter":{"title":"React Native 설치"}}},{"node":{"id":"dc2fdc41-a035-5dbc-aa8b-36c493e556cf","fields":{"slug":"/React-Native의-프로젝트-구조와-화면-이동-구현하기/"},"frontmatter":{"title":"React Native의 프로젝트 구조와 화면 이동 구현하기"}}},{"node":{"id":"f071c474-d82d-5dcf-9c08-0d117c0786d8","fields":{"slug":"/React-Native-Navigation과-Paper-기본부터-사용하기/"},"frontmatter":{"title":"React Native Navigation과 Paper: 기본부터 사용하기"}}},{"node":{"id":"41e18e50-7046-569a-a173-6aadc4b70426","fields":{"slug":"/GraphQL과-Django/"},"frontmatter":{"title":"GraphQL과 Django"}}},{"node":{"id":"d333dddb-d654-5b39-9705-92748c1d858d","fields":{"slug":"/우리-팀에-맞는-API-Gateway-선택하기/"},"frontmatter":{"title":"우리 팀에 맞는 API Gateway 선택하기"}}},{"node":{"id":"bfc8ced1-57c5-55e6-a278-bc62fbe28916","fields":{"slug":"/Elastic-APM/"},"frontmatter":{"title":"Elastic APM"}}},{"node":{"id":"7049857b-fde0-5f51-8131-43655deb98ca","fields":{"slug":"/GraphQL과-Django-2/"},"frontmatter":{"title":"GraphQL과 Django 2"}}},{"node":{"id":"f6783709-6fe0-53ce-9d40-6d4c45ff4b7e","fields":{"slug":"/Deepseek-R1-로컬-설치/"},"frontmatter":{"title":"Deepseek R1 로컬 설치"}}},{"node":{"id":"8f11b5a0-d13f-5def-b485-8b9313ecb0f6","fields":{"slug":"/uv-간단-소개-및-적용/"},"frontmatter":{"title":"uv 간단 소개 및 적용"}}},{"node":{"id":"54bf091e-628d-5868-8990-1db21a44ef7c","fields":{"slug":"/Nginx를-활용한-Reverse-Proxy-구현1/"},"frontmatter":{"title":"Nginx를 활용한 Reverse Proxy 구현(1)"}}},{"node":{"id":"2db7be05-a913-5e8f-a010-3d3d5dfc0cc0","fields":{"slug":"/Nginx를-활용한-Reverse-Proxy-구현2/"},"frontmatter":{"title":"Nginx를 활용한 Reverse Proxy 구현(2)"}}},{"node":{"id":"e6010f44-06a4-5a70-880c-a5eb66228f99","fields":{"slug":"/poetry를-활용해-안정적으로-package-업데이트하기/"},"frontmatter":{"title":"poetry를 활용해 안정적으로 package 업데이트하기"}}},{"node":{"id":"e87675f2-5775-56e9-a865-a738372a3cbf","fields":{"slug":"/React-Native에서-커스텀-폰트-추가하여-사용하기/"},"frontmatter":{"title":"React Native에서 커스텀 폰트 추가하여 사용하기"}}},{"node":{"id":"43249e85-0fc9-55b4-89ce-7a09bad9ed89","fields":{"slug":"/LDAP/"},"frontmatter":{"title":"LDAP"}}},{"node":{"id":"a75adc3f-5c1a-5915-b3b4-6161d21150fd","fields":{"slug":"/Ruff/"},"frontmatter":{"title":"Ruff"}}},{"node":{"id":"b3908629-2878-58ff-9d75-3eaa9afe939a","fields":{"slug":"/Nginx의-Reverse-Proxy-모니터링/"},"frontmatter":{"title":"Nginx의 Reverse Proxy 모니터링"}}},{"node":{"id":"877e8495-8028-5b68-8f55-a1c186b09f72","fields":{"slug":"/Django-모델에서-GraphQL-스키마-자동-생성/"},"frontmatter":{"title":"Django 모델에서 GraphQL 스키마 자동 생성"}}},{"node":{"id":"543e7c6d-4b87-5ff3-92ad-ff851d86ee8b","fields":{"slug":"/DataLoader의-적용/"},"frontmatter":{"title":"DataLoader의 적용"}}},{"node":{"id":"66a11a51-172b-502d-8746-39ce9aaf0028","fields":{"slug":"/분산된-모놀리스를-위한-관리자-페이지-시스템-설계-제안/"},"frontmatter":{"title":"분산된 모놀리스를 위한 관리자 페이지 시스템 설계 제안"}}},{"node":{"id":"f3ecc3d6-83df-5a75-91cc-ef3e294b3e16","fields":{"slug":"/Django와-MySQL에서-DB-Sleep으로-인한-Hang-문제-해결-방안/"},"frontmatter":{"title":"Django와 MySQL에서 DB Sleep으로 인한 Hang 문제 해결 방안"}}},{"node":{"id":"25a2c746-4abd-5665-b779-d7cd5026cded","fields":{"slug":"/Cloudflare-Workers-꾸미기/"},"frontmatter":{"title":"Cloudflare Workers 꾸미기"}}},{"node":{"id":"527edba3-65f4-59c1-b5f6-797bd4537b93","fields":{"slug":"/새로운-아키텍쳐의-선택/"},"frontmatter":{"title":"새로운 아키텍쳐의 선택"}}},{"node":{"id":"c8f0ea2c-1d83-534c-ad21-31df4417fc05","fields":{"slug":"/Vercel-Functions-CPU-사용량-줄이는-법/"},"frontmatter":{"title":"Vercel Functions CPU 사용량 줄이는 법"}}},{"node":{"id":"43c84be8-0a5f-5d1d-8ca8-33d63ff6b360","fields":{"slug":"/Vercel의-캐싱-구조-이해하기/"},"frontmatter":{"title":"Vercel의 캐싱 구조 이해하기"}}},{"node":{"id":"b92cfdd0-85c4-555d-a324-9b9c9b0f3724","fields":{"slug":"/Oracle-Cloud-ARM-인스턴스-생성-완전-가이드/"},"frontmatter":{"title":"Oracle Cloud ARM 인스턴스 생성 완전 가이드"}}}]},"previous":{"fields":{"slug":"/새로운-아키텍쳐의-선택/"},"frontmatter":{"title":"새로운 아키텍쳐의 선택"}},"next":{"fields":{"slug":"/Vercel의-캐싱-구조-이해하기/"},"frontmatter":{"title":"Vercel의 캐싱 구조 이해하기"}}},"pageContext":{"id":"c8f0ea2c-1d83-534c-ad21-31df4417fc05","series":null,"previousPostId":"527edba3-65f4-59c1-b5f6-797bd4537b93","nextPostId":"43c84be8-0a5f-5d1d-8ca8-33d63ff6b360"}},"staticQueryHashes":[],"slicesMap":{}}