{"componentChunkName":"component---src-templates-post-jsx","path":"/설계-중-만난-장애물/","result":{"data":{"site":{"siteMetadata":{"title":"SharkniA"}},"markdownRemark":{"id":"b82c89be-1529-5999-9daa-9bd3fe7ad2d5","excerpt":"서론 지난 안전한 레거시 탈출을 위한 Strangler Fig 패턴 설계기에서는, Django 1.11 기반의 레거시 시스템을 현대화하기 위한 전체적인 '점진적 교체' 전략을 소개했습니다. 그리고 글의 말미에, 보통이라면 가장 큰 장애물일 '인증' 문제는 기존 토큰 방식을 공유하면 간단히 해결될 것이라 낙관했습니다. 하지만, 이 낙관적인 가정은 설계가 깊…","html":"<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/b6d6249bb2396209e7c2db975186ba32/e8464/image1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 66.47058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACgUlEQVR42mVSbVMSURTmB+SUNlaCgoSNDTqYktFiu7KrrK4L7OquLAIKNKQhbKmpiIakAooKiYIsu4syfuwX1C9p+tg/6a4v5djM8+Hcc85zz3Ofc1WO0+odOCtVSpQoSb6CS5RdVemmKtxAiVX/k8lyBdktYNlDNJsfzBbsuTyeLzor4h3mFVn4RysJtFwzvV8Zso0ZSX8P7cXG6YfQhMbGojs5lyiRZeH2FapbBwHUgM6uwAKMT5qYdyYm9Ib1avGA1uaB19OgBETd7r8mU4LISrUJUZ6s1wcWU48QT8sg1273q1FfK8rp8QCxVwQlRpQZqeYo/yVXBGdVZM7P2Xqdls/oWs3Cf27sGVFb6YXd/EQs3mDC1QPMcKZASRIwkru4AD3AxWsytn0wmMgiicyL+WWHUIUWNu912buI6Z+/f3378f1BL3FFBltANrJoMmdd3oI3M66qqAIpczhuIN52kOH75tHR4ol1aeuJlXmK+0OpnIvfaLLQ2iGfPVsgSxUjG33mCOuGp59PR4C1ypu7/Xw7PqMb9jVZSOK4BC2mdEN+DepthjkAPJIwjc9h6TxRLOnHAgYi2AKzxmAM+KdM7nTPtmEejc3d+GqMLJ1aPiRbYTfsj3bgPgM9O5X+2s9F0O1D4ujY4Ah1u/nHA+PGYFSZDNw3UEENzDRbnA29OF4o9s+vaxEOmooaRmbaMK/eGVbDHLZzYD8otCBsq83T2Et0+uYoqaYaPTqxLCfNsbiZX+vjV9HMPpLMvP602b+YtK5uQSspaClpXfli295D0/svPybMfLwvtgqtpYAFimxKloH7lzgDa3Ndfmyg6vp7XwbAW6cggqQCsCpJWdUf7Fw9i1BJUb4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image1' title='' src='/static/b6d6249bb2396209e7c2db975186ba32/ca1dc/image1.png' srcset='/static/b6d6249bb2396209e7c2db975186ba32/e7570/image1.png 170w,\n/static/b6d6249bb2396209e7c2db975186ba32/f46e7/image1.png 340w,\n/static/b6d6249bb2396209e7c2db975186ba32/ca1dc/image1.png 680w,\n/static/b6d6249bb2396209e7c2db975186ba32/02d09/image1.png 1020w,\n/static/b6d6249bb2396209e7c2db975186ba32/9d567/image1.png 1360w,\n/static/b6d6249bb2396209e7c2db975186ba32/e8464/image1.png 1536w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>서론</h2>\n<p>지난 <a href=\"https://sharknia.github.io/%EC%95%88%EC%A0%84%ED%95%9C-%EB%A0%88%EA%B1%B0%EC%8B%9C-%ED%83%88%EC%B6%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B3%84%ED%9A%8D-%EC%84%A4%EA%B3%84\">안전한 레거시 탈출을 위한 Strangler Fig 패턴 설계기</a>에서는, Django 1.11 기반의 레거시 시스템을 현대화하기 위한 전체적인 '점진적 교체' 전략을 소개했습니다. 그리고 글의 말미에, 보통이라면 가장 큰 장애물일 '인증' 문제는 기존 토큰 방식을 공유하면 간단히 해결될 것이라 낙관했습니다.</p>\n<p>하지만, 이 낙관적인 가정은 설계가 깊어지면서 몇 가지 문제들에 마주쳤습니다.</p>\n<p>이번 글에서는 그 '간단할 것이라 믿었던' 인증 문제가 왜 큰 걸림돌이 되었는지, 그리고 이를 해결하기 위해 어떤 아키텍처를 최종적으로 설계했는지 상세히 다루어보고자 합니다. 이 글에 담긴 내용은 실제 코드가 아닌, 본격적인 구현에 앞서 문제점을 예측하고 해결책을 찾아낸 과정입니다.</p>\n<h2>인증에서 발생할 문제</h2>\n<p>1부에서 세웠던 초기 계획, 즉 \"v1과 v2가 동일한 토큰 테이블을 조회하여 인증을 처리한다\"는 아이디어는 두 가지 치명적인 결함을 가지고 있었습니다.</p>\n<h3>1. 인증 방식의 충돌</h3>\n<p>V1에서는 이미 업데이트가 멈춘 <code class=\"language-text\">django-rest-auth</code> 구버전을 사용 중이었습니다. V2에서 이를 계승하는 <code class=\"language-text\">dj-rest-auth</code>를 설치할 경우, Token을 위한 DB 스키마가 정면으로 충돌하게 됩니다. 토큰 스키마를 V2에 맞게 수정한다면 V1 서비스는 즉시 마비될 것이므로, 이 방법은 선택할 수 없었습니다.</p>\n<p>사실 이 문제는 이미 로컬에서 V1 프로젝트의 업그레이드를 시도하며 겪었던 문제였습니다. 하지만 3달 넘게 다른 업무를 하느라 이 중요한 사실을 까맣게 잊고 있었습니다. (머쓱)</p>\n<h3>2. '두 개의 문'이 야기하는 세션 불일치</h3>\n<p>더 근본적인 문제는, 라이브러리 사용 여부와 관계없이 발생했습니다. 1부의 계획대로 V1과 V2가 각자의 로그인 API를 유지한다면, 사용자가 어느 문으로 들어왔는지에 따라 인증 상태가 달라지는 '세션 상태 불일치'가 발생합니다.</p>\n<ul>\n<li>예상 시나리오: 사용자가 V1 로그인 API로 로그인 -> 레거시 토큰만 발급됨 -> V2 서비스 접근 시 인증된 토큰이 없으므로 '미로그인' 상태가 됨.</li>\n</ul>\n<p>결국 '기존 인증 방식을 공유'하는 것만으로는 SSO 달성이 불가능하며, 점진적 교체 전략 전체를 위협하는 심각한 블로커(Blocker)임을 설계 단계에서 인지하게 되었습니다.</p>\n<h2>해결책 구상</h2>\n<h3>첫 번째 구상: Unmanaged 모델을 통한 레거시 인증 모방</h3>\n<p>가장 먼저 떠올린 방법은, V2에서도 V1의 인증 방식을 그대로 사용하는 것이었습니다. V1의 <code class=\"language-text\">authtoken_token</code> 테이블과 동일한 Unmanaged 모델(<code class=\"language-text\">class Meta: managed = False</code>)을 V2에 만들고, 커스텀 인증 클래스를 통해 레거시 토큰을 읽어오는 방식입니다.</p>\n<p>이 방법은 기술적으로는 가능했지만, 치명적인 단점이 있었습니다. V2마저 낡은 인증 방식에 종속된다는 점입니다. 신규 서비스에 확장성 있는 현대적인 인증 체계를 도입하려던 원래의 목표를 전혀 달성할 수 없었습니다. 이것은 '현대화'가 아닌, '레거시의 확장'일 뿐이었습니다.</p>\n<h3>두 번째 구상: JWT 도입과 '두 개의 토큰' 전략</h3>\n<p>그래서 방향을 틀기로 했습니다. V2는 V2답게 현대적인 JWT를 사용하고, V1과의 호환성은 다른 방법으로 해결하는 것입니다. 여기서 'V2가 두 가지 토큰을 모두 발급하면 어떨까?'라는 생각을 해봤습니다. V2가 인증의 중심이 되어, 자신을 위한 JWT와 V1을 위한 레거시 토큰을 동시에 발급하고 관리하는 것입니다.</p>\n<p>이 아이디어를 발전시켜 최종 설계를 완성했습니다.</p>\n<h2>최종 설계: '중앙 관제탑' 모델</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    핵심 아이디어: 인증 권한을 신규 시스템(V2)으로 중앙집중화하여, V2가 레거시 시스템을 위한 인증까지 대행하는 '중앙 관제탑(Central Control Tower)' 모델을 설계하기로 했습니다.</code></pre></div>\n<h3>대원칙: 인증 권한의 중앙 집중화</h3>\n<p>모든 문제의 근원인 '상태 불일치'를 해결하기 위해, 인증을 처리하는 권한과 책임을 반드시 한 곳으로 모아야 한다는 결론에 도달했습니다.</p>\n<h3>1단계: V2의 '중앙 관제탑' 구축</h3>\n<ol>\n<li>JWT 인증 시스템 도입: V2 내부 API 통신을 위해 <code class=\"language-text\">djangorestframework-simplejwt</code> 등을 사용하여 표준 JWT 인증 시스템을 구축하기로 했습니다. 또, V2 인증은 구버전 레거시 토큰, 새 버전 jwt에 대해 모두 정상 인증 작동하게 구현합니다. </li>\n<li>Unmanaged 모델 생성: (첫 번째 구상에서 사용했던) V1 <code class=\"language-text\">authtoken_token</code> 테이블과 동일한 Unmanaged 모델을 V2에 유지하여, 마이그레이션 없이 레거시 테이블을 읽고 쓸 수 있도록 설계했습니다.</li>\n<li>\n<p>통합 로그인/로그아웃 API 구현: V2에 다음과 같이 동작하는 엔드포인트를 구현하기로 했습니다.</p>\n<ul>\n<li><strong>로그인 시:</strong> 사용자 인증 성공 후, ① V2를 위한 JWT를 생성하고, ② 동시에 Unmanaged 모델을 통해 V1을 위한 레거시 토큰을 DB에 생성/갱신합니다. 그리고 두 토큰을 모두 클라이언트에게 반환합니다.</li>\n<li><strong>로그아웃 시:</strong> JWT를 무효화하는 로직과 함께, DB에서 레거시 토큰을 삭제하는 로직을 수행합니다.</li>\n</ul>\n</li>\n</ol>\n<h3>2단계: 클라이언트-서버 간 API Contract</h3>\n<ul>\n<li>프론트엔드: 로그인 성공 시 jwt, 레거시 토큰을 레거시 토큰만 사용해도 v1/v2 api에 대해 모두 인증이 가능합니다. 다만, 추후 jwt만 사용하기 위해 밑작업을 미리 진행해둘 수 있습니다. 이 또한 점진적 전환입니다. </li>\n</ul>\n<h2>최종 검토: 더 나은 방법은 없었는가?</h2>\n<p>이 복잡한 설계를 마치고, '혹시 업계 표준으로 불리는 더 일반적인 방법이 있지 않았을까?'라는 마지막 고민을 했습니다. 결론적으로 API 게이트웨이나 별도의 인증 서버(IdP) 구축 같은 표준 패턴들은 'V1 코드 변경 최소화'라는 핵심 제약 조건에 위배되거나 단순히 문제의 책임을 이동시킬 뿐이었습니다.</p>\n<p>이 검토를 통해 우리가 설계한 '중앙 관제탑' 모델이, 주어진 특수한 제약 조건 하에서는 가장 실용적이고 최적화된 해결책임을 확신할 수 있었습니다.</p>","frontmatter":{"title":"설계 중 만난 장애물","date":"June 25, 2025","update":"July 01, 2025","tags":["Django","BackEnd","Python"],"series":"Django Upgrade"},"fields":{"slug":"/설계-중-만난-장애물/","readingTime":{"minutes":9.32}}},"seriesList":{"edges":[{"node":{"id":"c76b7fdb-3f26-5c95-907d-424c078a8ca9","fields":{"slug":"/안전한-레거시-탈출을-위한-계획-설계/"},"frontmatter":{"title":"안전한 레거시 탈출을 위한 계획 설계"}}},{"node":{"id":"b82c89be-1529-5999-9daa-9bd3fe7ad2d5","fields":{"slug":"/설계-중-만난-장애물/"},"frontmatter":{"title":"설계 중 만난 장애물"}}}]},"previous":{"fields":{"slug":"/안전한-레거시-탈출을-위한-계획-설계/"},"frontmatter":{"title":"안전한 레거시 탈출을 위한 계획 설계"}},"next":null},"pageContext":{"id":"b82c89be-1529-5999-9daa-9bd3fe7ad2d5","series":"Django Upgrade","previousPostId":"c76b7fdb-3f26-5c95-907d-424c078a8ca9","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}