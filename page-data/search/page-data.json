{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"열정 추가로 더 진행해버렸다. 정말로 여기까지만 하려고 한다. 오랜만에 탄력 받으니 계속 하게 되어버렸다.  구현 내용 콜아웃, 디바이더, 인용문, 코드, 번호 매기기 , 글머리 기호 목록 컨버터를 추가했다.  콜아웃, 디바이더 html로 구현했다. 인용문은 hr 태그로 처리했으며, 콜아웃은 div 태그를 사용했다. 다만 콜아웃은 스타일 처리가 필요하다.…","fields":{"slug":"/NotionAPI를활용한자동포스팅5/"},"frontmatter":{"date":"January 28, 2024","title":"NotionAPI를 활용한 자동 포스팅(5)","tags":["Blogging","Notion-API","Typescript"]},"rawMarkdownBody":"## 열정\n\n추가로 더 진행해버렸다. 정말로 여기까지만 하려고 한다. 오랜만에 탄력 받으니 계속 하게 되어버렸다. \n\n## 구현 내용\n\n콜아웃, 디바이더, 인용문, 코드, 번호 매기기 , 글머리 기호 목록 컨버터를 추가했다. \n\n### 콜아웃, 디바이더\n\nhtml로 구현했다. 인용문은 hr 태그로 처리했으며, 콜아웃은 div 태그를 사용했다. 다만 콜아웃은 스타일 처리가 필요하다. 지금은 대충 태그만 만들어놨다. 따라서 이건 미완성이나 다름없다. \n\n```typescript\nprivate convertCallout(calloutBlock: any): string {\n        const textContent = calloutBlock.rich_text\n            .map((textElement: any) => this.formatTextElement(textElement))\n            .join('');\n        const icon = calloutBlock.icon ? calloutBlock.icon.emoji : '';\n        const color = calloutBlock.color\n            ? calloutBlock.color\n            : 'gray_background';\n\n        return `\n    <div class=\"callout ${color}\">\n        ${icon} <span>${textContent}</span>\n    </div>\\n`;\n    }\n\nprivate convertDivider(): string {\n        return `<hr style=\"border: none; height: 1px; background-color: #e0e0e0; margin: 16px 0;\" />\\n`;\n    }\n```\n\n### 인용문\n\n인용문은 있을 줄 몰랐는데, 마크다운에서 지원을 해서 쉽게 구현했다. \n\n무엇은 지원하고 무엇은 지원안하고, 기준을 명확히 모르겠긴하다. \n\n```typescript\nprivate convertQuote(quoteBlock: any): string {\n        const quoteText = quoteBlock.rich_text\n            .map((textElement: any) => this.formatTextElement(textElement))\n            .join('');\n\n        return `> ${quoteText}\\n\\n`;\n    }\n```\n\n### 번호 매기기, 글머리 기호 \n\n둘은 구현이 상당히 비슷했다. 마치 세트와 같다. 이걸 구현할 때에, 들여쓰기를 하려면 계층 개념이 필요해서 전체적인 코드 수정이 한 번 이뤄졌다. \n\n```typescript\nprivate formatListItemContent(listItemBlock: any): string {\n        return listItemBlock.rich_text\n            .map((textElement: any) => this.formatTextElement(textElement))\n            .join('');\n    }\n\n    private convertNumberedList(listItemBlock: any): string {\n        const listItemContent = this.formatListItemContent(listItemBlock);\n        const indent = ' '.repeat(this.indentLevel * 2);\n        return `${indent}1. ${listItemContent}\\n`;\n    }\n\n    private convertBulletedList(listItemBlock: any): string {\n        const listItemContent = this.formatListItemContent(listItemBlock);\n        const indent = ' '.repeat(this.indentLevel * 2);\n        return `${indent}- ${listItemContent}\\n`;\n    }\n```\n\n띄어쓰기 네 번으로 계층을 구분한다. \n\n### 코드 \n\n코드도 쉬웠다. 마크다운에서 지원하는 것은 기본적으로 구현이 쉽다. \n\n```typescript\nprivate convertCode(codeBlock: any): string {\n        const codeText = codeBlock.rich_text\n            .map((textElement: any) => textElement.plain_text)\n            .join('');\n\n        const language = codeBlock.language || '';\n\n        return `\\`\\`\\`${language}\\n${codeText}\\n\\`\\`\\`\\n\\n`;\n    }\n```\n\n### to_do\n\nto_do도 간단하게 구현했다. 마크다운에서는 체크박스인데, 노션에서는 할 일 목록이다.. 그래서 체크박스를 체크하면 스타일이 추가되는데.. 이것까진 따로 구현하지 않았다. \n\n```typescript\nprivate convertToDo(toDoBlock: any): string {\n        const quoteText = toDoBlock.rich_text\n            .map((textElement: any) => this.formatTextElement(textElement))\n            .join('');\n        let pre = '- [ ]';\n        if (toDoBlock.checked == true) {\n            pre = '- [x]';\n        }\n        return `${pre} ${quoteText}\\n\\n`;\n    }\n```\n\n## 정리 \n\n### 작업 완료 블록\n\n일단 1차적으로 작업이 완료되었으며, 완료된 지원하는 블록 타입은 다음과 같다. \n\n- paragraph\n\n- heading_1, heading_2, heading_3\n\n- bookmark\n\n- link_to_page\n\n- image\n\n- callout\n\n- divider\n\n- quote\n\n- code\n\n- numbered_list_item\n\n- bulleted_list_item\n\n- to_do\n\n### 작업 예정 블록\n\n#### table, table-row\n\n꼭 필요해보이지만, 구현을 위해서는 현재 구현된 블록의 재귀 호출 구조를 바꿔야 한다. 상대적으로 까다로워 오늘 작업하진 않겠다. \n\n### 작업 미정 블록\n\n#### column (n개의 열로 구성된 블록 생성)\n\n가로로 여러 블록을 놓는 기능이다. 굳이 필요한가? 싶기도 하고 또 구현이 꽤나 까다로워 보인다. 다만 table, table-row를 작업할 때에 호출 구조를 잘 짜놓는다면 또 별 노력 없이 잘 될 것 같기도 한데, 마크다운에 원래 가로를 나누는 기능이 있는지는 또 모르겠다. 그래서 미정이다. \n\n#### 미디어 관련 블록\n\n미디어 관련 기능도 지금보니 노션에 있다. 이건.. 할만하지 않을까? 고려해보겠다. 아직 자세히 살펴보지 못했다. \n\n### 미구현 확정 블록\n\n#### 토글\n\n토글은 미구현 확정이다. 토글은 마크다운에서 지원하지 않고, 만약 하려면 부트스트랩의 collapse 같은 기능을 직접 구현해야 할 것 같다. 이건 쉽지 않다. \n\n#### 임베드 관련 블록\n\n기각이다. 블로그 글에 임베드는 쓰지 말자. \n\n#### 고급 블록\n\n지금보니 토글도 고급에 들어있다. 마크다운 기본 기능이 아닌 것들은 기본적으로 구현에 한계가 있다. 다시 보니 column도 고급에 있다. \n\n나중에 추후 시간이 되면 만들만한 것들은 한 번 고려해보겠다. \n\n#### 데이터베이스 관련 블록\n\n웹사이트에 넣을 수 있는 기능이 (아마도) 아니다. 기각이다. \n\n## 다음 작업 예정은? \n\n이제 배포 자동화를 목표로 해야 한다. 자동화까지 해둬야, 이 프로젝트를 만든 목적 달성이 아닐까? 얼른 자동화도 하고 싶다..\n\n자동화의 자세한 로직은 다음번에 설계 하도록 하겠다.. \n\n"},{"excerpt":"타입스크립트의 Union Type 타입스크립트에는 유니언 타입이라는게 있다. 쉽게 말해 값이 여러 타입을 or 로 가질 수 있는 것이다. *막나간다. * 두 개의 이상의 타입을  기호를 사용해 결합하면 유니언 타입이 된다. 이를 통해 변수가 함수 매개변수가 여러 타입 중 하나의 타입을 가질 수 있음을 나타낼 수 있다.  장점 유연성 다양한 타입을 하나의 …","fields":{"slug":"/UnionType/"},"frontmatter":{"date":"January 28, 2024","title":"Union Type","tags":["Typescript","Python"]},"rawMarkdownBody":"## 타입스크립트의 Union Type\n\n타입스크립트에는 유니언 타입이라는게 있다. 쉽게 말해 값이 여러 타입을 or 로 가질 수 있는 것이다. ~~*막나간다. *~~\n\n두 개의 이상의 타입을 `|` 기호를 사용해 결합하면 유니언 타입이 된다. 이를 통해 변수가 함수 매개변수가 여러 타입 중 하나의 타입을 가질 수 있음을 나타낼 수 있다. \n\n```typescript\ntype StringOrNumber = string | number;\n\nlet value: StringOrNumber;\n\nvalue = 'Hello'; // 유효함\nvalue = 123;     // 유효함\n```\n\n### 장점\n\n#### 유연성\n\n다양한 타입을 하나의 변수에 할당할 수 있어 다양한 시나리오에 대응할 수 있다. \n\n#### 타입 안정성 보장\n\n유니언 타입을 사용하면 타입스크립트 컴파일러가 타입 안정성을 체크해준다. 즉, 할당된 값이 유니언 타입에 명시된 타입 중 하나와 일치하지 않으면 오류를 발생시킨다. \n\n#### 코드 간결성\n\n복잡한 조건에 대한 타입을 간결하게 표현할 수 있다. \n\n### 유니언 타입 사용 시 고려할 사항\n\n#### 타입 가드\n\n유니언 타입은 여러 타입을 허용하기 때문에 실행 시점에 정확한 타입을 확인하기 위해 타입 가드를 사용해야 한다. \n\n```typescript\nfunction process(value: StringOrNumber) {\n    if (typeof value === 'string') {\n        // value는 여기서 string 타입입니다.\n    } else {\n        // value는 여기서 number 타입입니다.\n    }\n}\n```\n\n#### 공통 필드 사용\n\n유니언 타입의 모든 구성원이 공통으로 가진 필드나 메소드에만 접근할 수 있다. 공통되지 않은 필드에 접근하려면 타입 가드를 사용해야 한다. \n\n#### 복잡한 유니언 타입\n\n유니언 타입이 복잡해질 수록 그 타입을 사용하는 코드는 더 복잡해질 수 있다. 따라서 타입을 너무 복잡하게 만들지 않도록 주의해야 한다. \n\n## 파이썬의 Union Type\n\n여기까지 알아보다가 파이썬에서도 왠지 비슷한게 있을 것 같다는 생각이 들어서 찾아봤고, 역시 있음을 알게 됐다. \n\n파이썬은 타입스크립트와 다르게 동적 타이핑 언어이지만 3.5 이상에서는 타입 힌팅을 사용하여 비슷한 기능을 구현할 수 있고, 3.10 이상에서는 `Union` 대신 `|` 연산자를 이용하여 유니언 타입을 정의할 수 있다. \n\n### 파이썬 3.9 이전\n\ntyping 모듈의 Union 을 사용하여 나타낼 수 있다. \n\n```python\nfrom typing import Union\n\ndef process(value: Union[str, int]):\n    print(value)\n```\n\n### 파이썬 3.10 이상\n\n```python\ndef process(value: str | int):\n    print(value)\n```\n\n### 타입스크립트의 Union Type과 다른 점\n\n파이썬은 동적 타이핑 언어이므로 이 제약은 파이썬의 실행에 영향을 미치지 않는다. 즉 런타임에서 타입 안전을 강제하지 않는다. \n\n단순히 개발자의 가독성 향상, IDE의 자동완성 지원, mypy등 정적 타입 체킹 도구를 위한 것이다. \n\n저렇게 해두어도 런타임에서 다른 타입의 값이 할당될 수 있음을 주의해야 한다. \n\n## 사담\n\n노션 API를 활용한 블로그 쉽게 하는걸 만들다가 타입이 복잡하게 선언되어있는걸 보고 혹시나 해서 찾아봤더니 내 예상이 맞았다. \n\nC로 개발을 시작했어서 그런지 처음에 자바스크립트를 접하고 아주 재미있고 자유도가 높다고 생각했는데, 갈 수록 나 자신에게 쇠사슬이 묶여있는게 오히려 편하다고 느낀다. \n\n프로젝트 크기가 커질수록 더 그렇게 느끼는 것 같다. \n\n물론 이런 기능을 잘 활용하면 더 편할때도 많긴 하다. 코드가 짧아지는 것도 맞고..\n\n결국 내 자신이 잘하면 아무일도 안생길거라는 생각도 든다. \n\n\n\n"},{"excerpt":"개인적으로 나스를 하나 운영하고 있다.  이것저것 설정해서 쓰고 있는데, 어느 날 갑자기 토렌트 다운로드가 용량이 없다고 작동하지 않았다.  용량은 다음의 명령어를 통해 확인할 수 있다.  외장하든 왕 큰 놈을 달아서 사용하고 있는데, 오드로이드다보니 메인 OS가 깔리는 드라이브는 15gb짜리 작은 용량이다.. 그 드라이브가 100퍼센트 꽉 차 있었다. …","fields":{"slug":"/우분투용량관리/"},"frontmatter":{"date":"January 28, 2024","title":"우분투 용량 관리","tags":["Ubuntu"]},"rawMarkdownBody":"개인적으로 나스를 하나 운영하고 있다. \n\n이것저것 설정해서 쓰고 있는데, 어느 날 갑자기 토렌트 다운로드가 용량이 없다고 작동하지 않았다. \n\n용량은 다음의 명령어를 통해 확인할 수 있다. \n\n```bash\nfurychick@odroid:/HDD2/myHomePage$ df -h\nFilesystem      Size  Used Avail Use% Mounted on\ntmpfs           200M   29M  171M  15% /run\n/dev/mmcblk1p2   15G   15G     0 100% /\ntmpfs           996M     0  996M   0% /dev/shm\ntmpfs           5.0M     0  5.0M   0% /run/lock\n/dev/mmcblk1p1  128M   14M  114M  11% /media/boot\n/dev/sdb1       2.7T  656G  2.0T  26% /HDD2\n/dev/sda1        11T  8.3T  2.1T  80% /HDD\ntmpfs           200M     0  200M   0% /run/user/1000\n```\n\n외장하든 왕 큰 놈을 달아서 사용하고 있는데, 오드로이드다보니 메인 OS가 깔리는 드라이브는 15gb짜리 작은 용량이다.. 그 드라이브가 100퍼센트 꽉 차 있었다. \n\n다음의 명령어를 사용해 용량이 큰 디렉토리를 검색했다. 외장하드 경로는 제외하고 검색했다. \n\n```bash\nfurychick@odroid:/$ sudo du -h / --exclude=/HDD2 --exclude=/HDD | sort -hr | head -n 10\ndu: cannot read directory '/proc/sys/fs/binfmt_misc': No such device\ndu: cannot access '/proc/19035/task/19035/fd/3': No such file or directory\ndu: cannot access '/proc/19035/task/19035/fdinfo/3': No such file or directory\ndu: cannot access '/proc/19035/fd/4': No such file or directory\ndu: cannot access '/proc/19035/fdinfo/4': No such file or directory\n15G     /\n11G     /home/furychick\n11G     /home\n8.7G    /home/furychick/.forever\n2.2G    /var\n1.7G    /usr\n1.6G    /var/log\n1.5G    /var/log/journal/dc87f36fc06c441a85ff7269ba4d50fb\n1.5G    /var/log/journal\n1.3G    /usr/lib\n```\n\n아~ 개인 홈페이지를 돌리는 로그가.. 몇 년 째 사이트를 그냥 켜둔채로 방치하다 보니 9기가에 달하게 크게 자라 내 서버를 억누르고 있었다. \n\n당장 로그를 삭제해주었다. \n\n해피엔딩~\n\n\n\n"},{"excerpt":"지난 이야기 NotionAPI를 활용한 자동 포스팅(3) 간만에 복귀를 했다. 별건 아니고.. 그냥 복습을 했다.  오늘의 작업 block.ts 나머지 작업 지난번에 block.ts를 미완성 된 상태로 두었다. 타입 검사에서 걸린 상태로 일단 두었고, Union Type이라는 것이 있다는 것을 알게 되었다. 해당 내용에 대해서는 따로 정리 해두었다.  U…","fields":{"slug":"/NotionAPI를활용한자동포스팅4/"},"frontmatter":{"date":"January 27, 2024","title":"NotionAPI를 활용한 자동 포스팅(4)","tags":["Blogging","Notion-API","Typescript"]},"rawMarkdownBody":"## 지난 이야기\n\n[NotionAPI를 활용한 자동 포스팅(3)](https://sharknia.github.io/NotionAPI를활용한자동포스팅3)\n\n간만에 복귀를 했다. 별건 아니고.. 그냥 복습을 했다. \n\n## 오늘의 작업\n\n### block.ts 나머지 작업\n\n지난번에 block.ts를 미완성 된 상태로 두었다. 타입 검사에서 걸린 상태로 일단 두었고,\n\n```typescript\nexport type GetBlockResponse = PartialBlockObjectResponse | BlockObjectResponse;\n```\n\nUnion Type이라는 것이 있다는 것을 알게 되었다. 해당 내용에 대해서는 따로 정리 해두었다. \n\n[Union Type](https://sharknia.github.io/UnionType)\n\n \n\n### 로그 강화\n\n로그도 작업 순서에 맞게 찍히도록 강화했다. json 형태의 데이터여서 [object Object] 와 같이 찍히던 것도 제대로 내용물이 출력되도록 수정했다. 다음과 같은 코드로 json 형태의 데이터도 이쁘게 출력할 수 있다. \n\n```typescript\nconsole.log(\n            `convertParagraph - paragraph : ${JSON.stringify(\n                paragraph,\n                null,\n                2,\n            )}`,\n        );\n```\n\n### ConvertParagraph 완성\n\nparagraph는 노션 블록 타입 주으이 하나로, 텍스트의 기본 단위이다. 텍스트를 입력할 때 기본적으로 생성되는 블록 유형이다. \n\n이 블록 안에 들어있는 내용을 마크다운으로 바꿔주는 메소드를 완성했다. \n\n원본 노션의 내용은 다음과 같다. 일부러 여러가지 케이스를 집어넣었다. \n\n![](image3.png)\n이 paragraph블록의 데이터 형태는 다음과 같다. \n\n#### <u>노</u><u>~~션이~~</u> **좋습*****니다***..\n\n```json\n{\n  \"rich_text\": [\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"노\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": true,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \"노\",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"션이\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": true,\n        \"underline\": true,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \"션이\",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \" \",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \" \",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"좋습\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": true,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \"좋습\",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"니다\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": true,\n        \"italic\": true,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \"니다\",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"..\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \"..\",\n      \"href\": null\n    }\n  ],\n  \"color\": \"default\"\n}\n```\n\n#### `정말로`.. <span style=\"color: pink;\">좋아합니다</span>.. \n\n```json\n{\n  \"rich_text\": [\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"정말로\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": true,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \"정말로\",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \".. \",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \".. \",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \"좋아합니다\",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"pink\"\n      },\n      \"plain_text\": \"좋아합니다\",\n      \"href\": null\n    },\n    {\n      \"type\": \"text\",\n      \"text\": {\n        \"content\": \".. \",\n        \"link\": null\n      },\n      \"annotations\": {\n        \"bold\": false,\n        \"italic\": false,\n        \"strikethrough\": false,\n        \"underline\": false,\n        \"code\": false,\n        \"color\": \"default\"\n      },\n      \"plain_text\": \".. \",\n      \"href\": null\n    }\n  ],\n  \"color\": \"default\"\n}\n```\n\n이 중에서 밑줄과 색상은 기본적으로 마크다운에서 지원하지 않는 기능이므로 html 태그를 사용했다. 코드는 다음과 같다. \n\n```typescript\nprivate convertParagraph(paragraph: any): string {\n        let markdown = '';\n\n        for (const textElement of paragraph.rich_text) {\n            let textContent = textElement.plain_text;\n\n            // 텍스트 스타일링 처리\n            if (textElement.annotations.bold) {\n                textContent = `**${textContent}**`;\n            }\n            if (textElement.annotations.italic) {\n                textContent = `*${textContent}*`;\n            }\n            if (textElement.annotations.strikethrough) {\n                textContent = `~~${textContent}~~`;\n            }\n            if (textElement.annotations.code) {\n                textContent = `\\`${textContent}\\``;\n            }\n            if (textElement.annotations.underline) {\n                // 마크다운은 기본적으로 밑줄을 지원하지 않으므로, HTML 태그 사용\n                textContent = `<u>${textContent}</u>`;\n            }\n            // 색상 처리 (HTML 스타일을 사용)\n            if (textElement.annotations.color !== 'default') {\n                textContent = `<span style=\"color: ${textElement.annotations.color};\">${textContent}</span>`;\n            }\n            if (textElement.href) {\n                textContent = `[${textContent}](${textElement.href})`;\n            }\n            markdown += textContent;\n        }\n        console.log(\n            `convertParagraph - paragraph : ${JSON.stringify(\n                paragraph,\n                null,\n                2,\n            )}`,\n        );\n        markdown = markdown + '\\n\\n';\n        console.log(`convertParagraph - markdown : ${markdown}`);\n        return markdown; // 문단 끝에 줄바꿈 추가\n    }\n```\n\n각 문장은 각각 다음과 같이 변환된다. \n\n```bash\nconvertParagraph - markdown : <u>노</u><u>~~션이~~</u> **좋습*****니다***..\nconvertParagraph - markdown : `정말로`.. <span style=\"color: pink;\">좋아합니다</span>..\n```\n\n이를 vscode의 마크다운 편집 기능을 통해서 확인하면 다음과 같이 정상적으로 출력되는 것을 확인할 수 있다. \n\n![](image4.png)\n### 마크다운 파일 저장 기능 추가 \n\npage.ts에 block들로부터 받아온 마크다운 내용과 properties에 저장된 내용들을 합해 마크다운 파일로 저장하는 메소드를 완성했다. \n\n```typescript\npublic async printMarkDown() {\n        //contentMarkdown과 properties의 내용을 마크다운 파일로 저장한다.\n        try {\n            // 파일 이름 설정 (페이지 제목으로)\n            const filename = `${this.pageTitle}.md`;\n\n            // 마크다운 메타데이터 생성\n            const markdownMetadata = this.formatMarkdownMetadata();\n\n            // 마크다운 메타데이터와 contentMarkdown을 결합\n            const fullMarkdown = `${markdownMetadata}${this.contentMarkdown}`;\n\n            // 디렉토리 생성 (이미 존재하는 경우 오류를 무시함)\n            await fs.mkdir(this.pageUrl ?? '', { recursive: true });\n            const filePath = join(this.pageUrl ?? '', 'index.md');\n            // 결합된 내용을 파일에 쓰기 (이미 존재하는 경우 덮어쓰기)\n            await fs.writeFile(filePath, fullMarkdown);\n            console.log(`[page.ts] Markdown 파일 저장됨: ${filePath}`);\n        } catch (error) {\n            console.error(`[page.ts] 파일 저장 중 오류 발생: ${error}`);\n        }\n    }\n\n    private formatMarkdownMetadata(): string {\n        // properties를 마크다운 메타데이터로 변환\n        const metadata = [\n            '---',\n            `title: \"${this.properties?.title ?? ''}\"`,\n            `description: \"${this.properties?.description ?? ''}\"`,\n            `date: ${this.properties?.date ?? ''}`,\n            `update: ${this.properties?.update ?? ''}`,\n            // tags가 배열인 경우에만 join 메소드를 호출\n            `tags:\\n  - ${\n                Array.isArray(this.properties?.tags)\n                    ? this.properties.tags.join('\\n  - ')\n                    : ''\n            }`,\n            `series: \"${this.properties?.series ?? ''}\"`,\n            '---',\n            '',\n        ].join('\\n');\n\n        return metadata;\n    }\n```\n\ngithub.io의 블로그 형식에 맞춰서 properties를 바꿔주고, 블로그 형식에 맞는 위치에 일단 마크다운 파일을 저장하게끔 해주었다. 아마, 추후 배포 방식에 따라 해당 위치는 바뀔 수 있을 것이다. 아직 정확하게 어떤 방식으로 블로그를 배포할 것인지까지는 고려하지 않았다. \n\n위 코드를 포함해서 실행하면, \n\n![](image5.png)\n이렇게 저장이 되고, \n\n![](image6.png)\n이렇게 깔끔하게 저장이 된다. 이제 앞으로는 각 블록 타입들에 대한 변환을 추가하면 된다!\n\n### BlockObjectResponse 분석\n\n실질적으로 컨텐츠들은 BlockObjectResponse 타입들로 이루어져있다. BlockObjectResponse는 다음의 Union Type이다. \n\n```typescript\nexport type BlockObjectResponse = ParagraphBlockObjectResponse | Heading1BlockObjectResponse | Heading2BlockObjectResponse | Heading3BlockObjectResponse | BulletedListItemBlockObjectResponse | NumberedListItemBlockObjectResponse | QuoteBlockObjectResponse | ToDoBlockObjectResponse | ToggleBlockObjectResponse | TemplateBlockObjectResponse | SyncedBlockBlockObjectResponse | ChildPageBlockObjectResponse | ChildDatabaseBlockObjectResponse | EquationBlockObjectResponse | CodeBlockObjectResponse | CalloutBlockObjectResponse | DividerBlockObjectResponse | BreadcrumbBlockObjectResponse | TableOfContentsBlockObjectResponse | ColumnListBlockObjectResponse | ColumnBlockObjectResponse | LinkToPageBlockObjectResponse | TableBlockObjectResponse | TableRowBlockObjectResponse | EmbedBlockObjectResponse | BookmarkBlockObjectResponse | ImageBlockObjectResponse | VideoBlockObjectResponse | PdfBlockObjectResponse | FileBlockObjectResponse | AudioBlockObjectResponse | LinkPreviewBlockObjectResponse | UnsupportedBlockObjectResponse;\n```\n\n~~너무 많다~~\n\n일단, 많이 쓸 것 같은 블록들을 예제 파일로 만들고 해당 노션 파일들을 불러와보고 어떤 타입들을 사용하는지 살펴보기로 했다. 나머지는 모르겠다 아직은 그냥 미지원이다. \n\n![](image7.png)\n이것들을 넘는것은 내가 아직은 노션에 쓸 것 같지가 않다. 따라서 위의 블록들을 중점적으로 먼저 변환하기로 하자. \n\n다음의 녀석들이 그 녀석들이다. \n\n#### heading_ 시리즈\n\n제목1, 제목2, 제목3 들이다. heading_1부터 heading_3까지를 노션에서는 사용할 수 있는데, 각각 h2, h3, h4로 변환하면 될 것 같다. 이건 쉬울 것 같은 예감이 든다. \n\n#### bookmark\n\n북마크는 간단할 것 같지만, 간단하지 않은 점이 있다. 노션에는 페이지 링크 기능이 있는데, 이것도 가능하면 (페이지 링크도 어차피 내 블로그 글 일테니까, 아니 사용자가 그렇게 사용해야 한다. ) 블로그 글의 링크로 변환하고 싶다. 이게 가능할까? 이건 쉽지 않을 수도 있을 것 같은 생각이 지금은 든다. 생성된 페이지 링크와 페이지 아이디가 다르다면 근본적으로 불가능한 일이다. \n\n#### code\n\n코드 블록이다. 이건 쉬울 것 같다. \n\n#### table, table_row\n\n마크다운은 표 그리기가 까다롭다. 그래도 어떻게든 할 수 있지 않을까? \n\n#### bulleted_list_item\n\n글머리 기호이다. 이건.. 이건 쉽지 않을까? \n\n#### numbered_list_item\n\n번호 이것도 쉽지 않을까?? \n\n#### toggle\n\n토글도 어떻게든 되지 않을까? 다른것보단 복잡하겠지만 특별한 건 없을 것 같다. \n\n#### quote, divider, callout\n\n이 놈들도 특별한 어려움은 예상되지 않는다. 그냥 스타일이나 이쁘게 주면 될 것 같다. \n\n결국, 표나 북마크를 제외하면 나머지는 그냥 단순 노가다로 예상이 된다. \n\n### heading 시리즈 컨버터 생성\n\n이건 간단했다. 다만, 컨버팅 관련 내용이 길어질 것 같아 해당 역할을 하는 클래스 MarkdownConverter을 만들어서 이걸 이용하기로 했다. 이 클래스는 블록의 내용을 받아 markdown 문자열로 변환해서 리턴하는 역할을 한다. \n\nparagraph와 heading 시리즈에 겹치는 내용이 많다. 사실상 pre 태그만 다르다. 따라서 중복되는 내용을 formatTextElement 메소드로 분리했다. 아마 다른 타입에 대해서도 사용할 수 있을 것 같은 예감이 든다. \n\n완성된 코드는 다음과 같다. \n\n#### 코드 \n\n```typescript\nimport { BlockObjectResponse } from '@notionhq/client/build/src/api-endpoints';\n\nexport class MarkdownConverter {\n    private block: BlockObjectResponse;\n\n    private constructor(block: BlockObjectResponse) {\n        this.block = block;\n    }\n\n    public static async create(block: BlockObjectResponse): Promise<string> {\n        const converter: MarkdownConverter = new MarkdownConverter(block);\n        const result = await converter.makeMarkDown();\n        return result;\n    }\n\n    private async makeMarkDown(): Promise<string> {\n        let block = this.block;\n        let markdown: string = '';\n\n        console.log(\n            `[markdownConverter.ts] makeMarkDown : ${\n                block.type\n            } : ${JSON.stringify(block, null, 2)}`,\n        );\n\n        switch (block.type) {\n            // 텍스트의 기본 단위,텍스트를 입력할 때 기본적으로 생성되는 블록 유형\n            case 'paragraph':\n                markdown += this.convertParagraph(block.paragraph);\n                break;\n            case 'heading_1':\n                markdown += this.convertHeading(block.heading_1, 1);\n                break;\n            case 'heading_2':\n                markdown += this.convertHeading(block.heading_2, 2);\n                break;\n            case 'heading_3':\n                markdown += this.convertHeading(block.heading_3, 3);\n            // 다른 블록 유형에 대한 처리를 여기에 추가...\n            default:\n                console.warn(\n                    `[markdownConverter.ts] makeMarkDown : Unsupported block type - ${block.type}`,\n                );\n        }\n        return markdown;\n    }\n\n    private convertParagraph(paragraph: any): string {\n        let markdown = '';\n        for (const textElement of paragraph.rich_text) {\n            markdown += this.formatTextElement(textElement);\n        }\n        return markdown + '\\n\\n';\n    }\n\n    private convertHeading(heading: any, level: number): string {\n        let markdown = '';\n        const prefix = '#'.repeat(level + 1) + ' ';\n        for (const textElement of heading.rich_text) {\n            markdown += this.formatTextElement(textElement);\n        }\n        return prefix + markdown + '\\n\\n';\n    }\n\n    private formatTextElement(textElement: any): string {\n        let textContent = textElement.plain_text;\n\n        // 텍스트 스타일링 처리\n        if (textElement.annotations.bold) {\n            textContent = `**${textContent}**`;\n        }\n        if (textElement.annotations.italic) {\n            textContent = `*${textContent}*`;\n        }\n        if (textElement.annotations.strikethrough) {\n            textContent = `~~${textContent}~~`;\n        }\n        if (textElement.annotations.code) {\n            textContent = `\\`${textContent}\\``;\n        }\n        if (textElement.annotations.underline) {\n            textContent = `<u>${textContent}</u>`;\n        }\n        if (textElement.annotations.color !== 'default') {\n            textContent = `<span style=\"color: ${textElement.annotations.color};\">${textContent}</span>`;\n        }\n        if (textElement.href) {\n            textContent = `[${textContent}](${textElement.href})`;\n        }\n\n        return textContent;\n    }\n}\n```\n\n### convertLinkToPage 생성\n\n아까 북마크에 대해서 고려할 때, 페이지 링크가 어렵지 않을까? 고민했었는데 해당 문제는 해결이 가능했다. link_to_page 타입에서 페이지 아이디를 제공하고 있었고, 페이지 아이디를 API를 통해서 호출을 하면 해당 데이터를 가져오는 것이 가능했다. 이 경우에는 마크다운 파일은 필요없고 URL만 필요하므로, Page 클래스에 간단한 정보만 가져오는 메소드를 만들고 해당 메소드를 활용해 북마크를 생성해주었다. 또, 설정 파일에 블로그의 주소를 설정하도록 했다. \n\n```typescript\nexport class Page {\n    private pageId: string;\n    private notion: Client;\n\n    public properties?: Record<string, PropertyValue>;\n    public pageTitle?: string;\n    public pageUrl?: string;\n    public contentMarkdown?: string;\n\n    private constructor(pageId: string, notion: Client) {\n        this.pageId = pageId;\n        this.notion = notion;\n    }\n\n    private async init(page: Page) {\n        const properties = await page.getProperties();\n        page.properties = await page.extractDataFromProperties(properties);\n        page.pageUrl = `${\n            page.pageTitle\n                ?.trim()\n                .replace(/[^가-힣\\w\\-_~]/g, '') // 한글, 영어, 숫자, '-', '_', '.', '~'를 제외한 모든 문자 제거\n                .replace(/\\s+/g, '-') ?? // 공백을 하이픈으로 치환\n            ''\n        }`;\n    }\n\n\t\t.... 생략 ....\n\n    public static async getSimpleData(pageId: string) {\n        const notionApi: NotionAPI = await NotionAPI.create();\n        const page: Page = new Page(pageId, notionApi.client);\n        await page.init(page);\n        return {\n            pageTitle: page.pageTitle ?? '',\n            pageUrl: page.pageUrl ?? '',\n        };\n    }\n\n\t\t.... 생략 ....\n}\n```\n\n기존의 생성자 create 메소드와 중복되는 부분을 init 메소드로 분리하고, getSimpleData에서는 title, url만 리턴하도록 수정해주었다. \n\n```typescript\nprivate async convertLinkToPage(linkToPage: any): Promise<string> {\n        try {\n            const envConfig = EnvConfig.create(); // EnvConfig 인스턴스 생성\n            const blogUrl = envConfig.blogUrl; // blogUrl 가져오기\n            const pageId = linkToPage.page_id;\n            const pageData = await Page.getSimpleData(pageId);\n\n            const pageTitle = pageData.pageTitle;\n            const pageUrl = pageData.pageUrl;\n\n            return `[${pageTitle}](${blogUrl}/${pageUrl})\\n\\n`;\n        } catch (error) {\n            console.error('Error converting link_to_page:', error);\n            return '';\n        }\n    }\n```\n\n그리고 이렇게 해당 값과 설정값을 이용해 북마크를 연결할 주소를 만들었다. \n\n### Page 멘션 기능 대응\n\nPage Mention의 경우에는 특이하게 paragraph에 링크 관련 정보가 담겨서 온다. 해당 경우에 대응하기 위해 convertParagraph를 다음과 같이 수정해주었다. \n\n```typescript\nprivate async convertParagraph(paragraph: any): Promise<string> {\n        let markdown = '';\n        for (const textElement of paragraph.rich_text) {\n            if (\n                textElement.type === 'mention' &&\n                textElement.mention.type === 'page'\n            ) {\n                // mention 타입이고, page를 참조하는 경우\n                markdown += await this.convertMentionToPageLink(\n                    textElement.mention.page.id,\n                );\n            } else {\n                // 기타 텍스트 요소\n                markdown += this.formatTextElement(textElement);\n            }\n        }\n        return markdown + '\\n\\n';\n    }\n\n    private async convertMentionToPageLink(pageId: string): Promise<string> {\n        try {\n            const envConfig = EnvConfig.create(); // EnvConfig 인스턴스 생성\n            const blogUrl = envConfig.blogUrl; // blogUrl 가져오기\n            const pageData = await Page.getSimpleData(pageId);\n\n            const pageTitle = pageData.pageTitle;\n            const pageUrl = pageData.pageUrl;\n\n            return `[${pageTitle}](${blogUrl}/${pageUrl})`;\n        } catch (error) {\n            console.error('Error converting mention to page link:', error);\n            return '';\n        }\n    }\n```\n\n이로써 까다로울 것 같았던 두 가지에 대한 대응이 끝났고, 나머지는 노가다만 남은 것 같다!\n\n### imageConverter 구현\n\n이미지도 구현이 쉬웠다. 마크다운과 같은 폴더에 이미지를 다운로드 받고(amazone 저장소 주소가 API에서 제공된다. ) 캡션 형식으로 넣어주면 된다. \n\n```typescript\nprivate async convertImage(imageBlock: any): Promise<string> {\n        try {\n            const imageUrl = imageBlock.file.url;\n            const imageCaption =\n                imageBlock.caption.length > 0\n                    ? this.formatRichText(imageBlock.caption)\n                    : '';\n\n            // 이미지 이름을 순서대로 할당 (image1, image2, ...)\n            const imageName = `image${++MarkdownConverter.imageCounter}.png`;\n            const imageDownDir = `/${this.pageUrl}/${imageName}`;\n            const imagePath = join('contents/post', imageDownDir);\n\n            // 이미지 다운로드 및 로컬에 저장\n            const response = await axios.get(imageUrl, {\n                responseType: 'arraybuffer',\n            });\n            await fs.writeFile(imagePath, response.data);\n\n            // 마크다운 이미지 문자열 생성\n            let markdownImage = `![${imageCaption}](${imageName})\\n`;\n            if (imageCaption) {\n                markdownImage += `<p style=\"text-align:center;\"><small>${imageCaption}</small></p>\\n`;\n            }\n\n            return markdownImage;\n        } catch (error) {\n            console.error('Error converting image:', error);\n            return '';\n        }\n    }\n```\n\n단, 이 클래스는 상당히 분리되어있는 클래스여서 따로 저장될 곳의 디렉토리 명을 알 수 있는 방법이 없었다.. 어쩔 수 없이 Page클래스부터 계속해서 디렉토리 명을 던져줬다.. 깔끔하지 않다.. \n\n또, 저장될 디렉토리 (contents/post) 도 설정의 영역에 넣어야 할 것 같다. \n\n## 오늘의 마무리 \n\n오늘은 이 정도면 될 것 같다. 이미 핵심 부분은 모두 진행이 됐고, 앞으로는\n\n### 남은 타입별 구현\n\n콜아웃, devider, quote는 html, css의 영역으로 생각된다. 이건 추후 따로 정적 파일에 html, css를 추가하거나 해야 할 것 같다. 자세한 방법은 나중에 생각해보려고 한다. 오늘 다섯시간? 정도를 쉬지 않고 했더니 집중력이 많이 떨어진 게 느껴진다. \n\n토글도 의외로 까다로울지도? 뭐 초반엔 내가 그냥 토글을 노션에 안쓰면 되는거 아닐까? \n\n까다로운 부분은 많이 구현된 것 같다. 빠르면 내일, 열심히 한다면 이번주 안에 직접 사용을 해볼 수 있을 것 같다.\n\n\n\n"},{"excerpt":"지난시간 https://sharknia.github.io/Notion-Api-2/ 문제점 아무것도.. 기억이 나지 않는다.. 지난날의 나는 무엇이었나? 5개월만의 복귀가 이렇게 어렵다. 이래서 사람은 꾸준해야 한다.  잡설 최근 업무에 약~간의 여유가 생기면서 IDE를 파이참에서 vs code로 갈아탔다. 파이썬만 할 때에는 파이참이 유리한 것이 사실이지…","fields":{"slug":"/NotionAPI를활용한자동포스팅3/"},"frontmatter":{"date":"January 26, 2024","title":"NotionAPI를 활용한 자동 포스팅(3)","tags":["Blogging","Notion-API"]},"rawMarkdownBody":"## 지난시간\n\n[https://sharknia.github.io/Notion-Api-2/](https://sharknia.github.io/Notion-Api-2/)\n\n## 문제점\n\n아무것도.. 기억이 나지 않는다.. 지난날의 나는 무엇이었나? 5개월만의 복귀가 이렇게 어렵다. 이래서 사람은 꾸준해야 한다. \n\n## 잡설\n\n최근 업무에 약~간의 여유가 생기면서 IDE를 파이참에서 vs code로 갈아탔다. 파이썬만 할 때에는 파이참이 유리한 것이 사실이지만(심지어 속도도 파이참이 더 빠르다고 느꼈다. ) 추후 여러 언어를 다루게 될 경우 vs code가 유리한 점이 있다고 생각되어 갈아탔고, 환경 세팅을 다시 했다. \n\nformatter나 기타 여러가지 등등.. 그리고 타입스크립트 코드를 오랜만에 보면서 여기에도 formatter 설정을 추가해주었다. \n\n## 설계 되새김질\n\n코드를 다시 읽는데에만 시간을 꽤 투자했다. 예전의 나는 코드를 꽤 잘 짠 것 같다. \n\n블로그 글을 복습하지 않고 코드를 읽고 설계를 다시 했는데 오늘의 나는 예전의 나와 의견이 똑같다.~~ (진작 복습할걸)~~\n\n### 그래서 어떻게 할 것이냐? \n\n노션은 블록 기반의 구조로 이루어져있다. 그래서 나는 노션의 메인 데이터베이스를 블로그 홈이라고 가정하고, 그 안에 있는 블록들의 리스트는 페이지라고 정의하여, 페이지의 양식이나 속성은 고정해두려고 한다. 그리고 비로소 페이지안의 컨텐츠, 블록들을 마크다운으로 변환하려고 한다. \n\n그래서, Page.ts에서 페이지 들을 관리하고, Block.ts에서 블록들을 관리하려고 한다. 블록들은 각자 하위 블록을 다시 가질 수 있는 재귀적 형태를 가진다. \n\n콘텐츠들은 문단, 이미지, 리스트 등 여러 타입을 가지므로 경우에 따라서 block 클래스를 상속한 하위 클래스가 생길수도 있겠다. \n\n각자 블록들은 자신의 내용들을 마크다운으로 변환해서 상위 블록에게 전달하는 메소드를 갖는다. 가장 하위 블록부터 전달된 변경된 마크다운 내용들은 상위로 타고 올라가 결국 페이지 클래스에 전달된다. \n\n페이지 클래스는 이 마크다운들을 모아 파일로 저장한다. \n\n계획은 완벽해 보인다. \n\n하지만, 타입이 아주 많고 이걸 마크다운으로 변환하는 작업은 노가다 그 자체일것이다.. \n\n그래서 일단은 제한된 타입들에 대해서만 변환을 지원하려고 한다. \n\n## 그래서 오늘 작업은? \n\n일단 코드를 읽었고, 분석했고, 설계를 굳이 다시 하고 예전의 나와 의견이 같다는 점을 뒤늦게 확인했으며, \n\nblock.ts의 초안을 작성했다. \n\n```typescript\nimport { Client } from '@notionhq/client';\nimport { BlockObjectResponse } from '@notionhq/client/build/src/api-endpoints';\nimport { GetBlockResponse } from '@notionhq/client/build/src/api-endpoints';\n\nexport class Block {\n    private notion: Client;\n    private blockId: string;\n    private blockData?: GetBlockResponse;\n\n    constructor(notion: Client, blockId: string) {\n        this.notion = notion;\n        this.blockId = blockId;\n    }\n\n    public async getMarkdown(): Promise<string> {\n        this.blockData = await this.fetchBlockData();\n        return await this.processBlock(this.blockData);\n    }\n\n    private async fetchBlockData(): Promise<GetBlockResponse> {\n        return await this.notion.blocks.retrieve({ block_id: this.blockId });\n    }\n\n    private async processBlock(block: BlockObjectResponse): Promise<string> {\n        let markdown = '';\n\n        switch (block.type) {\n            case 'paragraph':\n                markdown += this.convertParagraph(block.paragraph);\n                break;\n            case 'heading_1':\n                markdown += `# ${block.heading_1.rich_text\n                    .map((t) => t.plain_text)\n                    .join('')}\\n\\n`;\n                break;\n            // 다른 블록 유형에 대한 처리를 여기에 추가...\n            default:\n                console.warn(`Unsupported block type: ${block.type}`);\n        }\n\n        // 하위 블록 처리 (재귀적)\n        if (block.has_children) {\n            markdown += await this.processChildBlocks(block.id);\n        }\n\n        return markdown;\n    }\n\n    private async processChildBlocks(blockId: string): Promise<string> {\n        const children = await this.notion.blocks.children.list({\n            block_id: blockId,\n        });\n        let markdown = '';\n        for (const child of children.results) {\n            markdown += await this.processBlock(child as BlockObjectResponse);\n        }\n        return markdown;\n    }\n\n    private convertParagraph(paragraph: any): string {\n        console.log('paragraph:' + paragraph);\n        return paragraph.rich_text;\n        // return paragraph.text.map((t) => t.plain_text).join('') + '\\n\\n';\n    }\n\n    // 기타 블록 유형에 대한 변환 함수를 여기에 추가...\n}\n```\n\n완전히 지극히 초안 그 자체이다. 기초적인 형태만 잡았다. 아직 리턴값에 대한 이해가 충분하지 않아, 해당 부분에 대한 조정이 필요하다. (심지어 오류가 나는 상태이다)\n\n블록의 타입이 모두 정의가 되어있으므로, 해당 타입에 따른 각 클래스를 따로 생성할 필요도 느낀다. 모두 여기에 집중된다면 코드가 너무 길어질 것 같다. \n\n## 결론\n\n결국 오늘은 한 일이 별로 없다.. 복귀에 의의를 두자. \n\n"},{"excerpt":"개발중인 서비스에서 Postgresql을 적용한지 이제 한달 조금 더 지났다.  아직 DB 마이그레이션 작업은 거의 되지 않았으므로, 실제로 Postgresql DB를 이용하는 서비스는 그다지 많지 않았다.  새로 업데이트 하는 기능들에 대해서는 적극적으로 Postgresql을 이용하기로 했고, 이번에 새로 퀴즈 기능을 개발하면서 이 기능은 전부 RDB …","fields":{"slug":"/SqlAlchemy의QueuePool/"},"frontmatter":{"date":"January 18, 2024","title":"SqlAlchemy의 QueuePool","tags":["SqlAlchemy","DataBase","Python"]},"rawMarkdownBody":"개발중인 서비스에서 Postgresql을 적용한지 이제 한달 조금 더 지났다. \n\n아직 DB 마이그레이션 작업은 거의 되지 않았으므로, 실제로 Postgresql DB를 이용하는 서비스는 그다지 많지 않았다. \n\n새로 업데이트 하는 기능들에 대해서는 적극적으로 Postgresql을 이용하기로 했고, 이번에 새로 퀴즈 기능을 개발하면서 이 기능은 전부 RDB 기반으로 만들어졌다. \n\n퀴즈 기능의 개발은 유저의 접속률을 늘리기 위한 것으로, 모든 테스트를 마친 후 실서버에 배포가 되고 클라이언트까지 패치가 된 후 당당하게 퀴즈 풀러 오시라고 사용자들에게 푸시를 날렸다. \n\n그리고 펑! 서버가 터졌다. \n\n## 현상\n\n실제 서비스가 엄청나게 느리거나 거의 작동하지 않았다. \n\nPostgresql DB와 연결된 API들이 작동하지 않았다. \n\n서버에서는 `QueuePool limit of size 5 overflow 10 reached, connection timed out, timeout 30.00` 오류가 대량으로 발생했다. \n\n서버 모니터링 결과 푸쉬 직후 대량의 트래픽이 집중적으로 발생했다. \n\nFlarelane을 통해 확인한 결과, 2000명 정도가 동시 접속을 시도했다. \n\nSupabase의 DB 커넥션이 순간적으로 크게 늘어났다. (풀러를 사용중인데도 불구하고)\n\n\n\n시간이 지나면서 (약 10분이 안되는 짧은 시간) 트래픽이 줄어들고 자연스럽게 오류가 줄고, 서비스가 정상화되었다. \n\n## 원인 파악 및 해결\n\nSqlalchemy의 QueuePool을 현재 지금 pool size 5, max overflow 10으로 맞춰놓았었는데, 트래픽이 증가하면서 QueuePool의 한도가 다 차고, 대다수 요청이 최대 대기 시간 30초를 꽉 채워 대기하다가 오류가 발생했다. \n\n조사 결과, 대다수 많은 실제 서비스에서 해당 설정값은 대체적으로 너무 적어 값을 늘려서 사용한다고 한다. 정확한 값을 찾기 위해서는 여러번의 테스트가 필요하며, 점진적으로 늘려가면서 적당한 값을 찾아야 한다고 한다. \n\nsupabase 기반의 postgresql을 사용하고 있는데, 일단 postgresql의 connection 여유는 충분한 상황이었으므로 일단 설정값을 pool size 10, max overflow 20으로 각각 두배로 늘려주었다. \n\n이벤트나, 푸쉬가 있을 경우 추가적인 모니터링이 필요할 것이다. \n\n## Sqlalchemy의 QueuePool\n\n데이터베이스 Connection은 리소스가 많이 필요하다. QueuePool은 이런 Connection을 효율적으로 관리하여 성능을 향상시키기 위해 만들어졌다. Connection을 빠르게 재사용함으로써, 애플리케이션의 반응 시간을 단축 시키고 부하 상황에서도 안정적으로 동작하도록 한다. \n\nQuepool은 내부적으로 Connection 객체들을 큐로 관리한다. 동시성을 고려하여 설계되어 여러 스레드 또는 프로세스에서 안전하게 사용될 수 있다. \n\n### QueuePool의 생명주기 \n\n#### 생성\n\nQueuePool은 Sqlalchemy 엔진이 생성될 때 함께 생성된다. 이 때 데이터베이스와의 Connection 설정이 정의된다. \n\n#### Connection 관리 \n\n애플리케이션에서 데이터베이스 Connection이 필요할 때, QueuePool이 Connection을 제공한다. 사용 가능한 Connection이 없으면 새 Connection을 생성하거나 대기열에서 Connection을 기다린다. \n\n#### Connection 반환\n\n작업이 완료되면 Connection은 Pool에 반환되어 재사용된다. \n\n#### 종료\n\n애플리케이션 종료와 함께 Pool에 있는 모든 Connection이 안전하게 종료된다. \n\n### 작동\n\nQueuePool은 기본적으로 미리 설정된 `pool_size` 내에서 Connection을 관리한다. 사용 가능한 Connection이 있다면 그 연결을 제공하고, 없으면 새로은 Connection을 생성한다. \n\n`pool_size`는 동시에 활성화 할 수 있는 최대 연결수이다. 만약 이 한계를 초과한다면, `max_overflow` 에 설정된 값에 따라 추가 Connection을 생성한다. `max_overflow` 는 `pool_size` 를 초과하여 생성할 수 있는 추가 연결의 최대 수이다. \n\n`max_overflow` 까지 초과한다면 추가 Connection 연결 요청은 대기열에 들어가며 사용 가능한 Connection 이 생길때까지 대기한다. 이 때, 연결 대기 시간이 `timeout` 설정을 초과하면 연결 요청은 실패한다. \n\n#### pool_size\n\n이 설정은 가능한 최대 연결의 최대 수를 정의 하는 것이므로, 5로 설정했다고 해서 실제 연결이 5개가 유지되는 것은 아니다. 사용되지 않는 Connection은 pool에 반환되며, 유휴 상태로 남아있다가 `recycle` 설정 시간을 넘어서면 끊어진다. \n\n#### max_overflow\n\npool_size를 초과하는 최대 개수를 정의한다. pool_size 가 5이고, max_overflowrk 10이라면 동시에 최대 5+10 = 15개의 연결을 허용하는 것이다. max_overflow에 해당되어 생성된 Connection이라 할지라도 사용 후에 풀에 반환된다(바로 끊어지는 것이 아니다). 다만, 해당 Connection은 pool_size의 기본 한계를 넘어선 것이므로 풀에서 더 높은 우선 순위로 종료될 수 있다. \n\n### Sqlalchemy의 풀링 전략\n\nSqlalchemy의 기본 풀링 전략은 Queuepool이지만, 이외에도 다른 전략들이 있다. \n\n### StaticPool\n\n연결의 고정된 집합을 유지한다. 모든 Connection 요청은 이 고정된 집합에서 제공된다. 단일 사용자 또는 단일 프로세스 어플리케이션에 적합하다. \n\n### NullPool\n\nConnection Pooling을 사용하지 않는다. 매 요청마다 새로운 DB Connection이 열리고 작업 종료 후 Connection이 닫힌다. \n\n매우 드문 요청이 있는 어플리케이션에 적합하다. \n\n### Singleton ThreadPool\n\n각 스레드에 대해 하나의 Connection을 유지한다. 스레드마다 고유한 Connection을 사용한다. \n\n멀티 스레드 환경에서 각 스레드가 자체 Connection을 가질 필요가 있을 때 유용하다. \n\n\n\n"},{"excerpt":"결론 supabase 기준, Sqlalchemy의 비동기 엔진에서 Postgresql pooler (supavisor)에 오류 없이 연결하기 위해서는  을 다음과 같이 구성해주면 된다.  statementcachesize, preparedstatementcache_size를 둘 다 모두 0으로 줘야 한다. 그리고 왜 발생하는지 모르겠는 간헐적인 오류(캐싱…","fields":{"slug":"/Sqlalchemy비동기엔진에서의PostgresqlPooler/"},"frontmatter":{"date":"January 09, 2024","title":"Sqlalchemy 비동기 엔진에서의 Postgresql Pooler","tags":["DataBase","SqlAlchemy","Python"]},"rawMarkdownBody":"## 결론\n\nsupabase 기준, Sqlalchemy의 비동기 엔진에서 Postgresql pooler (supavisor)에 오류 없이 연결하기 위해서는 `create_async_engine` 을 다음과 같이 구성해주면 된다. \n\n```python\nfrom uuid import uuid4\nfrom asyncpg import Connection\n\n...(생략)...\n\nclass CConnection(Connection):\n    def _get_unique_id(self, prefix: str) -> str:\n        \"\"\"\n        캐싱을 만들 시에 캐싱 아이디가 중복으로 생성되어서 오류가 발생하는 경우가 있다.\n        statement_cache_size를 0으로 해도 일단 캐싱을 만들고 오류를 낸다.\n        따라서 캐싱을 사용하지 않을 것이므로, 아예 중복되지 않게 UUID로 생성해버린다.\n        \"\"\"\n        return f'__asyncpg_{prefix}_{uuid4()}__'\n\n...(생략)...\n\nDATABASE_URL = f\"postgresql+asyncpg://postgres.[Project ID]:[Password]@aws-0-[Region].pooler.supabase.com:6543/postgres?prepared_statement_cache_size=0\"\n    _db_connection = create_async_engine(\n        DATABASE_URL,\n        connect_args={\n            \"statement_cache_size\": 0,\n            'connection_class': CConnection,\n        },\n    )\n```\n\nstatement_cache_size, prepared_statement_cache_size를 둘 다 모두 0으로 줘야 한다.\n\n그리고 왜 발생하는지 모르겠는 간헐적인 오류(캐싱 ID를 중복되게 생성하려고 시도함)를 해결하기 위해 Connection 클래스를 상속받아 _get_unique_id 메소드를 오버라이딩 해주고, 해당 클래스를 connection_class로 사용하도록 했다. 이렇게 하면 id 중복 생성 오류를 방지할 수 있다. \n\n\n\n일반적인 글이라면 결론이 서두에 나온다면 너무나 시시하겠지만 기술 블로그이니 괜찮다. \n\n## 문제 해결에 관한 글\n\n### 발단\n\nsupabase에서 메일이 왔다. \n\n![](image1.png)\n여태 본 기억이 없었는데, Final reminder라도 되어있는걸 보니 이미 여러번 고지했던 모양이다. \n\n읽어보니 Pgbouncer 지원이 종료된다는 내용이다. 지원이 종료되는건 알고 있었는데, 아예 Connection string을 죽여버리는 모양이다. 잔인하다는 생각이 들었지만 어차피 우리는 Pooler는 진작에 포기했으므로 상관이 없었다. \n\n문제는 다음이었는데, DB Direct access에 대한 IPv4 주소 지원도 끝난다니 이건 좀 문제의 소지가 있었다. \n\n마침 어제 지난번 DB 세팅에 대한 회고를 끝내서 다행이었다. \n\n### 전개\n\n선택지는 두가지이다. Supavisor 도입, 네트워크가 IPv6를 지원하도록 설정하고 Direct 연결 방법을 계속해서 사용. \n\n개인적으로 \n\n- 네트워크 설정에 상대적으로 약함\n- WebRTC를 하던 때의 기억 때문에 IPv6에 안좋은 감정이 있음 \n- 현재 백엔드의 네트워크 설정을 직접 진행하지 않았었음 \n- 혼자 출근한 백엔드는 나 혼자임\n- Pooler와 씨름을 한 기억이 최근이고, 회고는 더더욱 최근임\n의 이유로 Supavisor 도입에 대해 다른 백엔드가 출근하기 전 잠깐 살펴보기로 했다.\n\n그런데 왠걸? 직접 설치부터 해야 하나라고 막연히 생각을 했었는데(supabase의 공식 문서에는 아직 supavisor에 대한 내용이 적어도 찾기 쉬운 곳에 있지는 않다. ) 그렇지 않았다. \n\n[https://github.com/orgs/supabase/discussions/17817](https://github.com/orgs/supabase/discussions/17817)\n\n해당 링크를 보아하니 이미 꽤 지원이 진행된 상태였는지, connection string만 바꾸면 간단하게 Pgbouncer가 아니라 Supavisor를 사용하여 연결할 수 있다고 적혀 있었다. \n\n그래서 해당 링크를 참조해 Connection string은 약간 수정을 해야 했지만, 어쨌든 Supavisor 연결에 간단하게 성공해버렸다. \n\n### 위기\n\n곧장 과거 겪었던 것과 같은 문제가 발생했다. Sqlalchemy 입장에서는 Pgbouncer와 Supavisor를 따로 구분하지 못하는지 Transaction 또는 Session 풀 모드에서는 캐싱이 지원되지 않는다는 에러 문구가 발생했다. \n\n여기서 잠깐, 포기하고 얌전히 IPv6 설정을 보러 갈까 했는데, 아직 다른 백엔드가 아무도 출근하지 않았다. \n\n일단 Pool mode를 바꿔야 다음 단계의 설정을 진행할 수 있었는데, Pgbouncer의 Pool mode는 supabase 콘솔에서 세팅을 지원하지만 supavisor는 어떻게 바꿔야 할지 의문이었다. \n\n해당 의문은 말도 못하게 간단하게 풀렸다. 콘솔에 들어가보니 어느새 쥐도 새도 모르게 Pgbouncer 관련 섹션이 supavisor 관련 섹션으로 바뀌어있었다. \n\n![](image2.png)\n위 이슈에서 설명된 supavisor 관련 connection string은 `user` 로 시작하는 부분이 옳지 않아서 수정이 필요했는데, 콘솔의 pgbouncer 관련 연결 connection string 에는 제대로 적혀있었다. 아무래도 메일에 적어보낸 이슈이지만 따로 수정을 하지는 않은 모양이다.. \n\n아무튼간 pool mode를 변경 후 테스트를 할 수 있었다. \n\n### 절정1\n\nPool mode를 바꿨다고 해서 바로 연결이 가능하지는 않다. 서버 인스턴스를 실행하면 짜잔! 성공적인 DB 연결 대신 다음과 같은 문구를 볼 수 있다. \n\n```plain text\nsqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.InvalidSQLStatementNameError'>: prepared statement \"__asyncpg_stmt_b__\" does not exist\nHINT:  \nNOTE: pgbouncer with pool_mode set to \"transaction\" or\n\"statement\" does not support prepared statements properly.\nYou have two options:\n* if you are using pgbouncer for connection pooling to a\n  single server, switch to the connection pool functionality\n  provided by asyncpg, it is a much better option for this\n  purpose;\n* if you have no option of avoiding the use of pgbouncer,\n  then you can set statement_cache_size to 0 when creating\n  the asyncpg connection object.\n```\n\nSqlalchemy를 사용중이기 때문에 첫번째 방법은 자연스럽게 더 고려할것도 없이 기각이며, statement_cache_size를 0으로 수정하는 것이 현재 내 인프라에서 선택할 수 있는 방법이었다.\n\n[https://docs.sqlalchemy.org/en/20/dialects/postgresql.html](https://docs.sqlalchemy.org/en/20/dialects/postgresql.html)\n\n지난번 기나긴 고생 이후 공식 문서를 항상 참조하는 습관을 들이게 됐다. 아주 긍정적인 방향이라고 생각한다. \n\n공식 문서를 참조하면,\n\n```plain text\nengine = create_async_engine(\"postgresql+asyncpg://user:pass@hostname/dbname?prepared_statement_cache_size=0\")\n```\n\n의 방식으로 statement_cache_size를 0으로 설정할 수 있는 것을 알 수 있다. \n\n이 설정을 해준 후, 다시 서버 인스턴스를 실행하면 짜잔! DB 연결이 아주 잘 된다. 쿼리도 잘 날리고, 결과도 잘 받아온다.\n\n이 와중에 Cache 생성 시에 같은 인덱스로 중복 생성되어서 오류가 발생하기도 했다. 그래서 SqlAlchemy의 Connection 클래스를 상속받아 캐시의 아이디를 생성하는 메소드를 수정해주었다. \n\n```python\nfrom asyncpg import Connection\nfrom uuid import uuid4\n\nclass CConnection(Connection):\n    def _get_unique_id(self, prefix: str) -> str:\n        \"\"\"\n        캐싱을 만들 시에 캐싱 아이디가 중복으로 생성되어서 오류가 발생하는 경우가 있다.\n        statement_cache_size를 0으로 해도 일단 캐싱을 만들고 오류를 낸다.\n        따라서 캐싱을 사용하지 않을 것이므로, 아예 중복되지 않게 UUID로 생성해버린다.\n        \"\"\"\n        return f'__asyncpg_{prefix}_{uuid4()}__'\n```\n\n이후 DB 커넥션을 만들 때에 해당 클래스를 기본 Connection 클래스 대신 사용하도록 설정해주면 된다. \n\n```python\nDATABASE_URL = f\"postgresql+asyncpg://postgres.[Project ID]:[Password]@aws-0-[Region].pooler.supabase.com:6543/postgres?prepared_statement_cache_size=0\"\n    _db_connection = create_async_engine(\n        DATABASE_URL,\n        connect_args={\n            'connection_class': CConnection,\n        },\n    )\n```\n\n여기까지 작업을 해줘서 오류를 해결하고 같은 쿼리를 연속으로 날리면? \n\n짜잔! 다음과 같은 오류를 볼 수 있다. \n\n```plain text\nsqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.InvalidSQLStatementNameError'>: prepared statement \"__asyncpg_stmt_9462b5fe-88dc-46f5-98fb-57981ea56de0__\" does not exist\nHINT:  \nNOTE: pgbouncer with pool_mode set to \"transaction\" or\n\"statement\" does not support prepared statements properly.\nYou have two options:\n* if you are using pgbouncer for connection pooling to a\n  single server, switch to the connection pool functionality\n  provided by asyncpg, it is a much better option for this\n  purpose;\n* if you have no option of avoiding the use of pgbouncer,\n  then you can set statement_cache_size to 0 when creating\n  the asyncpg connection object.\n```\n\n그렇다, 오류는 반복된다. \n\n### 절정2\n\n이미 여기까지 시간을 꽤 쓴 상태였기 때문에 조금만 더 무언가를 해보기로 했다. \n\n캐시 사용을 아무리 꺼도, 도대체가 캐시를 계속 만들고 거기서 오류를 내는 이 상황. \n\n다행히 비슷한 오류를 겪는 사람들을 깃허브 이슈에서 찾을 수 있었다. \n\n이미 나의 신뢰를 많이 잃어버린 챗지피티에게 이 문제를 상담하면 `statement_cache_size` 옵션을 0으로 설정해서 connect_args에 넣으라고 한다. PgBouncer로 붙이려고 애써봤었을 때에 해당 옵션을 넣어도 아무런 변화가 없이 그대로 오류가 발생했었고, 공식문서에는 존재하지 않는 옵션이어서 이번에는 무시하고 넘어갔었다. \n\n근데 충격적이게도 한가지 옵션을 썼을 땐 되지 않고 두 옵션을 동시에 사용하면 된다고 한다.. 이게 무슨 일일까? 나는 왜 두 옵션을 동시에 쓸 생각을 못했을까?(이 생각을 어떻게 하나요?)\n\n최종적으로 DB Connection String을 다음과 같이 설정해주었다. \n\n```python\nfrom uuid import uuid4\nfrom asyncpg import Connection\n\n...(생략)...\n\nclass CConnection(Connection):\n    def _get_unique_id(self, prefix: str) -> str:\n        \"\"\"\n        캐싱을 만들 시에 캐싱 아이디가 중복으로 생성되어서 오류가 발생하는 경우가 있다.\n        statement_cache_size를 0으로 해도 일단 캐싱을 만들고 오류를 낸다.\n        따라서 캐싱을 사용하지 않을 것이므로, 아예 중복되지 않게 UUID로 생성해버린다.\n        \"\"\"\n        return f'__asyncpg_{prefix}_{uuid4()}__'\n\n...(생략)...\n\nDATABASE_URL = f\"postgresql+asyncpg://postgres.[Project ID]:[Password]@aws-0-[Region].pooler.supabase.com:6543/postgres?prepared_statement_cache_size=0\"\n    _db_connection = create_async_engine(\n        DATABASE_URL,\n        connect_args={\n            \"statement_cache_size\": 0,\n            'connection_class': CConnection,\n        },\n    )\n```\n\n### 결말 & 에필로그\n\n지난번 기나긴 고생과 삽질을 통해서 챗지피티에 대한 신뢰를 덜고 공식문서를 신뢰해야 한다는 사실을 깨달았다. \n\n그리고 이번 짧은(반나절 정도) 삽질을 통해서 공식문서도 100% 정답은 아니라는 사실을 깨달았다. (나는 무엇을 믿어야 할까?)\n\n생각해보면, Database url 에다가 옵션을 넣는다고 해서 내부적으로 뭔가 변경되는 것일리가 없다. 결국 엔진을 만들 때에 옵션값을 넣어줘야 내부적으로 뭔가 알고 다른 작동을 하지 않을까? 이 생각을 막바지에 와서 떠올렸다. \n\n항상 시야를 넓게 하고, 의심하면서 만들어야 한다는 것을 다시 한 번 깨달았다. 남들이 시키는대로 해서는 되는것이 없는 것이다. \n\n별개로, 내가 잘못을 한 것인지 뭔지 Sqlalchemy도 FastAPI도 Postgresql도 모두 유명한 것들인데 어째서 이렇게까지 불완전하게 작동하는지 의문이 든다. 역사가 길진 않지만 그래도 수년의 시간은 지난 것들인데, 가장 기본적인 부분이 이렇게 불안정할지는 예상을 못했다. FastAPI의 메모리 누수 문제도 뒤늦게 알게 되었는데, 메모리 누수 문제에 이어서 비동기 엔진에서의 DB Pooler 연결에 이렇게 문제가 있을 줄 알았다면 FastAPI와 SqlAlchemy를 절대 선택하지 않았을 것 같다. \n\n고찰, 의심, 경험.. 등등이 중요하다고 다시 한 번 느꼈다. \n\n"},{"excerpt":"소개 애플 단축어를 활용해 간단하게 슬랙 상태를 원클릭으로 변경할 수 있습니다. 슬랙의 API를 이용합니다.  저는 개인적으로 raycast의 뽀모도로 익스텐션과 함께 다음과 같이 사용하고 있습니다. \n집중을 시작할 때에  집중 모드 킴 음량 조절 노래 재생 슬랙 방해금지 상태 변경\n\n집중을 끝낼 때에 집중 모드 끔 슬랙 방해금지 상태 해제 집중 모드에서…","fields":{"slug":"/단축어로SLACK프로필변경하기/"},"frontmatter":{"date":"November 17, 2023","title":"단축어로 SLACK 프로필 변경하기","tags":["ETC"]},"rawMarkdownBody":"## 소개\n\n애플 단축어를 활용해 간단하게 슬랙 상태를 원클릭으로 변경할 수 있습니다. 슬랙의 API를 이용합니다. \n\n저는 개인적으로 raycast의 뽀모도로 익스텐션과 함께 다음과 같이 사용하고 있습니다.\n\n![](image3.png)\n집중을 시작할 때에 \n\n- 집중 모드 킴\n- 음량 조절\n- 노래 재생\n- 슬랙 방해금지 상태 변경\n![](image4.png)\n집중을 끝낼 때에\n\n- 집중 모드 끔\n- 슬랙 방해금지 상태 해제\n\n\n집중 모드에서는 다른 알림을 모두 꺼두고 슬랙 알림만 켜서 업무 흐름은 놓치지 않게 해두었습니다. \n\n![](image5.png)\n메뉴바에서 원클릭으로 설정할 수 있어 편리합니다. \n\n## 설정법\n\n### 슬랙의 API App 생성\n\n먼저 슬랙의 API App을 만들어야 합니다. \n\n[https://api.slack.com/](https://api.slack.com/)\n\n해당 페이지로 이동 후, 우측 상단의 Your apps으로 이동합니다. \n\n`Create New App` 을 클릭합니다. \n\n`From an app manifest` 를 선택 후, workspace를 고르고 Next 합니다. \n\n`YAML`을 고르고, 다음의 내용을 입력합니다. \n\n```yaml\ndisplay_information:\n  name: Apple 상태변경 단축어\noauth_config:\n  scopes:\n    user:\n      - users.profile:write\nsettings:\n  org_deploy_enabled: false\n  socket_mode_enabled: false\n  token_rotation_enabled: false\n```\n\n권한을 더 원한다면 더 많이 입력해주셔도 됩니다. \n\n`Create`를 눌러 앱을 생성합니다. \n\n\n\n그 후 바로 그 화면에서 `Install to Workspace`를 클릭해 앱을 인스톨합니다. \n\n\n\n그리고, 좌측 메뉴에서 `OAuth & Permissions` 메뉴로 이동합니다. \n\n**OAuth Token** 값을 복사해줍니다. 슬랙 페이지에서 할 일은 여기까지입니다. \n\n### 단축어 설정\n\n단축어 앱을 열고 새로운 단축어를 추가합니다. \n\n`URL 콘텐츠 가져오기` 를 검색해서 다음과 같이 설정합니다. \n\n![](image6.png)\n입력해야 하는 값은 다음과 같습니다. \n\n- 헤더\n키 : Authorization\n\n값 : Bearer xoxp-xxxxx-xxxx…\n\n\n\n키 : Content-Type\n\n값 : application/json; charset=UTF-8\n\n- 바디\n키 : profile\n\n값 : \n\n```json\n{\n\t\t\"status_text\": \"방해금지\",\n\t\t\"status_emoji\": \":no_entry_sign:\"\n}\n```\n\n원하는 이모지와 텍스트를 넣어주시면 됩니다. \n\n\n\n이렇게 하면 단축어가 완성됩니다. \n\n## 참고\n\n[https://api.slack.com/apps?deleted=1](https://api.slack.com/apps?deleted=1)\n\n"},{"excerpt":"무엇을 하는가? Notion API를 이용해서 내가 쓴 글 들을 불러와 MD 파일로 만들려고 한다. 그 과정을 실시간으로 기록하려고 한다. 명확하게 가능한가? 는 사실 아직 알아보지 않았다.  왜 하는가? 너무나 너무나 귀찮기 때문이다. 블로그 포스팅을 위해서 마크다운 에디터로 노션을 쓰고 싶기 때문이다. 아니? 노션으로 쓴 것을 그대로 블로그에 커밋해버…","fields":{"slug":"/Notion-Api-2/"},"frontmatter":{"date":"September 01, 2023","title":"Notion API(2)","tags":["Blogging","Notion API","Node.js"]},"rawMarkdownBody":"## 무엇을 하는가?\n\nNotion API를 이용해서 내가 쓴 글 들을 불러와 MD 파일로 만들려고 한다. 그 과정을 실시간으로 기록하려고 한다. 명확하게 가능한가? 는 사실 아직 알아보지 않았다. \n\n## 왜 하는가?\n\n너무나 너무나 귀찮기 때문이다.\n\n블로그 포스팅을 위해서 마크다운 에디터로 노션을 쓰고 싶기 때문이다. 아니? 노션으로 쓴 것을 그대로 블로그에 커밋해버리고 싶기 때문이다. 그 과정을 자동화해버리고 싶기 때문이다. \n\n즉, 노션에 글만 써두면 자동으로 마크다운으로 받아져서 깃허브에 커밋이 되고 깃허브 페이지에 배포가 되는 원대한 자동화를 원한다. \n\n## 어떻게 하는가?\n\n### 환경\n\nNode.js 18.17.1 버전을 사용한다.\n\nNode.js 프로젝트 시작\n\n```bash\nnpm init\n```\n\n.env 생성\n\n```bash\nNOTION_KEY=<노션키>\nNOTION_PAGE_ID=<PageId>\n```\n\n.gitignore에 .env 등록\n\n```bash\n.env\n```\n\n.env 안의 내용을 가져올 수 있도록 `dotenv` 패키지 설치\n\n```bash\n$ npm install dotenv\n```\n\nNotion API를 이용할 수 있도록 패키지 설치\n\n```bash\n$ npm install @notionhq/client\n```\n\n### API 확인\n\n#### 코드\n\nNotion API reference에 아주 친절하게 JavaScript 예제 코드까지 전부 붙어있다. Node.js를 선택한 이유이기도 하다. 예제 코드가 자바스크립트로 되어있어 그대로 갖다 붙이기 쉬워 보였기 때문이다. 일단 API의 결과물이 어떻게 날아오는지 확인하기 위해 있는 대로 갖다 붙였다. \n\n```jsx\nrequire(\"dotenv\").config();\nconst { Client } = require(\"@notionhq/client\");\n\nconst pageId = process.env.NOTION_PAGE_ID;\nconst key = process.env.NOTION_KEY;\n\nconst notion = new Client({ auth: key });\n\n(async () => {\n    try {\n        const response = await notion.databases.query({ database_id: pageId });\n        // console.log(response);\n        //페이지들을 돌면서 id로 페이지를 읽어온다. \n        response.results.forEach(page => {\n            (async () => {\n                const pageId = page.id;\n                //page properties\n                const response = await notion.pages.retrieve({ page_id: pageId });\n                console.log(\"----------Page Properties----------\")\n                console.log(JSON.stringify(response, null, 2));\n                //page contents\n                (async () => {\n                    const blockId = pageId;\n                    const response = await notion.blocks.retrieve({\n                        block_id: blockId,\n                    });\n                    console.log(\"----------Page Contents as Block----------\")\n                    console.log(JSON.stringify(response, null, 2))\n                })();\n                (async () => {\n                    const blockId = pageId;\n                    const response = await notion.blocks.children.list({\n                        block_id: blockId,\n                        page_size: 50,\n                    });\n                    console.log(\"----------Page Block List----------\");\n                    console.log(JSON.stringify(response, null, 2));\n                })();\n            })();\n        });\n    } catch (error) {\n        console.error(\"Error querying the database:\", error);\n    }\n})();\n```\n\n#### 노션의 페이지 구성\n\n![Untitled](Untitled.png)\n\npage properties는 정확하게 마크다운의 Front Matter에 사용하면 될 것 같다. \n\n그리고, 마크다운의 콘텐츠에 page content가 들어가면 되겠다. \n\npage properties를 얻기 위해서는 notion.pages.retrieve method를 이용하면 된다. \n\n#### 코드 실행 결과문 분석\n\n- notion.pages.retrieve\n\n```json\n{\n  \"object\": \"page\",\n  \"id\": \"...id...\",\n  \"created_time\": \"2023-08-23T13:32:00.000Z\",\n  \"last_edited_time\": \"2023-09-01T12:45:00.000Z\",\n  \"created_by\": {\n    \"object\": \"user\",\n    \"id\": \"...id...\"\n  },\n  \"last_edited_by\": {\n    \"object\": \"user\",\n    \"id\": \"...id...\"\n  },\n  \"cover\": null,\n  \"icon\": null,\n  \"parent\": {\n    \"type\": \"database_id\",\n    \"database_id\": \"...id...\"\n  },\n  \"archived\": false,\n  \"properties\": {\n    \"tags\": {\n      \"id\": \"PHNF\",\n      \"type\": \"multi_select\",\n      \"multi_select\": [\n        {\n          \"id\": \"...id...\",\n          \"name\": \"AWS\",\n          \"color\": \"brown\"\n        },\n        {\n          \"id\": \"...id...\",\n          \"name\": \"TAG2\",\n          \"color\": \"pink\"\n        }\n      ]\n    },\n  },\n  \"url\": \"https://www.notion.so/...\",\n  \"public_url\": \"https://name.notion.site/...\"\n}\n```\n\n정확하게 페이지의 속성들을 가져오고 있다. Front Matter에 필요한 내용들을 속성으로 만들어두면 완벽할 것 같다. \n\n- notion.blocks.retrieve\n\nnotion.blocks.retrieve는 page ID를 넣으면 해당 페이지의 정보를 가져다 주는데 왜냐면 노션에서 모든 단위가 블록이기 때문이다. 해당 페이지의 블록으로서의 데이터를 주는 것이기 때문에 지금 내 상황에선 그다지 사용할 필요가 없어 보인다. \n\n- notion.blocks.children.list\n\n```json\n{\n  \"object\": \"list\",\n  \"results\": [\n    {\n      \"object\": \"block\",\n      \"id\": \"id\",\n      \"parent\": {\n        \"type\": \"page_id\",\n        \"page_id\": \"id\"\n      },\n      \"created_time\": \"2023-09-01T12:00:00.000Z\",\n      \"last_edited_time\": \"2023-09-01T12:12:00.000Z\",\n      \"created_by\": {\n        \"object\": \"user\",\n        \"id\": \"id\"\n      },\n      \"last_edited_by\": {\n        \"object\": \"user\",\n        \"id\": \"id\"\n      },\n      \"has_children\": false,\n      \"archived\": false,\n      \"type\": \"heading_1\",\n      \"heading_1\": {\n        \"rich_text\": [\n          {\n            \"type\": \"text\",\n            \"text\": {\n              \"content\": \"제목1\",\n              \"link\": null\n            },\n            \"annotations\": {\n              \"bold\": false,\n              \"italic\": false,\n              \"strikethrough\": false,\n              \"underline\": false,\n              \"code\": false,\n              \"color\": \"default\"\n            },\n            \"plain_text\": \"제목1\",\n            \"href\": null\n          }\n        ],\n        \"is_toggleable\": false,\n        \"color\": \"default\"\n      }\n    },\n\t...\n}\n```\n\n우리가 원하는 Page Content들의 내용이 드디어 보인다. 위의 결과에는 나타나지 않았지만, 들여쓰기가 된 경우에는 해당 들여쓰기가 된 block의 상위 요소에게 종속된다. 다시 말 내 다음 블록에 들여쓰기를 한 블록이 있다면 `has_children` 속성이 true가 된다. 그 안을 다시 파고 들어가면 될 것 같다. \n\n## 오늘의 결론\n\n이렇게 해서, API를 통해서 내 노션에 올려진 글들을 가져오는 데에 성공했다. 이제 다음 시간에는 이 JSON들을 가공해서 Markdown으로 변환하려고 한다. \n\n방법은 세 가지 정도를 생각하고 있다. \n\n1. 노션 내부 API 사용\n    \n    실제 노션 페이지를 띄울 때 오고 가는 요청값 들을 확인해 이를 사용하여 마크다운 파일을 바로 만들 수 있는 것으로 보인다. 이는 만들기가 가장 쉬워 보이나, 언제 폭파 될지 모른다는 문제점을 갖고 있다.  만약 폭파된다면 귀찮게도 다시 만들어야 한다는 치명적인 문제 때문에 지금 당장은 고려하고 있지 않지만 실패할 가능성도 가장 적어 보이므로, 귀찮아지면 언제든지 이쪽으로 틀도록 하자. \n    \n2. 오픈 소스 사용\n    \n    Notion 블록을 마크다운 형식으로 바꿔주는 오픈 소스가 있는 것으로 보인다. 아직 자세히 살펴보지는 않았다. \n    \n3. 직접 구현\n    \n    그냥.. 직접 만든다. 아마 많은 기능을 지원하지는 못하겠지만 노션을 쓰면서 느낀 건데 많은 기능을 딱히 사용하지 않는다. 정말 개인적인 용도라면 그냥 생각보다 쉽게 될 것 같기도 하다.\n    \n\n일단 코드를 막 짜고 있는데, 이번에는 변화에 닫힌, 확장에 열린 코드를 짜보려고 한다. 설계도 신경써서 하고 싶다. \n\n또 여유가 허락된다면 타입스크립트도 써보고 싶다. \n\n## 참고문서\n\n[Start building with the Notion API](https://developers.notion.com/reference)\n\n[Notion API와 함께 정적 페이지로의 여정 – 화해 블로그 | 기술 블로그](https://blog.hwahae.co.kr/all/tech/10960)"},{"excerpt":"지난시간 github.io를 이용한 블로그 왜 하는가 나는 귀찮은게 너무 귀찮다.  커밋 한 이후에  를 해야 배포가 되는 것도 너무 귀찮았다.  무엇을 하는가 그래서, 이걸  을 이용해서 자동화를 했다.  에 임의의 yml 파일을 넣어주면 해당 작업을 github action에서 진행한다.  어떻게 했는가 yml 파일 내용은 다음과 같다.  문제는 없었…","fields":{"slug":"/github.io-자동배포/"},"frontmatter":{"date":"August 30, 2023","title":"github.io 자동배포","tags":["Blogging"]},"rawMarkdownBody":"### 지난시간\n\n[github.io를 이용한 블로그](https://sharknia.vercel.app/github.io를-이용한-블로그)\n\n### 왜 하는가\n\n나는 귀찮은게 너무 귀찮다. \n\n커밋 한 이후에 \n\n```bash\nnpm run deploy-gh\n```\n\n를 해야 배포가 되는 것도 너무 귀찮았다. \n\n### 무엇을 하는가\n\n그래서, 이걸 `github action` 을 이용해서 자동화를 했다. \n\n`.gitbub/workflows`에 임의의 yml 파일을 넣어주면 해당 작업을 github action에서 진행한다. \n\n### 어떻게 했는가\n\nyml 파일 내용은 다음과 같다. \n\n```bash\nname: Deploy\n\non: # 어떤 작업이 수행될 때 deploy.yml 작업이 수행된다. (트리거)\n  push: # push 작업이 수행될 때\n    branches: # 특정 브랜치를 대상으로\n      - master\n\npermissions: # github action이 수행되는 환경에서 특정 권한을 준다\n  contents: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 20.3.1\n\n      - name: Install node packages\n        run: yarn\n        \n      - name: Check lint\n        run: yarn check:lint\n        \n      # 아래와 같은 오류가 남\n      # error Command failed with exit code 1.\n      # info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n      # - name: Check prettier\n      #   run: yarn check:prettier\n      \n      - name: Build\n        run: yarn build\n        \n      - name: Set up GitHub token\n        env:\n          GITHUB_TOKEN: ${{ secrets.Token}}\n        run: git config --global user.email \"email입력\" && git config --global user.name \"name입력\"\n\n      - name: Set Git remote URL with token\n        run: git remote set-url origin https://${{ secrets.classicToken }}@github.com/Sharknia/Sharknia.github.io\n\n      - name: Deploy to GitHub Pages\n        run: npx gh-pages -d public\n```\n\n### 문제는 없었는가\n\n처음에는 npm install을 사용했었는데, 패키지가 없다던지 여러가지 문제가 났다. 해당 문제는 npx 명령을 사용하는 것으로 해결돼\n\nDeploy 까지 자동으로 하기 위해서는 깃허브 설정 관련 명령어가 필요했다. \n\n특히, 반드시 토큰을 발행하고 Github Action의 환경 변수에 추가를 해주어야 한다."},{"excerpt":"🚀 2. 빠르게 시작하기 디자인이 마음에 들고, 필요로 하는 기능이 모두 들어가 있기 때문에 해당 테마를 선택했다. (시리즈 기능, 목차 기능, 댓글 기능) 5번까지는 무사히 테스트 했는데,  6번 특히 Netlify를 활용한 배포에서 막혔다.  Repository를 생성 후, 해당 저장소를 바로 Netlify에서 빌드하려고 하면 의존성 오류가 났다.  …","fields":{"slug":"/github.io를-이용한-블로그/"},"frontmatter":{"date":"August 28, 2023","title":"github.io를 이용한 블로그","tags":["Blogging"]},"rawMarkdownBody":"[🚀 2. 빠르게 시작하기](https://devhudi.github.io/gatsby-starter-hoodie/quick-start-kr/)\n\n디자인이 마음에 들고, 필요로 하는 기능이 모두 들어가 있기 때문에 해당 테마를 선택했다. (시리즈 기능, 목차 기능, 댓글 기능)\n\n5번까지는 무사히 테스트 했는데, \n\n6번 특히 Netlify를 활용한 배포에서 막혔다. \n\nRepository를 생성 후, 해당 저장소를 바로 Netlify에서 빌드하려고 하면 의존성 오류가 났다. \n\nNetlify를 활용하려고 한 이유는 Github Pages를 통해 배포할 경우 마스터 브랜치와 별도의 브랜치가 생성되는것이 번잡스러웠기 때문이다. \n\n조금 더 알아본 결과,\n\n```bash\n$ npm run build\n```\n\n를 실행하면, \n\n`/public` 에 빌드 결과물이 생성되고 해당 폴더만 배포하면 될 것 같긴하다. 또는 `github action` 을 이용할 수도 있겠다. \n\n조금 더 편하게 블로그를 하려는 길은 아직 멀고 험하다."},{"excerpt":"Notion API를 사용해보려고 한다.  이것으로 무엇을 할 것인가? 는 생각해둔게 있지만, 가능하다고 생각된 시점에서 본격적으로 해보려고 하고, 일단 오늘은 Notion API를 살펴보려고 한다.  간단한 소개 Start building with the Notion API Notion의 공개 Rest API를 이용하여 Notion Workspace와 …","fields":{"slug":"/Notion-Api-1/"},"frontmatter":{"date":"August 23, 2023","title":"Notion API(1)","tags":["Blogging","Notion API"]},"rawMarkdownBody":"Notion API를 사용해보려고 한다. \n\n이것으로 무엇을 할 것인가? 는 생각해둔게 있지만, 가능하다고 생각된 시점에서 본격적으로 해보려고 하고, 일단 오늘은 Notion API를 살펴보려고 한다. \n\n### 간단한 소개\n\n[Start building with the Notion API](https://developers.notion.com/)\n\nNotion의 공개 Rest API를 이용하여 Notion Workspace와 상호 작용 할 수 있다.\n\n페이지, 데이터베이스, 사용자, 페이지 및 인라인 주석, Workspace의 포스팅에 대한 검색 등등.. \n\n점점 지원 영역이 늘어나는 것 같다. change-log가 꽤 활발해보인다. \n\n### API 생성 및 권한 부여\n\n일단 우선, API를 생성하고 권한 부여 작업을 해야 한다. \n\n[Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.](https://www.notion.so/my-integrations)\n\n올라와 있는 한글 블로그들과 현재의 API 권한 부여 방식이 달라지는 바람에  여기서 은근 헤맸다… 역시 공식 가이드를 우선적으로 봐야한다. \n\n위 페이지에서 새 `API 통합 만들기` 를 선택한다. \n\nAPI의 권한은 워크스페이스별로 관리되므로, `연결된 워크스페이스` 를 정확히 선택해준다. \n\n필수 항목을 입력해주고 `제출` 을 눌러주자. \n\n![Untitled](Untitled.png)\n\n그럼 바로 위와 같은 화면으로 넘어온다. 표시를 눌러서 시크릿 키를 복사해서 보관해주자. \n\n![Untitled](Untitled1.png)\n\n기능도 커스텀 할 수 있는데, 일단 기본적인 기능을 넣어주었다. \n\n배포는 당연히 공개로 해두지 않았다. \n\n이후, 노션으로 돌아와 API와 연결된 워크스페이스를 선택하고 \n\n![Untitled](Untitled2.png)\n\n<aside>\n💡 **오른쪽 상단의 `…` 를 눌러서 `연결추가` 를 선택한 다음, 아까 만들어준 API의 이름을 검색해 해당 API와 연결을 해주면 된다.**\n\n</aside>\n\n이 부분이 UI가 달라진 부분이어서 공식 가이드를 보기 전까지 한참 헤맸던 부분이었다.\n\n이제, API와 Notion Workspace가 연결되었다!"},{"excerpt":"아주 마음에 드는 오픈소스로, 다만 내 취향에 맞게 짜잘짜잘 임의로 몇 가지 부분을 수정했다.  Tags 정렬 등록한 태그들이 블로그 좌측에 나열되는데, 이를 이름 순서대로 나오게 정렬했다.  자동썸네일 기능 테스트 src\\routes\\Detail\\PostDetail\\PostHeader.tsx 에서 썸네일을 가져오고 있고,  src\\pages[slug].…","fields":{"slug":"/Morethan-log-수정/"},"frontmatter":{"date":"August 20, 2023","title":"MORETHAN-LOG-수정","tags":["Blogging"]},"rawMarkdownBody":"아주 마음에 드는 오픈소스로, 다만 내 취향에 맞게 짜잘짜잘 임의로 몇 가지 부분을 수정했다. \n\n1. Tags 정렬\n    \n    등록한 태그들이 블로그 좌측에 나열되는데, 이를 이름 순서대로 나오게 정렬했다. \n    \n    ```tsx\n    // itemObj를 item name으로 정렬\n      const sortedItemObj = Object.entries(itemObj)\n        .sort((a, b) => a[0].localeCompare(b[0]))\n        .reduce((acc, [key, val]) => {\n          acc[key] = val\n          return acc\n        }, {} as { [itemName: string]: number })\n    \n      return sortedItemObj\n    ```\n    \n2. 자동썸네일 기능 테스트\n    \n    src\\routes\\Detail\\PostDetail\\PostHeader.tsx 에서 썸네일을 가져오고 있고, \n    \n    src\\pages\\[slug].tsx 에서 ogImageGenerateURL을 이용한 부분이 있다. \n    \n    다만 ogImageGenerateURL을 이용한 부분은 meta에만 적용되고 있고, 자동 썸네일 용 [https://og-image-korean.vercel.app](https://og-image-korean.vercel.app/) 는 만약 사용을 위해서라면 내 이미지를 활용한것으로 수정해야 할 것 같다."},{"excerpt":"MORETHAN-LOG 설치 개발자로서 어엿한 블로그 하나는 있어야 하지 않을까, 생각을 항상 하곤 했다.   하지만 블로그라는게 여간 귀찮은 일이 아니다.  공부한 내용을 노션에 적어두기 시작한지 좀 됐는데, 티스토리나 velog나 여러 방법을 시도한적이 있었지만 노션에 적은 내용을 거기로 옮기는게 얼마나 귀찮은지, 시작은 해도 도무지 꾸준히 이어할 수…","fields":{"slug":"/Morethan-log-설치/"},"frontmatter":{"date":"August 18, 2023","title":"MORETHAN-LOG-설치","tags":["Blogging"]},"rawMarkdownBody":"# MORETHAN-LOG 설치\n\n개발자로서 어엿한 블로그 하나는 있어야 하지 않을까, 생각을 항상 하곤 했다.  \n\n하지만 블로그라는게 여간 귀찮은 일이 아니다.  공부한 내용을 노션에 적어두기 시작한지 좀 됐는데, 티스토리나 velog나 여러 방법을 시도한적이 있었지만 노션에 적은 내용을 거기로 옮기는게 얼마나 귀찮은지, 시작은 해도 도무지 꾸준히 이어할 수가 없었다. \n\n그냥 언젠가 노션에 쓰기만 하면 블로그가 되는게 없나 그냥 가끔 검색만 하는 정도였는데, 어느샌가 나온 것이다. 그런 천지개벽할 물건이. \n\n[https://github.com/morethanmin/morethan-log](https://github.com/morethanmin/morethan-log)\n\n![Untitled](Untitled.png)\n\n커밋할 필요도, 포스트 할 필요도 없다. 단지 노션에 글을 적으면 바로 포스팅 된다. \n\n게다가 Readme에 설치방법이 10단계로 스크린샷까지 동봉되어서 너무나 친절하게 나와있다. \n\n[GitHub - morethanmin/morethan-log: 😎 A static blog using notion database](https://github.com/morethanmin/morethan-log#readme)\n\n블로그로 대성하겠다, 이런 마음가짐은 없기 때문에 심플한 구성과 간단한 기능이 너무 마음에 들었다. 누구나 따라할 수 있을 만큼 쉽게 되어있기 때문에 그대로 그대로 따라하는데,\n\n```jsx\nFailed to compile.\n./src/routes/Detail/PostDetail/CommentBox/Utterances.tsx:28:11\nType error: Type '{ repo: string | undefined; \"issue-term\": string; label: string; }' is not assignable to type '{ [key: string]: string; }'.\n  Property 'repo' is incompatible with index signature.\n    Type 'string | undefined' is not assignable to type 'string'.\n      Type 'undefined' is not assignable to type 'string'.\n  26 |     script.setAttribute(\"issue-term\", issueTerm)\n  27 |     script.setAttribute(\"theme\", theme)\n> 28 |     const config: { [key: string]: string } = CONFIG.utterances.config\n     |           ^\n  29 |     Object.keys(config).forEach((key) => {\n  30 |       script.setAttribute(key, config[key])\n  31 |     })\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nError: Command \"yarn run build\" exited with 1\n```\n\n글쎄 대체 나만 Deploy가 안되는것이다. \n\nISSUE에 나와 같은 오류를 겪은 외국인이 한 명 더 있었는데, 다른 플랫폼으로 갈아탄 모양인지 해결방법은 적혀있지 않았다. \n\n타입스크립트, 리액트는 처음이었기 때문에 정확히 알 수 없었는데, site.config.js 의 utterances-config 의 값을 가져올 때 오류가 나는 것이라고 짐작을 할 수 있었기 때문에 해당 부분을 챗지피티의 도움을 받아 코드를 수정했다. \n\n```tsx\nconst config: { [key: string]: string } = Object.entries(CONFIG.utterances.config)\n  .filter(([_, value]) => value !== undefined)\n  .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});\n```\n\n이렇게 하여, 무사히 deploy를 마치고 블로그 포스팅에 성공한것이다. \n\n문제는 여기서 끝나지 않았는데 노션에 글을 써도 도무지 블로그에 새로운 글이 포스팅되지 않았다. \n\n이것 때문에 잠도 못자고 설쳐가면서 새벽에 새로고침을 해보기도 했는데 자고 일어나도 되어있지 않았다. \n\n결론부터 이야기하자면, 아무것도 오류는 아니었다. \n\n[Serverless Functions Overview](https://vercel.com/docs/functions/serverless-functions)\n\nvercel의 Serverless Functions 기능은 모든 plan에서 이용가능하며, 이 기능을 이용해서 Notion API를 활용해서 글 내용을 불러오도록 되어있었다. \n\nsite.config.js를 확인하면 revalidateTime 변수가 있는데 처음에는 이 값이 42시간(!)으로 설정되어있었으므로, 이를 임의로 1시간으로 수정해주었다. \n\n성격이 급해서 1시간 단위로 갱신되게 해두었는데, 지금 와서 생각해보면 굳이 1시간일 필요도 없다는 생각이 든다."},{"excerpt":"변수(Variable) 메모리상의 주소(위치)를 기억하는 저장소. 즉 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자 값 데이터 타입(Data Type) 프로그래밍 언어에서 사용할 수 있는 값의 종료 변수(Variable) 값이 저장된 메모리를 가리키는 식별자 리터럴(literal) 소스코드 안에 직접 만들어낸 상수 값 자체. 값…","fields":{"slug":"/JavaScript-기본-문법/"},"frontmatter":{"date":"January 06, 2023","title":"JavaScript 기본 문법","tags":["JavaScript"]},"rawMarkdownBody":"1. 변수(Variable)\n    \n    메모리상의 주소(위치)를 기억하는 저장소. 즉 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자\n    \n2. 값\n    \n    \n    | 데이터 타입(Data Type) | 프로그래밍 언어에서 사용할 수 있는 값의 종료 |\n    | --- | --- |\n    | 변수(Variable) | 값이 저장된 메모리를 가리키는 식별자 |\n    | 리터럴(literal) | 소스코드 안에 직접 만들어낸 상수 값 자체. 값의 최소 단위 |\n    \n    값은 프로그램에 의해 조작될 수 있는 대상을 말한다. \n    \n    자바스크립트의 모든 값은 자바스크립트가 제공하는 7가지 데이터 타입 중 하나를 갖는다. \n    \n    - 데이터타입\n        - 원시타입(Privitive data type)\n            - number\n            - string\n            - boolean\n            - null\n            - undefined\n            - symbol(ES6)\n        - 객체 타입(Object data type)\n            - object\n    \n    자바스크립트는 데이터 타입을 미리 지정하지 않는다. 값의 타입에 의해 동적으로 변수의 타입이 결정되며, 이를 동적 타이핑이라고 한다. \n    \n3. 연산자\n    \n    피연산자의 타입이 반드시 일치할 필요가 없다. 암묵적 타입 강제 변환을 통해 연산을 수행한다. \n    \n4. 키워드\n    \n    키워드는 수행할 동작을 규정한다. 예를 들어 var 는 변수를 생성할 것을 지시한다. \n    \n5. 주석\n    \n    // 로 쓴다. 또는 /* */ 사이에 쓴다. \n    \n    주석은 해석기가 무시하며 실행되지 않는다. \n    \n6. 문\n    \n    브라우저에 의해 단계별로 수행될 명령들의 집합. 문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론으로 끝나야 한다. \n    \n    문은 코드 블록으로 그룹화 할 수 있다. \n    \n    자바스크립트는 블록 유효범위 (Block-Level Scope)를 생성하지 않는다. 함수 단위의 유효범위 (Function-Level Scope)만 생성된다.\n    \n7. 표현식\n    \n    표현식은 하나의 값으로 평가된다.\n    \n8. 문과 표현식의 비교\n    \n    문은 표현식을 포함한다. 표현식은 그 자체로 하나의 문이 될 수도 있다. \n    \n    표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. \n    \n    표현식을 통해 평가한 값을 통해 실제로 컴퓨터에게 명령을 하여 무언가를 하는 것은 문이다.\n    \n9. 함수\n    \n    어떤 작업을 수행하기 위해 필요한 문들의 집함. 이름과 매개변수를 가진다. \n    \n10. 객체\n    \n    자바스크립트는 객체(object) 기반의 스크립트 언어로 자바스크립트를 이루는 거의 모든 것이 객체이다. \n    \n    원시 타입을 제외한 나머지 값들은 모두 객체이다. (함수, 배열, 정규표현식 등)\n    \n    자바스크립트 객체는 키(이름)와 값으로 구성된 프로퍼티(property)의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. \n    \n    따라서 프로퍼티 값으로 함수를 사용할수도 있으며, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위헤 메소드라 부른다. \n    \n    객체는 데이터를 의미하는 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작을 의미하는 메소드로 구성된 집합이다. 객체는 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문에 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다. \n    \n    자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 “프로토타입”이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. \n    \n11. 배열\n    \n    자바스크립트의 배열은 객체이다. 유용한 내장 메소드를 포함하고 있다."},{"excerpt":"환경구성 Ubuntu 18.04 bionic Python 3.7 설치 명령어 정리 파이썬 및 기본 소프트웨어 설치 Janus 설치 How to install Janus Gateway in Ubuntu Server 18.04 Janus 설치 libnice 설치 ※ 최소 파이썬 3.7을 요구한다.  libstrp 설치 usrctp 설치 libwebsocket…","fields":{"slug":"/화상상담을-위한-Janus-구성/"},"frontmatter":{"date":"January 03, 2023","title":"화상상담을 위한 Janus 구성","tags":["BE"]},"rawMarkdownBody":"<aside>\n👨‍💻 Janus를 우분투에 설치하면서 사용한 명령어 정리\nStun 서버와 Turn 서버를 위한 Coturn Server도 함께 설치\n</aside>\n\n## 환경구성\n\n- Ubuntu 18.04 bionic\n- Python 3.7\n\n## 설치 명령어 정리\n\n1. 파이썬 및 기본 소프트웨어 설치\n2. Janus 설치\n    \n    [How to install Janus Gateway in Ubuntu Server 18.04](https://ourcodeworld.com/articles/read/1197/how-to-install-janus-gateway-in-ubuntu-server-18-04)\n    \n    - Janus 설치\n        \n        ```bash\n        packagelist=( \n        git \n        libmicrohttpd-dev \n        libjansson-dev \n        libssl-dev \n        libsrtp-dev \n        libsofia-sip-ua-dev \n        libglib2.0-dev \n        libopus-dev \n        libogg-dev \n        libcurl4-openssl-dev \n        liblua5.3-dev \n        libconfig-dev \n        pkg-config \n        gengetopt \n        libtool \n        automake \n        gtk-doc-tools \n        cmake \n        ) \n        apt-get install ${packagelist[@]}\n        ```\n        \n    - libnice 설치\n        \n        *※ 최소 파이썬 3.7을 요구한다.* \n        \n        ```bash\n        pip3 install meson==0.61.5 \n        ln -s /usr/local/bin/meson /usr/bin/ \n        wget https://github.com/ninja-build/ninja/releases/download/v1.10.1/ninja-linux.zip \n        unzip ninja-linux.zip \n        cp ninja /usr/bin/ \n        git clone https://gitlab.freedesktop.org/libnice/libnice.git\n        cd libnice \n        meson --prefix=/usr build \n        ninja -C build \n        ninja -C build install\n        ```\n        \n    - libstrp 설치\n        \n        ```bash\n        wget https://github.com/cisco/libsrtp/archive/v2.2.0.tar.gz \n        tar xfv v2.2.0.tar.gz \n        cd libsrtp-2.2.0 \n        ./configure —prefix=/usr —enable-openssl \n        make shared_library && make install\n        ```\n        \n    - usrctp 설치\n        \n        ```bash\n        git clone https://github.com/sctplab/usrsctp \n        cd usrsctp \n        ./bootstrap \n        ./configure --prefix=/usr && make && make install\n        ```\n        \n    - libwebsockets 설치\n        \n        ```bash\n        git clone https://github.com/warmcat/libwebsockets.git \n        cd libwebsockets \n        mkdir build \n        cd build \n        cmake -DLWS_MAX_SMP=1 -LWS_IPV6=ON -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS=\"-fpic\" .. \n        make && make install\n        ```\n        \n    - mqtt 설치\n        \n        ```bash\n        git clone https://github.com/eclipse/paho.mqtt.c.git \n        cd paho.mqtt.c \n        prefix=/usr make install\n        ```\n        \n    - NanoMSG 설치\n        \n        ```bash\n        apt-get install libnanomsg-dev -y\n        ```\n        \n    - RabbitMQ C AMQP 설치\n        \n        ```bash\n        git clone https://github.com/alanxz/rabbitmq-c \n        cd rabbitmq-c \n        git submodule init \n        git submodule update \n        mkdir build && cd build \n        cmake -DCMAKE_INSTALL_PREFIX=/usr ..\n        make && make install\n        ```\n        \n    - janus 컴파일링\n        \n        ```bash\n        git clone https://github.com/meetecho/janus-gateway.git\n        cd janus-gateway\n        sh autogen.sh\n        ./configure —prefix=/opt/janus\n        make && make install\n        make configs\n        ```\n        \n3. Janus 설정\n    \n    설정 파일 위치 : /opt/janus/etc/janus\n    \n    - janus.jcfg\n        \n        ```bash\n        - log_to_file : 주석해제 \n        - admin_secret : 변경 \"PW\" \n        - rtp_port_range : 주석해제 및 변경 \"20000-60000\" \n        - stun_server : 변경 \"Stun Server Domain\" \n        - stun_port : 주석해제 \n        - nat_1_1_mapping : 변경 \"Server IP\" \n        - turn_server : 변경 \"Turn Server Domain\" \n        - turn_port : 주석해제 \n        - turn_type : 주석해제 \n        - turn_user : 주석해제 및 변경 \"Turn ID\" \n        - turn_pwd : 주석해제 및 변경 \" Turn PW\" \n        - ipv6 : 주석해제 및 변경 \"true\"\n        ```\n        \n    - janus.plugin.videoroom.jcfg\n        \n        ```bash\n        general{ \n        admin_key : 주석해제 및 변경 \"비밀번호\" \n        publishers : 생성 값 \"10\" \n        }\n        ```\n        \n    - janus.transport.http.jcfg\n        \n        ```bash\n        https : 값 변경 \"true\" \n        secure_port : 주석 해제 \n        admin_https : 주석처리 값 변경 \"true\" \n        cert_pem : 값 변경 \"crt.pem 위치\" \n        cert_key : 값 변경 \"key.pem 위치\" \n        cert_pwd : 값 변경 \"인증서 비밀번호\"\n        ```\n        \n4. Coturn 설치\n    \n    [Corturn](http://john-home.iptime.org:8085/xe/index.php?mid=board_sKSz42&document_srl=1546)"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}