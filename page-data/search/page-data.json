{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Notion API(2) 무엇을 하는가? Notion API를 이용해서 내가 쓴 글 들을 불러와 MD 파일로 만들려고 한다. 그 과정을 실시간으로 기록하려고 한다. 명확하게 가능한가? 는 사실 아직 알아보지 않았다.  왜 하는가? 너무나 너무나 귀찮기 때문이다. 블로그 포스팅을 위해서 마크다운 에디터로 노션을 쓰고 싶기 때문이다. 아니? 노션으로 쓴 것을…","fields":{"slug":"/Notion-Api-2/"},"frontmatter":{"date":"September 01, 2023","title":"Notion API(2)","tags":["Blogging","Notion API","Node.js"]},"rawMarkdownBody":"# Notion API(2)\n\n# 무엇을 하는가?\n\nNotion API를 이용해서 내가 쓴 글 들을 불러와 MD 파일로 만들려고 한다. 그 과정을 실시간으로 기록하려고 한다. 명확하게 가능한가? 는 사실 아직 알아보지 않았다. \n\n# 왜 하는가?\n\n너무나 너무나 귀찮기 때문이다.\n\n블로그 포스팅을 위해서 마크다운 에디터로 노션을 쓰고 싶기 때문이다. 아니? 노션으로 쓴 것을 그대로 블로그에 커밋해버리고 싶기 때문이다. 그 과정을 자동화해버리고 싶기 때문이다. \n\n즉, 노션에 글만 써두면 자동으로 마크다운으로 받아져서 깃허브에 커밋이 되고 깃허브 페이지에 배포가 되는 원대한 자동화를 원한다. \n\n# 어떻게 하는가?\n\n## 환경\n\nNode.js 18.17.1 버전을 사용한다.\n\nNode.js 프로젝트 시작\n\n```bash\nnpm init\n```\n\n.env 생성\n\n```bash\nNOTION_KEY=<노션키>\nNOTION_PAGE_ID=<PageId>\n```\n\n.gitignore에 .env 등록\n\n```bash\n.env\n```\n\n.env 안의 내용을 가져올 수 있도록 `dotenv` 패키지 설치\n\n```bash\n$ npm install dotenv\n```\n\nNotion API를 이용할 수 있도록 패키지 설치\n\n```bash\n$ npm install @notionhq/client\n```\n\n## API 확인\n\n### 코드\n\nNotion API reference에 아주 친절하게 JavaScript 예제 코드까지 전부 붙어있다. Node.js를 선택한 이유이기도 하다. 예제 코드가 자바스크립트로 되어있어 그대로 갖다 붙이기 쉬워 보였기 때문이다. 일단 API의 결과물이 어떻게 날아오는지 확인하기 위해 있는 대로 갖다 붙였다. \n\n```jsx\nrequire(\"dotenv\").config();\nconst { Client } = require(\"@notionhq/client\");\n\nconst pageId = process.env.NOTION_PAGE_ID;\nconst key = process.env.NOTION_KEY;\n\nconst notion = new Client({ auth: key });\n\n(async () => {\n    try {\n        const response = await notion.databases.query({ database_id: pageId });\n        // console.log(response);\n        //페이지들을 돌면서 id로 페이지를 읽어온다. \n        response.results.forEach(page => {\n            (async () => {\n                const pageId = page.id;\n                //page properties\n                const response = await notion.pages.retrieve({ page_id: pageId });\n                console.log(\"----------Page Properties----------\")\n                console.log(JSON.stringify(response, null, 2));\n                //page contents\n                (async () => {\n                    const blockId = pageId;\n                    const response = await notion.blocks.retrieve({\n                        block_id: blockId,\n                    });\n                    console.log(\"----------Page Contents as Block----------\")\n                    console.log(JSON.stringify(response, null, 2))\n                })();\n                (async () => {\n                    const blockId = pageId;\n                    const response = await notion.blocks.children.list({\n                        block_id: blockId,\n                        page_size: 50,\n                    });\n                    console.log(\"----------Page Block List----------\");\n                    console.log(JSON.stringify(response, null, 2));\n                })();\n            })();\n        });\n    } catch (error) {\n        console.error(\"Error querying the database:\", error);\n    }\n})();\n```\n\n### 노션의 페이지 구성\n\n![Untitled](Untitled.png)\n\npage properties는 정확하게 마크다운의 Front Matter에 사용하면 될 것 같다. \n\n그리고, 마크다운의 콘텐츠에 page content가 들어가면 되겠다. \n\npage properties를 얻기 위해서는 notion.pages.retrieve method를 이용하면 된다. \n\n### 코드 실행 결과문 분석\n\n- notion.pages.retrieve\n\n```json\n{\n  \"object\": \"page\",\n  \"id\": \"...id...\",\n  \"created_time\": \"2023-08-23T13:32:00.000Z\",\n  \"last_edited_time\": \"2023-09-01T12:45:00.000Z\",\n  \"created_by\": {\n    \"object\": \"user\",\n    \"id\": \"...id...\"\n  },\n  \"last_edited_by\": {\n    \"object\": \"user\",\n    \"id\": \"...id...\"\n  },\n  \"cover\": null,\n  \"icon\": null,\n  \"parent\": {\n    \"type\": \"database_id\",\n    \"database_id\": \"...id...\"\n  },\n  \"archived\": false,\n  \"properties\": {\n    \"tags\": {\n      \"id\": \"PHNF\",\n      \"type\": \"multi_select\",\n      \"multi_select\": [\n        {\n          \"id\": \"...id...\",\n          \"name\": \"AWS\",\n          \"color\": \"brown\"\n        },\n        {\n          \"id\": \"...id...\",\n          \"name\": \"TAG2\",\n          \"color\": \"pink\"\n        }\n      ]\n    },\n  },\n  \"url\": \"https://www.notion.so/...\",\n  \"public_url\": \"https://name.notion.site/...\"\n}\n```\n\n정확하게 페이지의 속성들을 가져오고 있다. Front Matter에 필요한 내용들을 속성으로 만들어두면 완벽할 것 같다. \n\n- notion.blocks.retrieve\n\nnotion.blocks.retrieve는 page ID를 넣으면 해당 페이지의 정보를 가져다 주는데 왜냐면 노션에서 모든 단위가 블록이기 때문이다. 해당 페이지의 블록으로서의 데이터를 주는 것이기 때문에 지금 내 상황에선 그다지 사용할 필요가 없어 보인다. \n\n- notion.blocks.children.list\n\n```json\n{\n  \"object\": \"list\",\n  \"results\": [\n    {\n      \"object\": \"block\",\n      \"id\": \"id\",\n      \"parent\": {\n        \"type\": \"page_id\",\n        \"page_id\": \"id\"\n      },\n      \"created_time\": \"2023-09-01T12:00:00.000Z\",\n      \"last_edited_time\": \"2023-09-01T12:12:00.000Z\",\n      \"created_by\": {\n        \"object\": \"user\",\n        \"id\": \"id\"\n      },\n      \"last_edited_by\": {\n        \"object\": \"user\",\n        \"id\": \"id\"\n      },\n      \"has_children\": false,\n      \"archived\": false,\n      \"type\": \"heading_1\",\n      \"heading_1\": {\n        \"rich_text\": [\n          {\n            \"type\": \"text\",\n            \"text\": {\n              \"content\": \"제목1\",\n              \"link\": null\n            },\n            \"annotations\": {\n              \"bold\": false,\n              \"italic\": false,\n              \"strikethrough\": false,\n              \"underline\": false,\n              \"code\": false,\n              \"color\": \"default\"\n            },\n            \"plain_text\": \"제목1\",\n            \"href\": null\n          }\n        ],\n        \"is_toggleable\": false,\n        \"color\": \"default\"\n      }\n    },\n\t...\n}\n```\n\n우리가 원하는 Page Content들의 내용이 드디어 보인다. 위의 결과에는 나타나지 않았지만, 들여쓰기가 된 경우에는 해당 들여쓰기가 된 block의 상위 요소에게 종속된다. 다시 말 내 다음 블록에 들여쓰기를 한 블록이 있다면 `has_children` 속성이 true가 된다. 그 안을 다시 파고 들어가면 될 것 같다. \n\n# 오늘의 결론\n\n이렇게 해서, API를 통해서 내 노션에 올려진 글들을 가져오는 데에 성공했다. 이제 다음 시간에는 이 JSON들을 가공해서 Markdown으로 변환하려고 한다. \n\n방법은 세 가지 정도를 생각하고 있다. \n\n1. 노션 내부 API 사용\n    \n    실제 노션 페이지를 띄울 때 오고 가는 요청값 들을 확인해 이를 사용하여 마크다운 파일을 바로 만들 수 있는 것으로 보인다. 이는 만들기가 가장 쉬워 보이나, 언제 폭파 될지 모른다는 문제점을 갖고 있다.  만약 폭파된다면 귀찮게도 다시 만들어야 한다는 치명적인 문제 때문에 지금 당장은 고려하고 있지 않지만 실패할 가능성도 가장 적어 보이므로, 귀찮아지면 언제든지 이쪽으로 틀도록 하자. \n    \n2. 오픈 소스 사용\n    \n    Notion 블록을 마크다운 형식으로 바꿔주는 오픈 소스가 있는 것으로 보인다. 아직 자세히 살펴보지는 않았다. \n    \n3. 직접 구현\n    \n    그냥.. 직접 만든다. 아마 많은 기능을 지원하지는 못하겠지만 노션을 쓰면서 느낀 건데 많은 기능을 딱히 사용하지 않는다. 정말 개인적인 용도라면 그냥 생각보다 쉽게 될 것 같기도 하다.\n    \n\n일단 코드를 막 짜고 있는데, 이번에는 변화에 닫힌, 확장에 열린 코드를 짜보려고 한다. 설계도 신경써서 하고 싶다. \n\n또 여유가 허락된다면 타입스크립트도 써보고 싶다. \n\n# 참고문서\n\n[Start building with the Notion API](https://developers.notion.com/reference)\n\n[Notion API와 함께 정적 페이지로의 여정 – 화해 블로그 | 기술 블로그](https://blog.hwahae.co.kr/all/tech/10960)"},{"excerpt":"github.io 자동배포 지난시간 github.io를 이용한 블로그 왜 하는가 나는 귀찮은게 너무 귀찮다.  커밋 한 이후에  를 해야 배포가 되는 것도 너무 귀찮았다.  무엇을 하는가 그래서, 이걸  을 이용해서 자동화를 했다.  에 임의의 yml 파일을 넣어주면 해당 작업을 github action에서 진행한다.  어떻게 했는가 yml 파일 내용은 …","fields":{"slug":"/github.io-자동배포/"},"frontmatter":{"date":"August 30, 2023","title":"github.io 자동배포","tags":["Blogging"]},"rawMarkdownBody":"# github.io 자동배포\n\n### 지난시간\n\n[github.io를 이용한 블로그](https://sharknia.vercel.app/github.io를-이용한-블로그)\n\n### 왜 하는가\n\n나는 귀찮은게 너무 귀찮다. \n\n커밋 한 이후에 \n\n```bash\nnpm run deploy-gh\n```\n\n를 해야 배포가 되는 것도 너무 귀찮았다. \n\n### 무엇을 하는가\n\n그래서, 이걸 `github action` 을 이용해서 자동화를 했다. \n\n`.gitbub/workflows`에 임의의 yml 파일을 넣어주면 해당 작업을 github action에서 진행한다. \n\n### 어떻게 했는가\n\nyml 파일 내용은 다음과 같다. \n\n```bash\nname: Deploy\n\non: # 어떤 작업이 수행될 때 deploy.yml 작업이 수행된다. (트리거)\n  push: # push 작업이 수행될 때\n    branches: # 특정 브랜치를 대상으로\n      - master\n\npermissions: # github action이 수행되는 환경에서 특정 권한을 준다\n  contents: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 20.3.1\n\n      - name: Install node packages\n        run: yarn\n        \n      - name: Check lint\n        run: yarn check:lint\n        \n      # 아래와 같은 오류가 남\n      # error Command failed with exit code 1.\n      # info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n      # - name: Check prettier\n      #   run: yarn check:prettier\n      \n      - name: Build\n        run: yarn build\n        \n      - name: Set up GitHub token\n        env:\n          GITHUB_TOKEN: ${{ secrets.Token}}\n        run: git config --global user.email \"email입력\" && git config --global user.name \"name입력\"\n\n      - name: Set Git remote URL with token\n        run: git remote set-url origin https://${{ secrets.classicToken }}@github.com/Sharknia/Sharknia.github.io\n\n      - name: Deploy to GitHub Pages\n        run: npx gh-pages -d public\n```\n\n### 문제는 없었는가\n\n처음에는 npm install을 사용했었는데, 패키지가 없다던지 여러가지 문제가 났다. 해당 문제는 npx 명령을 사용하는 것으로 해결돼\n\nDeploy 까지 자동으로 하기 위해서는 깃허브 설정 관련 명령어가 필요했다. \n\n특히, 반드시 토큰을 발행하고 Github Action의 환경 변수에 추가를 해주어야 한다."},{"excerpt":"github.io를 이용한 블로그 🚀 2. 빠르게 시작하기 디자인이 마음에 들고, 필요로 하는 기능이 모두 들어가 있기 때문에 해당 테마를 선택했다. (시리즈 기능, 목차 기능, 댓글 기능) 5번까지는 무사히 테스트 했는데,  6번 특히 Netlify를 활용한 배포에서 막혔다.  Repository를 생성 후, 해당 저장소를 바로 Netlify에서 빌드하…","fields":{"slug":"/github.io를-이용한-블로그/"},"frontmatter":{"date":"August 28, 2023","title":"github.io를 이용한 블로그","tags":["Blogging"]},"rawMarkdownBody":"# github.io를 이용한 블로그\n\n[🚀 2. 빠르게 시작하기](https://devhudi.github.io/gatsby-starter-hoodie/quick-start-kr/)\n\n디자인이 마음에 들고, 필요로 하는 기능이 모두 들어가 있기 때문에 해당 테마를 선택했다. (시리즈 기능, 목차 기능, 댓글 기능)\n\n5번까지는 무사히 테스트 했는데, \n\n6번 특히 Netlify를 활용한 배포에서 막혔다. \n\nRepository를 생성 후, 해당 저장소를 바로 Netlify에서 빌드하려고 하면 의존성 오류가 났다. \n\nNetlify를 활용하려고 한 이유는 Github Pages를 통해 배포할 경우 마스터 브랜치와 별도의 브랜치가 생성되는것이 번잡스러웠기 때문이다. \n\n조금 더 알아본 결과,\n\n```bash\n$ npm run build\n```\n\n를 실행하면, \n\n`/public` 에 빌드 결과물이 생성되고 해당 폴더만 배포하면 될 것 같긴하다. 또는 `github action` 을 이용할 수도 있겠다. \n\n조금 더 편하게 블로그를 하려는 길은 아직 멀고 험하다."},{"excerpt":"Notion API(1) Notion API를 사용해보려고 한다.  이것으로 무엇을 할 것인가? 는 생각해둔게 있지만, 가능하다고 생각된 시점에서 본격적으로 해보려고 하고, 일단 오늘은 Notion API를 살펴보려고 한다.  간단한 소개 Start building with the Notion API Notion의 공개 Rest API를 이용하여 Noti…","fields":{"slug":"/Notion-Api-1/"},"frontmatter":{"date":"August 23, 2023","title":"Notion API(1)","tags":["Blogging","Notion API"]},"rawMarkdownBody":"# Notion API(1)\n\nNotion API를 사용해보려고 한다. \n\n이것으로 무엇을 할 것인가? 는 생각해둔게 있지만, 가능하다고 생각된 시점에서 본격적으로 해보려고 하고, 일단 오늘은 Notion API를 살펴보려고 한다. \n\n### 간단한 소개\n\n[Start building with the Notion API](https://developers.notion.com/)\n\nNotion의 공개 Rest API를 이용하여 Notion Workspace와 상호 작용 할 수 있다.\n\n페이지, 데이터베이스, 사용자, 페이지 및 인라인 주석, Workspace의 포스팅에 대한 검색 등등.. \n\n점점 지원 영역이 늘어나는 것 같다. change-log가 꽤 활발해보인다. \n\n### API 생성 및 권한 부여\n\n일단 우선, API를 생성하고 권한 부여 작업을 해야 한다. \n\n[Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.](https://www.notion.so/my-integrations)\n\n올라와 있는 한글 블로그들과 현재의 API 권한 부여 방식이 달라지는 바람에  여기서 은근 헤맸다… 역시 공식 가이드를 우선적으로 봐야한다. \n\n위 페이지에서 새 `API 통합 만들기` 를 선택한다. \n\nAPI의 권한은 워크스페이스별로 관리되므로, `연결된 워크스페이스` 를 정확히 선택해준다. \n\n필수 항목을 입력해주고 `제출` 을 눌러주자. \n\n![Untitled](Untitled.png)\n\n그럼 바로 위와 같은 화면으로 넘어온다. 표시를 눌러서 시크릿 키를 복사해서 보관해주자. \n\n![Untitled](Untitled1.png)\n\n기능도 커스텀 할 수 있는데, 일단 기본적인 기능을 넣어주었다. \n\n배포는 당연히 공개로 해두지 않았다. \n\n이후, 노션으로 돌아와 API와 연결된 워크스페이스를 선택하고 \n\n![Untitled](Untitled2.png)\n\n<aside>\n💡 **오른쪽 상단의 `…` 를 눌러서 `연결추가` 를 선택한 다음, 아까 만들어준 API의 이름을 검색해 해당 API와 연결을 해주면 된다.**\n\n</aside>\n\n이 부분이 UI가 달라진 부분이어서 공식 가이드를 보기 전까지 한참 헤맸던 부분이었다.\n\n이제, API와 Notion Workspace가 연결되었다!"},{"excerpt":"MORETHAN-LOG 수정 아주 마음에 드는 오픈소스로, 다만 내 취향에 맞게 짜잘짜잘 임의로 몇 가지 부분을 수정했다.  Tags 정렬 등록한 태그들이 블로그 좌측에 나열되는데, 이를 이름 순서대로 나오게 정렬했다.  자동썸네일 기능 테스트 src\\routes\\Detail\\PostDetail\\PostHeader.tsx 에서 썸네일을 가져오고 있고,  …","fields":{"slug":"/Morethan-log-수정/"},"frontmatter":{"date":"August 20, 2023","title":"MORETHAN-LOG-설치","tags":["Blogging"]},"rawMarkdownBody":"# MORETHAN-LOG 수정\n\n아주 마음에 드는 오픈소스로, 다만 내 취향에 맞게 짜잘짜잘 임의로 몇 가지 부분을 수정했다. \n\n1. Tags 정렬\n    \n    등록한 태그들이 블로그 좌측에 나열되는데, 이를 이름 순서대로 나오게 정렬했다. \n    \n    ```tsx\n    // itemObj를 item name으로 정렬\n      const sortedItemObj = Object.entries(itemObj)\n        .sort((a, b) => a[0].localeCompare(b[0]))\n        .reduce((acc, [key, val]) => {\n          acc[key] = val\n          return acc\n        }, {} as { [itemName: string]: number })\n    \n      return sortedItemObj\n    ```\n    \n2. 자동썸네일 기능 테스트\n    \n    src\\routes\\Detail\\PostDetail\\PostHeader.tsx 에서 썸네일을 가져오고 있고, \n    \n    src\\pages\\[slug].tsx 에서 ogImageGenerateURL을 이용한 부분이 있다. \n    \n    다만 ogImageGenerateURL을 이용한 부분은 meta에만 적용되고 있고, 자동 썸네일 용 [https://og-image-korean.vercel.app](https://og-image-korean.vercel.app/) 는 만약 사용을 위해서라면 내 이미지를 활용한것으로 수정해야 할 것 같다."},{"excerpt":"MORETHAN-LOG 설치 개발자로서 어엿한 블로그 하나는 있어야 하지 않을까, 생각을 항상 하곤 했다.   하지만 블로그라는게 여간 귀찮은 일이 아니다.  공부한 내용을 노션에 적어두기 시작한지 좀 됐는데, 티스토리나 velog나 여러 방법을 시도한적이 있었지만 노션에 적은 내용을 거기로 옮기는게 얼마나 귀찮은지, 시작은 해도 도무지 꾸준히 이어할 수…","fields":{"slug":"/Morethan-log-설치/"},"frontmatter":{"date":"August 18, 2023","title":"MORETHAN-LOG-설치","tags":["Blogging"]},"rawMarkdownBody":"# MORETHAN-LOG 설치\n\n개발자로서 어엿한 블로그 하나는 있어야 하지 않을까, 생각을 항상 하곤 했다.  \n\n하지만 블로그라는게 여간 귀찮은 일이 아니다.  공부한 내용을 노션에 적어두기 시작한지 좀 됐는데, 티스토리나 velog나 여러 방법을 시도한적이 있었지만 노션에 적은 내용을 거기로 옮기는게 얼마나 귀찮은지, 시작은 해도 도무지 꾸준히 이어할 수가 없었다. \n\n그냥 언젠가 노션에 쓰기만 하면 블로그가 되는게 없나 그냥 가끔 검색만 하는 정도였는데, 어느샌가 나온 것이다. 그런 천지개벽할 물건이. \n\n[https://github.com/morethanmin/morethan-log](https://github.com/morethanmin/morethan-log)\n\n![Untitled](Untitled.png)\n\n커밋할 필요도, 포스트 할 필요도 없다. 단지 노션에 글을 적으면 바로 포스팅 된다. \n\n게다가 Readme에 설치방법이 10단계로 스크린샷까지 동봉되어서 너무나 친절하게 나와있다. \n\n[GitHub - morethanmin/morethan-log: 😎 A static blog using notion database](https://github.com/morethanmin/morethan-log#readme)\n\n블로그로 대성하겠다, 이런 마음가짐은 없기 때문에 심플한 구성과 간단한 기능이 너무 마음에 들었다. 누구나 따라할 수 있을 만큼 쉽게 되어있기 때문에 그대로 그대로 따라하는데,\n\n```jsx\nFailed to compile.\n./src/routes/Detail/PostDetail/CommentBox/Utterances.tsx:28:11\nType error: Type '{ repo: string | undefined; \"issue-term\": string; label: string; }' is not assignable to type '{ [key: string]: string; }'.\n  Property 'repo' is incompatible with index signature.\n    Type 'string | undefined' is not assignable to type 'string'.\n      Type 'undefined' is not assignable to type 'string'.\n  26 |     script.setAttribute(\"issue-term\", issueTerm)\n  27 |     script.setAttribute(\"theme\", theme)\n> 28 |     const config: { [key: string]: string } = CONFIG.utterances.config\n     |           ^\n  29 |     Object.keys(config).forEach((key) => {\n  30 |       script.setAttribute(key, config[key])\n  31 |     })\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nError: Command \"yarn run build\" exited with 1\n```\n\n글쎄 대체 나만 Deploy가 안되는것이다. \n\nISSUE에 나와 같은 오류를 겪은 외국인이 한 명 더 있었는데, 다른 플랫폼으로 갈아탄 모양인지 해결방법은 적혀있지 않았다. \n\n타입스크립트, 리액트는 처음이었기 때문에 정확히 알 수 없었는데, site.config.js 의 utterances-config 의 값을 가져올 때 오류가 나는 것이라고 짐작을 할 수 있었기 때문에 해당 부분을 챗지피티의 도움을 받아 코드를 수정했다. \n\n```tsx\nconst config: { [key: string]: string } = Object.entries(CONFIG.utterances.config)\n  .filter(([_, value]) => value !== undefined)\n  .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});\n```\n\n이렇게 하여, 무사히 deploy를 마치고 블로그 포스팅에 성공한것이다. \n\n문제는 여기서 끝나지 않았는데 노션에 글을 써도 도무지 블로그에 새로운 글이 포스팅되지 않았다. \n\n이것 때문에 잠도 못자고 설쳐가면서 새벽에 새로고침을 해보기도 했는데 자고 일어나도 되어있지 않았다. \n\n결론부터 이야기하자면, 아무것도 오류는 아니었다. \n\n[Serverless Functions Overview](https://vercel.com/docs/functions/serverless-functions)\n\nvercel의 Serverless Functions 기능은 모든 plan에서 이용가능하며, 이 기능을 이용해서 Notion API를 활용해서 글 내용을 불러오도록 되어있었다. \n\nsite.config.js를 확인하면 revalidateTime 변수가 있는데 처음에는 이 값이 42시간(!)으로 설정되어있었으므로, 이를 임의로 1시간으로 수정해주었다. \n\n성격이 급해서 1시간 단위로 갱신되게 해두었는데, 지금 와서 생각해보면 굳이 1시간일 필요도 없다는 생각이 든다."},{"excerpt":"JavaScript 기본 문법 변수(Variable) 메모리상의 주소(위치)를 기억하는 저장소. 즉 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자 값 데이터 타입(Data Type) 프로그래밍 언어에서 사용할 수 있는 값의 종료 변수(Variable) 값이 저장된 메모리를 가리키는 식별자 리터럴(literal) 소스코드 안에 직…","fields":{"slug":"/JavaScript-기본-문법/"},"frontmatter":{"date":"January 06, 2023","title":"JavaScript 기본 문법","tags":["JavaScript"]},"rawMarkdownBody":"# JavaScript 기본 문법\n\n1. 변수(Variable)\n    \n    메모리상의 주소(위치)를 기억하는 저장소. 즉 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자\n    \n2. 값\n    \n    \n    | 데이터 타입(Data Type) | 프로그래밍 언어에서 사용할 수 있는 값의 종료 |\n    | --- | --- |\n    | 변수(Variable) | 값이 저장된 메모리를 가리키는 식별자 |\n    | 리터럴(literal) | 소스코드 안에 직접 만들어낸 상수 값 자체. 값의 최소 단위 |\n    \n    값은 프로그램에 의해 조작될 수 있는 대상을 말한다. \n    \n    자바스크립트의 모든 값은 자바스크립트가 제공하는 7가지 데이터 타입 중 하나를 갖는다. \n    \n    - 데이터타입\n        - 원시타입(Privitive data type)\n            - number\n            - string\n            - boolean\n            - null\n            - undefined\n            - symbol(ES6)\n        - 객체 타입(Object data type)\n            - object\n    \n    자바스크립트는 데이터 타입을 미리 지정하지 않는다. 값의 타입에 의해 동적으로 변수의 타입이 결정되며, 이를 동적 타이핑이라고 한다. \n    \n3. 연산자\n    \n    피연산자의 타입이 반드시 일치할 필요가 없다. 암묵적 타입 강제 변환을 통해 연산을 수행한다. \n    \n4. 키워드\n    \n    키워드는 수행할 동작을 규정한다. 예를 들어 var 는 변수를 생성할 것을 지시한다. \n    \n5. 주석\n    \n    // 로 쓴다. 또는 /* */ 사이에 쓴다. \n    \n    주석은 해석기가 무시하며 실행되지 않는다. \n    \n6. 문\n    \n    브라우저에 의해 단계별로 수행될 명령들의 집합. 문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론으로 끝나야 한다. \n    \n    문은 코드 블록으로 그룹화 할 수 있다. \n    \n    자바스크립트는 블록 유효범위 (Block-Level Scope)를 생성하지 않는다. 함수 단위의 유효범위 (Function-Level Scope)만 생성된다.\n    \n7. 표현식\n    \n    표현식은 하나의 값으로 평가된다.\n    \n8. 문과 표현식의 비교\n    \n    문은 표현식을 포함한다. 표현식은 그 자체로 하나의 문이 될 수도 있다. \n    \n    표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. \n    \n    표현식을 통해 평가한 값을 통해 실제로 컴퓨터에게 명령을 하여 무언가를 하는 것은 문이다.\n    \n9. 함수\n    \n    어떤 작업을 수행하기 위해 필요한 문들의 집함. 이름과 매개변수를 가진다. \n    \n10. 객체\n    \n    자바스크립트는 객체(object) 기반의 스크립트 언어로 자바스크립트를 이루는 거의 모든 것이 객체이다. \n    \n    원시 타입을 제외한 나머지 값들은 모두 객체이다. (함수, 배열, 정규표현식 등)\n    \n    자바스크립트 객체는 키(이름)와 값으로 구성된 프로퍼티(property)의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. \n    \n    따라서 프로퍼티 값으로 함수를 사용할수도 있으며, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위헤 메소드라 부른다. \n    \n    객체는 데이터를 의미하는 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작을 의미하는 메소드로 구성된 집합이다. 객체는 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문에 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다. \n    \n    자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 “프로토타입”이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. \n    \n11. 배열\n    \n    자바스크립트의 배열은 객체이다. 유용한 내장 메소드를 포함하고 있다."},{"excerpt":"화상상담을 위한 Janus 구성 환경구성 Ubuntu 18.04 bionic Python 3.7 설치 명령어 정리 파이썬 및 기본 소프트웨어 설치 Janus 설치 How to install Janus Gateway in Ubuntu Server 18.04 Janus 설치 libnice 설치 ※ 최소 파이썬 3.7을 요구한다.  libstrp 설치 usrc…","fields":{"slug":"/화상상담을-위한-Janus-구성/"},"frontmatter":{"date":"January 03, 2023","title":"화상상담을 위한 Janus 구성","tags":["BE"]},"rawMarkdownBody":"# 화상상담을 위한 Janus 구성\n\n<aside>\n👨‍💻 Janus를 우분투에 설치하면서 사용한 명령어 정리\nStun 서버와 Turn 서버를 위한 Coturn Server도 함께 설치\n</aside>\n\n## 환경구성\n\n- Ubuntu 18.04 bionic\n- Python 3.7\n\n## 설치 명령어 정리\n\n1. 파이썬 및 기본 소프트웨어 설치\n2. Janus 설치\n    \n    [How to install Janus Gateway in Ubuntu Server 18.04](https://ourcodeworld.com/articles/read/1197/how-to-install-janus-gateway-in-ubuntu-server-18-04)\n    \n    - Janus 설치\n        \n        ```bash\n        packagelist=( \n        git \n        libmicrohttpd-dev \n        libjansson-dev \n        libssl-dev \n        libsrtp-dev \n        libsofia-sip-ua-dev \n        libglib2.0-dev \n        libopus-dev \n        libogg-dev \n        libcurl4-openssl-dev \n        liblua5.3-dev \n        libconfig-dev \n        pkg-config \n        gengetopt \n        libtool \n        automake \n        gtk-doc-tools \n        cmake \n        ) \n        apt-get install ${packagelist[@]}\n        ```\n        \n    - libnice 설치\n        \n        *※ 최소 파이썬 3.7을 요구한다.* \n        \n        ```bash\n        pip3 install meson==0.61.5 \n        ln -s /usr/local/bin/meson /usr/bin/ \n        wget https://github.com/ninja-build/ninja/releases/download/v1.10.1/ninja-linux.zip \n        unzip ninja-linux.zip \n        cp ninja /usr/bin/ \n        git clone https://gitlab.freedesktop.org/libnice/libnice.git\n        cd libnice \n        meson --prefix=/usr build \n        ninja -C build \n        ninja -C build install\n        ```\n        \n    - libstrp 설치\n        \n        ```bash\n        wget https://github.com/cisco/libsrtp/archive/v2.2.0.tar.gz \n        tar xfv v2.2.0.tar.gz \n        cd libsrtp-2.2.0 \n        ./configure —prefix=/usr —enable-openssl \n        make shared_library && make install\n        ```\n        \n    - usrctp 설치\n        \n        ```bash\n        git clone https://github.com/sctplab/usrsctp \n        cd usrsctp \n        ./bootstrap \n        ./configure --prefix=/usr && make && make install\n        ```\n        \n    - libwebsockets 설치\n        \n        ```bash\n        git clone https://github.com/warmcat/libwebsockets.git \n        cd libwebsockets \n        mkdir build \n        cd build \n        cmake -DLWS_MAX_SMP=1 -LWS_IPV6=ON -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS=\"-fpic\" .. \n        make && make install\n        ```\n        \n    - mqtt 설치\n        \n        ```bash\n        git clone https://github.com/eclipse/paho.mqtt.c.git \n        cd paho.mqtt.c \n        prefix=/usr make install\n        ```\n        \n    - NanoMSG 설치\n        \n        ```bash\n        apt-get install libnanomsg-dev -y\n        ```\n        \n    - RabbitMQ C AMQP 설치\n        \n        ```bash\n        git clone https://github.com/alanxz/rabbitmq-c \n        cd rabbitmq-c \n        git submodule init \n        git submodule update \n        mkdir build && cd build \n        cmake -DCMAKE_INSTALL_PREFIX=/usr ..\n        make && make install\n        ```\n        \n    - janus 컴파일링\n        \n        ```bash\n        git clone https://github.com/meetecho/janus-gateway.git\n        cd janus-gateway\n        sh autogen.sh\n        ./configure —prefix=/opt/janus\n        make && make install\n        make configs\n        ```\n        \n3. Janus 설정\n    \n    설정 파일 위치 : /opt/janus/etc/janus\n    \n    - janus.jcfg\n        \n        ```bash\n        - log_to_file : 주석해제 \n        - admin_secret : 변경 \"PW\" \n        - rtp_port_range : 주석해제 및 변경 \"20000-60000\" \n        - stun_server : 변경 \"Stun Server Domain\" \n        - stun_port : 주석해제 \n        - nat_1_1_mapping : 변경 \"Server IP\" \n        - turn_server : 변경 \"Turn Server Domain\" \n        - turn_port : 주석해제 \n        - turn_type : 주석해제 \n        - turn_user : 주석해제 및 변경 \"Turn ID\" \n        - turn_pwd : 주석해제 및 변경 \" Turn PW\" \n        - ipv6 : 주석해제 및 변경 \"true\"\n        ```\n        \n    - janus.plugin.videoroom.jcfg\n        \n        ```bash\n        general{ \n        admin_key : 주석해제 및 변경 \"비밀번호\" \n        publishers : 생성 값 \"10\" \n        }\n        ```\n        \n    - janus.transport.http.jcfg\n        \n        ```bash\n        https : 값 변경 \"true\" \n        secure_port : 주석 해제 \n        admin_https : 주석처리 값 변경 \"true\" \n        cert_pem : 값 변경 \"crt.pem 위치\" \n        cert_key : 값 변경 \"key.pem 위치\" \n        cert_pwd : 값 변경 \"인증서 비밀번호\"\n        ```\n        \n4. Coturn 설치\n    \n    [Corturn](http://john-home.iptime.org:8085/xe/index.php?mid=board_sKSz42&document_srl=1546)"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}