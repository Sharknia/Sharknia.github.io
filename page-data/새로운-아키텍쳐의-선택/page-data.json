{"componentChunkName":"component---src-templates-post-jsx","path":"/새로운-아키텍쳐의-선택/","result":{"data":{"site":{"siteMetadata":{"title":"SharkniA"}},"markdownRemark":{"id":"527edba3-65f4-59c1-b5f6-797bd4537b93","excerpt":"서론 오랜만의 글입니다. 그 사이에 많은 일이 있었고, 새 직장에 오게 됐습니다.  새 회사의 신규 프로젝트의 메인 서버 개발이 한창인 가운데 첫 업무로 서비스 운영을 위한 백오피스(Back-office) 시스템 구축을 맡게 됐습니다. 이 백오피스는 메인 서비스의 데이터를 직접 조회하고 관리(CRUD)해야 하므로 두 서비스가 동일한 메인 DB를 공유하는 …","html":"<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/955874deaf23159dfe77bf2ba367386e/e8464/image1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 66.47058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACgElEQVR42jWSS2/TQBSFsyOxHb/txM7bjZ3YifNO807TRk1ISgohqFRtaWhRQaLqAqRUAvHohkUrwYotKyTEnh3/gjU/gL/BmUSVrqzxzPnuOaM7HkpzaS1Ha3k6VGBCRSZcJhWp+KPrq8KaCZVovQANFXSpQManOj4l7VNSHlrP42DJLIFYnY032USLMzqc0WWNNn79sRoTqUJDxFqOCmZXvIeGW6RMsHgdDLvW4ZM93uoL9lBwRoI94K0tbq1DjmJ1tIb+lrc9JNWqiG2DNzeF9FDM7UqVfak+l0p7ojsR0gNgsjvRu8/90SqSUuADGcBVPtVX63N961zrnkq5CdSB5jx39rl2+c3c+6DUDoXMWGs9jY0vVXTMjPlkF84oDx0u0eGyUt1PTD8asyu1dsTZ4/DO4ur3n59//z3++ktun0n5B/H777X2M1rPSdkdzmhRAQfhARfviGtoA4W6fqh3T+OjC+fkprL43njzwz6+tp98igwvgs0Tf6Qi56diekDIUBHJPUyo4JVNzEBw7srFR3JpptYOYvcWyYPr1OFNdGcR2j6XC1PJnYjZCRtvwJaNrdPBDIHh6ZWSPjVNxmP2RGeklGZ6/yVg6/hLePgqUD8SMyPB6nPJDcwM/v5wiZjjzl7J8IoJfKmAzRkNJb+rtebR0evEw3eJ6dvQ5guteawUkHYbDBOtUEEHep9sLh8JuXoW4blEQ7R6kj0Ar5ZmMqaVGUm4S3aMTcHqQQCeBFbxvCwUYjuM5vrDRTZa4eI13mgKyQ6kYqovprYEc4M32sBYErgMD1pzqVve41NTWKEfdhk9jy4QsVFUFYU1SYtnTx6mu7S1EdinmF7Z/A9eAIAJ4QqqjQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image1' title='' src='/static/955874deaf23159dfe77bf2ba367386e/ca1dc/image1.png' srcset='/static/955874deaf23159dfe77bf2ba367386e/e7570/image1.png 170w,\n/static/955874deaf23159dfe77bf2ba367386e/f46e7/image1.png 340w,\n/static/955874deaf23159dfe77bf2ba367386e/ca1dc/image1.png 680w,\n/static/955874deaf23159dfe77bf2ba367386e/02d09/image1.png 1020w,\n/static/955874deaf23159dfe77bf2ba367386e/9d567/image1.png 1360w,\n/static/955874deaf23159dfe77bf2ba367386e/e8464/image1.png 1536w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>서론</h2>\n<p>오랜만의 글입니다. 그 사이에 많은 일이 있었고, 새 직장에 오게 됐습니다. </p>\n<p>새 회사의 신규 프로젝트의 메인 서버 개발이 한창인 가운데 첫 업무로 서비스 운영을 위한 백오피스(Back-office) 시스템 구축을 맡게 됐습니다. 이 백오피스는 메인 서비스의 데이터를 직접 조회하고 관리(CRUD)해야 하므로 두 서비스가 동일한 메인 DB를 공유하는 구조입니다.</p>\n<p>초기 논의에서는 백오피스 시스템을 TypeScript 기반으로 별도 구축하는 안이 있었는데 이 경우 런타임과 패키지 생태계가 완전히 다르므로 레포지토리를 분리(멀티레포)하는 것이 필수적이었습니다.</p>\n<p>하지만 최종적으로 백오피스 역시 메인 서버와 동일한 FastAPI(Python) 스택을 사용하기로 결정되면서 아키텍처에 새로운 선택지가 열렸습니다. 동일 스택이기에 레포 분리가 필수는 아니게 된 것입니다.</p>\n<p>이에 따라 팀에서 처음 제안된 '멀티레포' 구조가 과연 최선인지, 혹은 '모노레포'라는 대안이 가져다줄 이점은 없는지 각 구조의 트레이드오프를 분석하게 되었습니다.</p>\n<h2>팀의 초기 제안: 레포지토리 분리 (멀티레포)</h2>\n<p>팀에서 초기에 제안한 구조는 다음과 같습니다.</p>\n<ul>\n<li><code class=\"language-text\">main-server-repo</code> / <code class=\"language-text\">backoffice-repo</code> (레포지토리 분리)</li>\n<li><code class=\"language-text\">main-server</code> / <code class=\"language-text\">backoffice-server</code> (서버 분리)</li>\n<li>메인 DB 공동 사용</li>\n<li>백오피스 서버에는 SQLModel 도입 후 추후 메인 서버 고도화</li>\n</ul>\n<p>이 구조는 명확한 장점을 가집니다.</p>\n<ol>\n<li>배포 독립성: 백오피스 서버의 배포가 메인 서버에 영향을 주지 않으며 그 반대도 마찬가지입니다.</li>\n<li>기술 스택의 자유: 메인 서버(SQLAlchemy)와 관계없이 백오피스는 Pydantic V2와 호환성이 좋은 SQLModel 같은 현대적인 기술 스택을 자유롭게 도입할 수 있습니다.</li>\n<li>브랜치 관리 단순성: 레포지토리가 물리적으로 분리되어 메인 서버의 복잡한 브랜치(핫픽스, 기능 개발 등)와 백오피스 개발 브랜치가 충돌할 가능성이 원천적으로 차단됩니다. 팀은 이미 솔루션의 1.0의 핫픽스와 1.1버전의 브랜치 관리가 이슈였으므로 이는 무시할 수 없는 장점입니다. </li>\n</ol>\n<h3>핵심 위험: '사실상의 분산 모놀리식' 안티패턴</h3>\n<p>여기까지만 보면 멀티레포는 깔끔하고 합리적인 선택처럼 보입니다. 하지만 '공유 DB'라는 제약 하에서 이 구조는 제가 과거에 경험했던 '사실상의 분산 모놀리식(Distributed Monolith)' 아키텍처의 실패 패턴을 그대로 재현할 위험이 있습니다.</p>\n<p>분명 서비스는 분리되어 있지만 서로의 DB를 직접 읽어 들이면서 암묵적인 강결합이 발생하고 코드 수정을 놓치면 모델의 일관성이 깨지는 구조입니다.</p>\n<p>이 구조의 치명적인 단점은 DB 모델 코드의 중복 관리입니다. 두 레포지토리는 동일한 DB를 바라보지만 각자의 서버에서 데이터를 다루기 위해 DB 스키마(모델) 코드를 별도로 가지고 있어야 합니다. 심지어 첫 제안에서는 메인 서버는 SQLAlchemy, 백오피스는 SQLModel로 코드마저 다릅니다.</p>\n<p>이는 두 서비스 간의 가장 강력한 계약인 '데이터 스키마'의 동기화를 전적으로 개발자의 '기억'과 '꼼꼼함'에 의존하게 만듭니다.</p>\n<p>이 구조에서는 다음의 장애 시나리오가 발생할 가능성이 아주 높습니다.</p>\n<ol>\n<li>기획 요구사항: <code class=\"language-text\">User</code> 테이블에 <code class=\"language-text\">nickname</code> 컬럼 추가.</li>\n<li>개발: 개발자가 <code class=\"language-text\">main-server-repo</code>의 <code class=\"language-text\">User</code> 모델(SQLAlchemy)에 <code class=\"language-text\">nickname</code>을 추가하고 배포합니다.</li>\n<li>장애 발생: 개발자가 <code class=\"language-text\">backoffice-repo</code>의 <code class=\"language-text\">User</code> 모델(SQLModel)에 <code class=\"language-text\">nickname</code> 추가하는 것을 잊었습니다.</li>\n<li>결과</li>\n<li>메인 서버는 <code class=\"language-text\">nickname</code>이 포함된 <code class=\"language-text\">User</code>를 DB에 잘 저장합니다.</li>\n<li>백오피스가 해당 <code class=\"language-text\">User</code>를 조회하는 순간 백오피스 모델에는 <code class=\"language-text\">nickname</code> 필드가 없으므로 추가적인 별도의 작업이 필요합니다. </li>\n</ol>\n<h2>고려에서 제외된 대안들</h2>\n<p>이러한 문제를 해결하기 위해 다른 대안들도 검토했습니다.</p>\n<h3>1. 서버/레포 완전 통합 (Full Monolith)</h3>\n<p>DB 모델의 중복을 피하는 가장 간단한 방법은 백오피스를 별도 서버로 두지 않고 메인 서버 API의 일부(예: <code class=\"language-text\">/admin</code> 경로)로 통합하는 것입니다.</p>\n<p>하지만 이 방안은 '배포 독립성의 완전한 상실'이라는 더 큰 문제를 야기하기에 기각했습니다.</p>\n<p>백오피스의 사소한 문구 수정 배포가 민감한 메인 서버의 전체 빌드와 배포를 트리거하게 됩니다. </p>\n<p>안 그래도 현재 팀은 1.0 핫픽스와 1.1 신규 개발 브랜치를 동시에 관리하는 데 어려움을 겪고 있는데 여기에 백오피스 개발 브랜치까지 얹어져 배포 파이프라인을 공유하게 된다면 관리 부담이 감당할 수 없는 수준으로 커질 것이라 판단했습니다.</p>\n<h3>2. 모델 파일의 라이브러리화</h3>\n<p>'서버 분리'와 '모델 일관성'을 모두 잡기 위해 공통 모델 파일만 별도 레포지토리로 분리하여 '라이브러리'로 패키징하는 방안도 잠시 고려했습니다.</p>\n<p>하지만 이는 현재 단계에서는 '오버 엔지니어링'이라고 판단했습니다.</p>\n<ul>\n<li>공통 모델 라이브러리의 버전 관리 정책 수립</li>\n<li>Private PyPI 같은 패키지 저장소 운영 및 CI/CD 파이프라인 구축</li>\n<li>메인 서버와 백오피스 서버의 라이브러리 의존성 업데이트 동기화</li>\n</ul>\n<p>모델 일관성은 잡을 수 있지만 그 대가로 지불해야 하는 인프라 및 관리 비용이 너무 컸습니다.</p>\n<h2>실용적인 대안: 모노레포</h2>\n<p>이러한 고민 끝에 제가 제안하는 대안은 모노레포입니다. 이는 앞선 모든 방법의 단점(휴먼에러 위험, 배포 결합, 오버 엔지니어링)을 피하는 가장 실용적인 절충안입니다.</p>\n<ul>\n<li>모노레포 내 <code class=\"language-text\">main_server/</code> 와 <code class=\"language-text\">backoffice/</code> 디렉토리로 코드 분리</li>\n<li><code class=\"language-text\">main-server</code> / <code class=\"language-text\">backoffice-server</code> (서버 분리)</li>\n<li>배포는 CI/CD 설정을 통해 디렉토리별로 분리</li>\n</ul>\n<h3>모노레포의 명확한 트레이드오프</h3>\n<p>이 구조는 명확한 이점과 비용을 동시에 가집니다.</p>\n<h4>1. 이점: DB 모델의 단일 소스 (Single Source of Truth) 확보</h4>\n<p>shared/models/와 같은 공통 디렉토리에 DB 모델을 정의합니다. 메인 서버와 백오피스 서버는 이 공통 모델을 임포트(import)하여 사용합니다. 모델 코드의 중복 작성이 원천적으로 제거되며, 스키마 변경 시 공통 모델 파일 하나만 수정하면 됩니다. </p>\n<h4>2. 비용 1: SQLModel 도입 지연 (기술 스택 통일)</h4>\n<p>가장 큰 비용입니다. 공통 모델을 공유한다는 것은 백오피스 역시 메인 서버와 동일한 SQLAlchemy 기반 모델을 사용해야 함을 의미합니다. 백오피스에 SQLModel을 도입하려던 계획은 포기하거나 메인 서버 전체가 SQLModel로 마이그레이션될 때까지 무기한 연기해야 합니다.</p>\n<h4>3. 비용 2: 초기 설정 복잡도</h4>\n<p>디렉토리별 CI/CD 분기, PYTHONPATH 설정, 공통 모듈 임포트 구조 확립 등은 '신규 레포 생성'과는 다른 종류의 복잡한 초기 설정 비용입니다.</p>\n<h2>트레이드오프 분석 및 결론: 일관성을 위한 선택</h2>\n<p>네 가지 방안의 트레이드오프는 명확합니다.</p>\n<p>이 분석은 어느 한쪽이 '무조건 옳다'고 주장하려는 것이 아닙니다. 모노레포 역시 '최선'의 아키텍처라기보다, 우리가 피하고자 하는 명확한 위험(배포 결합, 휴먼 에러, 추가 유지보수 공수, 오버 엔지니어링)을 피하기 위한 현실적인 '절충안'이라고 생각할 뿐으로, 가장 중요한 것은 팀의 결정입니다. </p>\n<ul>\n<li>멀티레포(초기안): '기술 스택의 자유(SQLModel)'를 얻는 대신, '추가적인 휴먼에러 위험성'을 안고 가며 이를 해결할 자동화 방안(예: git submodule, 스크립트)을 반드시 마련한다.</li>\n<li>모노레포(개선안): '모델 안정성'을 확보하는 대신, '기술 스택의 자유(SQLModel)'를 포기하고 'CI/CD 분기 처리'라는 엔지니어링 비용을 지불한다.</li>\n</ul>\n<p>저는 '휴먼 에러 및 추가 유지보수 공수'라는 위험이 '신규 기술 스택 도입'이라는 이점보다 훨씬 더 크고 치명적이라고 생각합니다. 따라서 후자(모노레포)가 현재 우리 팀의 상황에서 더 예측 가능하고 제어하기 쉬운 비용이라고 판단하여 이 안을 트레이드 오프 분석 문서로 작성하여 팀에 제안하려고 합니다.</p>\n<h2>미래: 멀티모듈로의 진화</h2>\n<p>특히 모노레포를 선택할 경우, 이 구조는 향후 프로젝트가 더 복잡해졌을 때 자연스럽게 '멀티모듈' 아키텍처로 진화할 수 있는 좋은 기반이 됩니다.</p>\n<p>현재는 <code class=\"language-text\">shared/</code> 디렉토리를 단순 임포트하여 사용하지만 추후에는 이 <code class=\"language-text\">shared</code> 모듈을 <code class=\"language-text\">poetry</code> 등을 통해 명시적인 내부 패키지로 분리하여 메인 서버와 백오피스가 이를 '설치'하도록 구성할 수 있습니다. 이는 서비스 간의 의존성을 더욱 명확하게 관리하는 데 도움이 될 것입니다.</p>","frontmatter":{"title":"새로운 아키텍쳐의 선택","date":"October 28, 2025","update":"October 29, 2025","tags":["BackEnd","FastAPI","Work","아키텍쳐"],"series":null},"fields":{"slug":"/새로운-아키텍쳐의-선택/","readingTime":{"minutes":13.11}}},"seriesList":{"edges":[{"node":{"id":"b1fa34d8-79a6-5920-b77c-fbf3bc57100b","fields":{"slug":"/화상상담을-위한-Janus-구성/"},"frontmatter":{"title":"화상상담을 위한 Janus 구성"}}},{"node":{"id":"36ed6446-4d80-5d51-87fe-7cbb02582980","fields":{"slug":"/JavaScript의-특징-브라우저-동작-원리/"},"frontmatter":{"title":"JavaScript의 특징, 브라우저 동작 원리"}}},{"node":{"id":"1890a1d7-34c1-53bd-a8bd-9bdfd39e91c3","fields":{"slug":"/JavaScript-기본-문법/"},"frontmatter":{"title":"JavaScript 기본 문법"}}},{"node":{"id":"61ba989b-e166-5573-a895-1f71aa176358","fields":{"slug":"/JavaScript의-변수/"},"frontmatter":{"title":"JavaScript의 변수"}}},{"node":{"id":"09afa1c5-5d39-532c-8dbb-5ba9e4af5b42","fields":{"slug":"/JavaScript의-타입-변환과-단축-평가/"},"frontmatter":{"title":"JavaScript의 타입 변환과 단축 평가"}}},{"node":{"id":"a81f1c25-10c3-52c4-8594-54806409ea15","fields":{"slug":"/JavaScript-클로저/"},"frontmatter":{"title":"JavaScript 클로저"}}},{"node":{"id":"6f1a58a9-6d27-5238-a531-618fc2d38f6a","fields":{"slug":"/NestJS-소개/"},"frontmatter":{"title":"NestJS 소개"}}},{"node":{"id":"6a1bda4f-ebe2-5b4f-980e-0484f92834f9","fields":{"slug":"/MORETHAN-LOG-설치/"},"frontmatter":{"title":"MORETHAN-LOG 설치"}}},{"node":{"id":"b1b9709f-6909-592c-b003-7ff67d3ca0fe","fields":{"slug":"/DB-튜닝-경험/"},"frontmatter":{"title":"DB 튜닝 경험"}}},{"node":{"id":"192dff3e-aa73-5307-a245-65393ab4e1d9","fields":{"slug":"/RDB관계형-데이터베이스-RDBMS/"},"frontmatter":{"title":"RDB(관계형 데이터베이스) + RDBMS"}}},{"node":{"id":"7ac316a8-f6ea-52cc-a790-b5be80f2bec7","fields":{"slug":"/var와-letconst/"},"frontmatter":{"title":"var와 let,const"}}},{"node":{"id":"e86672d9-847c-55f9-a249-42b4d896508f","fields":{"slug":"/MORETHAN-LOG-수정/"},"frontmatter":{"title":"MORETHAN-LOG 수정"}}},{"node":{"id":"6a5ef575-d133-5b56-b0b6-4db4af7aa70d","fields":{"slug":"/NestJS-설치/"},"frontmatter":{"title":"NestJS 설치"}}},{"node":{"id":"c9c69060-c0a8-5657-b744-46feb11aa3bd","fields":{"slug":"/NestJS의-디렉토리-구조/"},"frontmatter":{"title":"NestJS의 디렉토리 구조"}}},{"node":{"id":"6c0e93ce-fab2-5cd8-b369-8c7e35114bd4","fields":{"slug":"/웹-사이트-프로젝트-vs-웹-응용-프로그램-프로젝트/"},"frontmatter":{"title":"웹 사이트 프로젝트 vs 웹 응용 프로그램 프로젝트"}}},{"node":{"id":"e6017a82-883c-5533-b084-e4d128fba3f5","fields":{"slug":"/Nuget-패키지-dll-추출/"},"frontmatter":{"title":"Nuget 패키지 dll 추출"}}},{"node":{"id":"0747e4e2-4d9c-5f2e-9ad4-db4690dc2756","fields":{"slug":"/무료-웹-호스팅-비교/"},"frontmatter":{"title":"무료 웹 호스팅 비교"}}},{"node":{"id":"dec52422-f02f-5520-bfe2-d277ddc7a455","fields":{"slug":"/PRG-패턴-PostRedirectGet/"},"frontmatter":{"title":"PRG 패턴 (Post/Redirect/Get)"}}},{"node":{"id":"ef3f3ed5-f90e-552f-8c1a-f24d1eeb0573","fields":{"slug":"/Python-venv-Windows/"},"frontmatter":{"title":"Python venv (Windows)"}}},{"node":{"id":"73f61a9c-4b13-5f3c-b288-9f971499e1c9","fields":{"slug":"/print와-pprint/"},"frontmatter":{"title":"print와 pprint"}}},{"node":{"id":"42d9a8c0-c330-548e-a36c-c8b97811df23","fields":{"slug":"/정규화와-역정규화/"},"frontmatter":{"title":"정규화와 역정규화"}}},{"node":{"id":"8bcc825c-89ec-552c-9144-ac6b2afced1e","fields":{"slug":"/트래픽-튜닝/"},"frontmatter":{"title":"트래픽 튜닝"}}},{"node":{"id":"1f906753-4b2c-58e9-8b1d-65dbacd5a5ed","fields":{"slug":"/npx/"},"frontmatter":{"title":"npx"}}},{"node":{"id":"90f8d06a-0a5c-5fa2-bcb7-7ac1b4fccbdc","fields":{"slug":"/Branch/"},"frontmatter":{"title":"Branch"}}},{"node":{"id":"3e072448-1152-518b-89a4-0154bf7ed441","fields":{"slug":"/DataTable-클래스/"},"frontmatter":{"title":"DataTable 클래스"}}},{"node":{"id":"4e96b425-fd44-57b0-a26c-205a2db9f3f9","fields":{"slug":"/Typescript-시작하기/"},"frontmatter":{"title":"Typescript 시작하기"}}},{"node":{"id":"825a1946-8a6a-559a-9e11-93447cdedcdf","fields":{"slug":"/gitignore/"},"frontmatter":{"title":"gitignore"}}},{"node":{"id":"c65d18a5-967b-591b-a184-2f380d3f7847","fields":{"slug":"/Factory-Pattern/"},"frontmatter":{"title":"Factory Pattern"}}},{"node":{"id":"ee0abcf0-eb6f-569e-a2df-26ef807ffd53","fields":{"slug":"/네이밍-규칙naming-conventions/"},"frontmatter":{"title":"네이밍 규칙(naming conventions)"}}},{"node":{"id":"b3e00fd2-84a2-5bbc-8976-a76d7948ba15","fields":{"slug":"/AWS-API-Gateway/"},"frontmatter":{"title":"AWS API Gateway"}}},{"node":{"id":"c1d28daf-f0b4-521c-926c-88c14a61a609","fields":{"slug":"/ColdStart/"},"frontmatter":{"title":"ColdStart"}}},{"node":{"id":"45a48b17-f235-5fcf-90c4-f186e96b788e","fields":{"slug":"/Serverless/"},"frontmatter":{"title":"Serverless"}}},{"node":{"id":"b1e5d38b-5dfb-5406-a693-d18281ac16f8","fields":{"slug":"/NoSQL/"},"frontmatter":{"title":"NoSQL"}}},{"node":{"id":"59b56ebf-8c53-5362-82a7-3deb113c9308","fields":{"slug":"/Dynamo-DB/"},"frontmatter":{"title":"Dynamo DB"}}},{"node":{"id":"97236b20-03d7-59be-b021-0cf4f12ba08f","fields":{"slug":"/REST/"},"frontmatter":{"title":"REST"}}},{"node":{"id":"67555ff4-c43d-50d6-91fc-7db62ae5324a","fields":{"slug":"/TypeError-non-default-argument-content-follows-default-argument/"},"frontmatter":{"title":"TypeError: non-default argument 'content' follows default argument"}}},{"node":{"id":"247e0d6c-cb1f-523b-a365-12fbdf26de54","fields":{"slug":"/브랜치-관리-전략/"},"frontmatter":{"title":"브랜치 관리 전략"}}},{"node":{"id":"fd68eada-5e64-5d6e-ad3e-e7cccc28c242","fields":{"slug":"/Unit-Test단위-테스트/"},"frontmatter":{"title":"Unit Test(단위 테스트)"}}},{"node":{"id":"8fc059ee-a057-5299-9416-e5fe9a21f3b5","fields":{"slug":"/__post_init__/"},"frontmatter":{"title":"__post_init__"}}},{"node":{"id":"facbb85b-b3b0-54f1-b2ac-5593cedf9d02","fields":{"slug":"/dataclass/"},"frontmatter":{"title":"dataclass"}}},{"node":{"id":"f517cf21-d25d-5ad1-90b2-7cd04bdc1de5","fields":{"slug":"/FastAPI와-DDD/"},"frontmatter":{"title":"FastAPI와 DDD"}}},{"node":{"id":"c76d3263-2674-5711-9753-c7b1884886a2","fields":{"slug":"/vercel-배포-자동화/"},"frontmatter":{"title":"vercel 배포 자동화"}}},{"node":{"id":"643a5e74-e453-5eaf-be99-4fe90007fc0d","fields":{"slug":"/AWS-ECSElastic-Container-Service/"},"frontmatter":{"title":"AWS ECS(Elastic Container Service)"}}},{"node":{"id":"295a3a5e-5f68-53dd-a096-99c650a09f85","fields":{"slug":"/Blue-Green-Deploy-전략/"},"frontmatter":{"title":"Blue Green Deploy 전략"}}},{"node":{"id":"ef099c50-5b09-5374-b773-1646367f1a07","fields":{"slug":"/CloudFront/"},"frontmatter":{"title":"CloudFront"}}},{"node":{"id":"f2c13448-7669-5227-8e74-c0db79f8efa6","fields":{"slug":"/Poetry/"},"frontmatter":{"title":"Poetry"}}},{"node":{"id":"327528cd-aa5a-5ecb-9d02-1747c311b92a","fields":{"slug":"/DynamoDB의-동시성-제어Concurrency-Control/"},"frontmatter":{"title":"DynamoDB의 동시성 제어(Concurrency Control)"}}},{"node":{"id":"c61f89ee-7345-5822-a5bb-1ee417382592","fields":{"slug":"/FastAPI/"},"frontmatter":{"title":"FastAPI"}}},{"node":{"id":"6fde18dc-7c77-5d99-8142-13ade8537ae3","fields":{"slug":"/Pydantic-모델/"},"frontmatter":{"title":"Pydantic 모델"}}},{"node":{"id":"f97d2d57-9678-56e0-a700-2bd7ef00aca3","fields":{"slug":"/FastAPI의-데코레이터/"},"frontmatter":{"title":"FastAPI의 데코레이터"}}},{"node":{"id":"9b37002b-b912-5345-b81b-46951cc4a970","fields":{"slug":"/생성기generate-패턴/"},"frontmatter":{"title":"생성기(generate) 패턴"}}},{"node":{"id":"483a498b-b542-5587-989a-52dab4c1214c","fields":{"slug":"/FastAPI에서-데코레이터와-Dependency/"},"frontmatter":{"title":"FastAPI에서 데코레이터와 Dependency"}}},{"node":{"id":"80de20ad-d374-517c-ac92-d2877e4c06a8","fields":{"slug":"/FastAPI와-asyncio/"},"frontmatter":{"title":"FastAPI와 asyncio"}}},{"node":{"id":"87a218c9-82b0-5f05-90fa-a0d9da888853","fields":{"slug":"/aiohttp/"},"frontmatter":{"title":"aiohttp"}}},{"node":{"id":"222a8a91-8da9-500a-9074-4dd115cbe21f","fields":{"slug":"/단축어로-SLACK-프로필-변경하기/"},"frontmatter":{"title":"단축어로 SLACK 프로필 변경하기"}}},{"node":{"id":"75fcb75f-0a52-533f-a038-0a8460398f25","fields":{"slug":"/PynamoDB와-boto3-PynamoDB의-커넥션/"},"frontmatter":{"title":"PynamoDB와 boto3, PynamoDB의 커넥션"}}},{"node":{"id":"f15732ca-1b29-5230-aa8f-d32fd8ce5769","fields":{"slug":"/FastAPI에서-Postgresql의-커넥션-관리/"},"frontmatter":{"title":"FastAPI에서 Postgresql의 커넥션 관리"}}},{"node":{"id":"e0b43964-5998-5379-becc-614d8c62f076","fields":{"slug":"/Sqlalchemy-비동기-엔진에서의-Postgresql-Pooler/"},"frontmatter":{"title":"Sqlalchemy 비동기 엔진에서의 Postgresql Pooler"}}},{"node":{"id":"ef31575e-f174-58f7-84b7-832d38e952f9","fields":{"slug":"/FastAPI의-Pagenation/"},"frontmatter":{"title":"FastAPI의 Pagenation"}}},{"node":{"id":"c661de9c-fcb1-5bc6-b987-28d7cd303acb","fields":{"slug":"/SqlAlchemy의-QueuePool/"},"frontmatter":{"title":"SqlAlchemy의 QueuePool"}}},{"node":{"id":"7591133a-cdeb-5c9a-ab49-4ca7c8f3dea7","fields":{"slug":"/Pydantic-Model의-응용/"},"frontmatter":{"title":"Pydantic Model의 응용"}}},{"node":{"id":"cf792859-1afc-5118-bf50-0752527a6569","fields":{"slug":"/Union-Type/"},"frontmatter":{"title":"Union Type"}}},{"node":{"id":"c2c531ea-1018-5ad8-87b3-c1c027e8f2ee","fields":{"slug":"/우분투-용량-관리/"},"frontmatter":{"title":"우분투 용량 관리"}}},{"node":{"id":"ccff0278-8778-54c6-a28a-ffad6d97612d","fields":{"slug":"/Sqlalchemy에서의-트랜잭션-격리-수준-구현/"},"frontmatter":{"title":"Sqlalchemy에서의 트랜잭션 격리 수준 구현"}}},{"node":{"id":"ee1bfa9e-9eeb-52a2-a33a-88916dcc9119","fields":{"slug":"/트랜잭션-격리-수준Transaction-Isolation-Level/"},"frontmatter":{"title":"트랜잭션 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"a7292f80-7079-5082-9645-3def2d6750b8","fields":{"slug":"/PostgreSQL-Advisory-Locks-트랜잭션-레벨에서-구현/"},"frontmatter":{"title":"PostgreSQL Advisory Locks 트랜잭션 레벨에서 구현"}}},{"node":{"id":"acd438b5-e05c-5772-9da1-3ea3a67cefe0","fields":{"slug":"/Sqlalchemy의-func/"},"frontmatter":{"title":"Sqlalchemy의 func"}}},{"node":{"id":"8221080c-9128-57cc-b79e-c8a9e7959a90","fields":{"slug":"/동시성-제어문제-해결/"},"frontmatter":{"title":"동시성 제어문제 해결"}}},{"node":{"id":"4e23a734-8707-55b2-824e-d120641e8f1a","fields":{"slug":"/vscode-quick-Suggestions/"},"frontmatter":{"title":"vscode-quick Suggestions"}}},{"node":{"id":"1f589451-3bb6-501a-a892-6492654e760c","fields":{"slug":"/Typescript의-열거형/"},"frontmatter":{"title":"Typescript의 열거형"}}},{"node":{"id":"a5babc02-b843-5c39-85e7-1b34cce43cdd","fields":{"slug":"/Github-Action-Output/"},"frontmatter":{"title":"Github Action Output"}}},{"node":{"id":"8b1f5d89-c5ae-52b6-b3c7-19a8d6afda7a","fields":{"slug":"/Github-Actions/"},"frontmatter":{"title":"Github Actions"}}},{"node":{"id":"b81485d3-7cab-52c0-adf9-f489724dc88f","fields":{"slug":"/Github-Actions-Job---needs/"},"frontmatter":{"title":"Github Actions Job - needs"}}},{"node":{"id":"72e50b04-cb8a-55a6-b4ac-636d3dce4b78","fields":{"slug":"/Github-Actions-Workflow-수동으로-실행하기/"},"frontmatter":{"title":"Github Actions Workflow 수동으로 실행하기"}}},{"node":{"id":"2b53a4ed-50b1-5166-bde5-00f56edc9436","fields":{"slug":"/Typescript의-Testcode-맛보기/"},"frontmatter":{"title":"Typescript의 Testcode 맛보기"}}},{"node":{"id":"dbdceb4a-2ed6-5dbc-aa20-7dc961d63f54","fields":{"slug":"/시맨틱-버전-관리/"},"frontmatter":{"title":"시맨틱 버전 관리"}}},{"node":{"id":"6e6deb6d-e36d-5d2f-b11a-55fbc674c2ea","fields":{"slug":"/SQLAlchemy-create_all-메소드로-데이터베이스-테이블-자동-생성하기/"},"frontmatter":{"title":"SQLAlchemy create_all() 메소드로 데이터베이스 테이블 자동 생성하기"}}},{"node":{"id":"dd65c1da-59ff-5d58-a092-3ecc81bdb4fd","fields":{"slug":"/Sqlalchemy의-index/"},"frontmatter":{"title":"Sqlalchemy의 index"}}},{"node":{"id":"2de5adbd-b426-5f30-8811-ebd7fc04ff66","fields":{"slug":"/위치-기반-검색-기능의-구현/"},"frontmatter":{"title":"위치 기반 검색 기능의 구현"}}},{"node":{"id":"50b9db01-3888-5f30-80bc-b2d8ffd25486","fields":{"slug":"/인앱결제에서-백엔드는-무엇을-준비해야-할까/"},"frontmatter":{"title":"인앱결제에서 백엔드는 무엇을 준비해야 할까?"}}},{"node":{"id":"bb95007b-56db-5930-a9b8-4c09e2e118c4","fields":{"slug":"/식별-관계와-비식별-관계-그리고-CASCADE-옵션의-이해/"},"frontmatter":{"title":"식별 관계와 비식별 관계, 그리고 CASCADE 옵션의 이해"}}},{"node":{"id":"f76f95c7-1554-5431-a30b-7d03c93ac41c","fields":{"slug":"/arc-browser/"},"frontmatter":{"title":"arc browser"}}},{"node":{"id":"fe32f546-1476-5dc1-99f4-355cd81fba19","fields":{"slug":"/FastAPI-프로젝트의-시작/"},"frontmatter":{"title":"FastAPI 프로젝트의 시작"}}},{"node":{"id":"ae4611cf-ac19-58f9-be47-e8452f25a2df","fields":{"slug":"/Apple-Silicon과-pyenv/"},"frontmatter":{"title":"Apple Silicon과 pyenv"}}},{"node":{"id":"7edd7ada-7dda-553b-b007-2e7eacdc0c25","fields":{"slug":"/Geocoder와-Reverse-Geocoder/"},"frontmatter":{"title":"Geocoder와 Reverse Geocoder"}}},{"node":{"id":"ef7e194d-396d-5189-87b2-9905aa8edea4","fields":{"slug":"/Postgresql의-JSON과-JSONB/"},"frontmatter":{"title":"Postgresql의 JSON과 JSONB"}}},{"node":{"id":"ad9ce5f7-33b5-5f19-9087-52c928903f92","fields":{"slug":"/SQLModel에서-unique_constraints-설정하기/"},"frontmatter":{"title":"SQLModel에서 unique_constraints 설정하기"}}},{"node":{"id":"fbd5faae-ec78-5d51-ac80-d809dc5137d2","fields":{"slug":"/Supabase-Local-Dev-환경-꾸미기/"},"frontmatter":{"title":"Supabase Local Dev 환경 꾸미기"}}},{"node":{"id":"939d0130-e4ea-5ae4-a169-be69c0f404f9","fields":{"slug":"/Supabase와-Row-Level-Security-RLS/"},"frontmatter":{"title":"Supabase와 Row-Level Security (RLS) "}}},{"node":{"id":"6c085c2e-fa7b-5dcc-a26f-df91cf9354ea","fields":{"slug":"/Supabase-Local-개발-환경-꾸미기---DB-세팅/"},"frontmatter":{"title":"Supabase Local 개발 환경 꾸미기 - DB 세팅"}}},{"node":{"id":"f1f51fb0-adac-5433-9a00-912141ff3182","fields":{"slug":"/Supabase-CLI-db-migration-이력-초기화하기/"},"frontmatter":{"title":"Supabase CLI db migration 이력 초기화하기"}}},{"node":{"id":"2a0b1ae0-7af6-5ce1-90ad-57af39dc2085","fields":{"slug":"/Supabase-EdgeFunction---Deno-개발환경-꾸미기/"},"frontmatter":{"title":"Supabase EdgeFunction  - Deno 개발환경 꾸미기"}}},{"node":{"id":"bbfd7494-2deb-5de4-88dd-5ffbdd240cf6","fields":{"slug":"/Postgresql-Function-Trigger-생성-쿼리문-확인하기/"},"frontmatter":{"title":"Postgresql Function, Trigger 생성 쿼리문 확인하기"}}},{"node":{"id":"e2d90afb-f1f2-5e1f-aab6-820a0d5cf41c","fields":{"slug":"/postgresql의-pg_jsonschema/"},"frontmatter":{"title":"postgresql의 pg_jsonschema"}}},{"node":{"id":"a692b906-efe4-5b06-a108-de1a09926ea9","fields":{"slug":"/Postgresql에서-ENUM-타입에서-값-삭제하기/"},"frontmatter":{"title":"Postgresql에서 ENUM 타입에서 값 삭제하기"}}},{"node":{"id":"d48736cc-957e-53f5-9f48-aac53d5598e4","fields":{"slug":"/PostgreSQL에서-테이블-로우를-JSON으로-변환하기/"},"frontmatter":{"title":"PostgreSQL에서 테이블 로우를 JSON으로 변환하기"}}},{"node":{"id":"02ae12df-41b7-5333-a060-ecc60974fbab","fields":{"slug":"/RLS에-대한-궁금증-모음/"},"frontmatter":{"title":"RLS에 대한 궁금증 모음"}}},{"node":{"id":"78c2562a-631b-572d-8dee-132c9ff9b074","fields":{"slug":"/Deno에서-URL의-쿼리-스트링Query-String-다루기/"},"frontmatter":{"title":" Deno에서 URL의 쿼리 스트링(Query String) 다루기"}}},{"node":{"id":"bab930ba-913e-596b-a917-bdd124dd36db","fields":{"slug":"/Supabase에서-뷰에도-RLS-적용하기/"},"frontmatter":{"title":"Supabase에서 뷰에도 RLS 적용하기"}}},{"node":{"id":"8c276d68-536a-5e9d-a09f-c0055c239046","fields":{"slug":"/supabase-custom-claims를-활용한-관리자-권한-관리/"},"frontmatter":{"title":"supabase-custom-claims를 활용한 관리자 권한 관리"}}},{"node":{"id":"d6698c34-32be-55f0-94d2-50b66aef1073","fields":{"slug":"/Supabase를-위한-Bitbucket-Pipelines-CICD-워크플로우-구축하기/"},"frontmatter":{"title":"Supabase를 위한 Bitbucket Pipelines CI/CD 워크플로우 구축하기"}}},{"node":{"id":"bc763a45-0f35-5420-9eed-9e6387ff48ee","fields":{"slug":"/Pyenv-local-실행을-했는데-파이썬-버전이-바뀌지-않는다/"},"frontmatter":{"title":"Pyenv local 실행을 했는데 파이썬 버전이 바뀌지 않는다"}}},{"node":{"id":"60b158b5-de2c-56a7-a158-53f3648b2889","fields":{"slug":"/Django-설치/"},"frontmatter":{"title":"Django 설치"}}},{"node":{"id":"711d4b8d-3afb-59f8-a47e-efe8b52f1665","fields":{"slug":"/docker-compose를-활용한-postgresql과-django-커넥션-만들기/"},"frontmatter":{"title":"docker-compose를 활용한 postgresql과 django 커넥션 만들기"}}},{"node":{"id":"3c997249-c541-501d-9479-558a653fc409","fields":{"slug":"/Nextjs-소개와-설치-간단-예제/"},"frontmatter":{"title":"Next.js 소개와 설치, 간단 예제"}}},{"node":{"id":"e04ee4b2-2742-5601-a3f7-147ad7074bc1","fields":{"slug":"/ngrok-로컬-서버를-쉽게-공개하는-도구/"},"frontmatter":{"title":"ngrok: 로컬 서버를 쉽게 공개하는 도구"}}},{"node":{"id":"286a5830-d62e-5ddd-99e9-d237161a5838","fields":{"slug":"/Django-Discord-소셜-회원가입-및-로그인-구현/"},"frontmatter":{"title":"Django Discord 소셜 회원가입 및 로그인 구현"}}},{"node":{"id":"e2facd8b-fe1b-5d7e-8134-327a36c58230","fields":{"slug":"/Nextjs-Supabase-회원가입-구현/"},"frontmatter":{"title":"Next.js + Supabase 회원가입 구현"}}},{"node":{"id":"987a5340-8662-50df-85c0-6b7c3732d791","fields":{"slug":"/Django-프로젝트에-Swagger-설정하기/"},"frontmatter":{"title":"Django 프로젝트에 Swagger 설정하기"}}},{"node":{"id":"989746e1-cdef-5498-8c00-2087bbb27bd7","fields":{"slug":"/Django-Rest-Framework에서-JWT를-이용한-사용자-인증-구현/"},"frontmatter":{"title":"Django Rest Framework에서 JWT를 이용한 사용자 인증 구현"}}},{"node":{"id":"11691347-100c-5676-9729-f22ce8a43272","fields":{"slug":"/Django의-Serializers/"},"frontmatter":{"title":"Django의 Serializers"}}},{"node":{"id":"910235bb-5188-5a17-a705-a552a6684e7d","fields":{"slug":"/Go-입문/"},"frontmatter":{"title":"Go 입문"}}},{"node":{"id":"a1ef6dd3-d896-5758-8f72-9e378dcab0f3","fields":{"slug":"/Go를-활용한-OAuth-20-구현/"},"frontmatter":{"title":"Go를 활용한 OAuth 2.0 구현"}}},{"node":{"id":"55e2a5f0-e2c2-5f20-9bc1-e6f52142b1ab","fields":{"slug":"/Django의-사용자-인증-시스템-커스터마이징/"},"frontmatter":{"title":"Django의 사용자 인증 시스템 커스터마이징"}}},{"node":{"id":"27fc9be6-e48b-52a8-bf6d-c0c664700209","fields":{"slug":"/DRF의-API-View/"},"frontmatter":{"title":"DRF의 API View"}}},{"node":{"id":"19273a3e-a109-5cb0-a53a-102a2c1f1f74","fields":{"slug":"/AWS-활용-테스트-서버-구현-1/"},"frontmatter":{"title":"AWS 활용 테스트 서버 구현 (1)"}}},{"node":{"id":"b443bdc5-d571-57ac-a75f-e433dc12f651","fields":{"slug":"/AWS에서-EC2-인스턴스-생성-및-Visual-Studio-Code로-원격-연결하기/"},"frontmatter":{"title":"AWS에서 EC2 인스턴스 생성 및 Visual Studio Code로 원격 연결하기"}}},{"node":{"id":"88f3a1cc-7ec0-50be-a43d-d969e27c4529","fields":{"slug":"/Django-REST-Framework에서-가상-필드-추가하기/"},"frontmatter":{"title":"Django REST Framework에서 가상 필드 추가하기"}}},{"node":{"id":"ae529d5f-12b2-59f1-89bc-e832cde40652","fields":{"slug":"/Mock과-Stub-Fixture/"},"frontmatter":{"title":"Mock과 Stub, Fixture"}}},{"node":{"id":"388f1fc6-4ef9-5391-ad7c-03a8e88d99e3","fields":{"slug":"/Install-Tailwind-CSS-with-Nextjs/"},"frontmatter":{"title":"Install Tailwind CSS with Next.js"}}},{"node":{"id":"dbba3bc0-4c3c-5d9d-87fa-c9c9650907df","fields":{"slug":"/Ubuntu-DLNA-서버-설정/"},"frontmatter":{"title":"Ubuntu DLNA 서버 설정"}}},{"node":{"id":"626fd5b3-36c4-5633-8916-46f9aeba4756","fields":{"slug":"/GitHub-Container-Registry-vs-Docker-Hub/"},"frontmatter":{"title":"GitHub Container Registry vs Docker Hub"}}},{"node":{"id":"a0117df3-8740-55e0-b9e9-d14f35c4e2a9","fields":{"slug":"/N1-문제/"},"frontmatter":{"title":"N+1 문제"}}},{"node":{"id":"e925ca86-1d32-5737-b469-6b04e049b5be","fields":{"slug":"/N1-문제의-해결방법/"},"frontmatter":{"title":"N+1 문제의 해결방법"}}},{"node":{"id":"7caa9886-de89-5549-a331-43a790e9be9d","fields":{"slug":"/Django의-관리자-페이지-만들기/"},"frontmatter":{"title":"Django의 관리자 페이지 만들기"}}},{"node":{"id":"4a03fdbb-525f-5955-a2f4-d2e3f37dab34","fields":{"slug":"/Django의-startapp/"},"frontmatter":{"title":"Django의 startapp"}}},{"node":{"id":"d02a3ccb-149b-5f4e-b724-2a5c694d9dd6","fields":{"slug":"/SD-카드-기반-디스크-오류-및-해결-과정/"},"frontmatter":{"title":"SD 카드 기반 디스크 오류 및 해결 과정"}}},{"node":{"id":"bd6bfd1a-0643-5893-b4fe-19074e66dee3","fields":{"slug":"/Docker에서-Python-환경-변수-관리/"},"frontmatter":{"title":"Docker에서 Python 환경 변수 관리"}}},{"node":{"id":"0baf5600-7bc6-5104-b434-352d0e8cf8fb","fields":{"slug":"/Python-Mocking시-patch-경로-문제-해결하기/"},"frontmatter":{"title":"Python Mocking시 patch 경로 문제 해결하기"}}},{"node":{"id":"ac8d2058-f151-5c32-bb36-494173ac916f","fields":{"slug":"/FastAPI의-의존성-주입Dependency-Injection/"},"frontmatter":{"title":"FastAPI의 의존성 주입(Dependency Injection)"}}},{"node":{"id":"7e134f83-d0a3-5e87-82cd-6877e6ba4567","fields":{"slug":"/FastAPI-의존성-주입의-심화-활용법과-주의점/"},"frontmatter":{"title":"FastAPI 의존성 주입의 심화 활용법과 주의점"}}},{"node":{"id":"06b9e98d-7766-587f-b48e-423e69c5a214","fields":{"slug":"/Typescript의-얇은-복사-vs-깊은-복사/"},"frontmatter":{"title":"Typescript의 얇은 복사 vs 깊은 복사"}}},{"node":{"id":"2dfdf2e4-9e64-596a-a6d6-cb81c682ef09","fields":{"slug":"/React-Native-설치/"},"frontmatter":{"title":"React Native 설치"}}},{"node":{"id":"dc2fdc41-a035-5dbc-aa8b-36c493e556cf","fields":{"slug":"/React-Native의-프로젝트-구조와-화면-이동-구현하기/"},"frontmatter":{"title":"React Native의 프로젝트 구조와 화면 이동 구현하기"}}},{"node":{"id":"f071c474-d82d-5dcf-9c08-0d117c0786d8","fields":{"slug":"/React-Native-Navigation과-Paper-기본부터-사용하기/"},"frontmatter":{"title":"React Native Navigation과 Paper: 기본부터 사용하기"}}},{"node":{"id":"41e18e50-7046-569a-a173-6aadc4b70426","fields":{"slug":"/GraphQL과-Django/"},"frontmatter":{"title":"GraphQL과 Django"}}},{"node":{"id":"d333dddb-d654-5b39-9705-92748c1d858d","fields":{"slug":"/우리-팀에-맞는-API-Gateway-선택하기/"},"frontmatter":{"title":"우리 팀에 맞는 API Gateway 선택하기"}}},{"node":{"id":"bfc8ced1-57c5-55e6-a278-bc62fbe28916","fields":{"slug":"/Elastic-APM/"},"frontmatter":{"title":"Elastic APM"}}},{"node":{"id":"7049857b-fde0-5f51-8131-43655deb98ca","fields":{"slug":"/GraphQL과-Django-2/"},"frontmatter":{"title":"GraphQL과 Django 2"}}},{"node":{"id":"f6783709-6fe0-53ce-9d40-6d4c45ff4b7e","fields":{"slug":"/Deepseek-R1-로컬-설치/"},"frontmatter":{"title":"Deepseek R1 로컬 설치"}}},{"node":{"id":"8f11b5a0-d13f-5def-b485-8b9313ecb0f6","fields":{"slug":"/uv-간단-소개-및-적용/"},"frontmatter":{"title":"uv 간단 소개 및 적용"}}},{"node":{"id":"54bf091e-628d-5868-8990-1db21a44ef7c","fields":{"slug":"/Nginx를-활용한-Reverse-Proxy-구현1/"},"frontmatter":{"title":"Nginx를 활용한 Reverse Proxy 구현(1)"}}},{"node":{"id":"2db7be05-a913-5e8f-a010-3d3d5dfc0cc0","fields":{"slug":"/Nginx를-활용한-Reverse-Proxy-구현2/"},"frontmatter":{"title":"Nginx를 활용한 Reverse Proxy 구현(2)"}}},{"node":{"id":"e6010f44-06a4-5a70-880c-a5eb66228f99","fields":{"slug":"/poetry를-활용해-안정적으로-package-업데이트하기/"},"frontmatter":{"title":"poetry를 활용해 안정적으로 package 업데이트하기"}}},{"node":{"id":"e87675f2-5775-56e9-a865-a738372a3cbf","fields":{"slug":"/React-Native에서-커스텀-폰트-추가하여-사용하기/"},"frontmatter":{"title":"React Native에서 커스텀 폰트 추가하여 사용하기"}}},{"node":{"id":"43249e85-0fc9-55b4-89ce-7a09bad9ed89","fields":{"slug":"/LDAP/"},"frontmatter":{"title":"LDAP"}}},{"node":{"id":"a75adc3f-5c1a-5915-b3b4-6161d21150fd","fields":{"slug":"/Ruff/"},"frontmatter":{"title":"Ruff"}}},{"node":{"id":"b3908629-2878-58ff-9d75-3eaa9afe939a","fields":{"slug":"/Nginx의-Reverse-Proxy-모니터링/"},"frontmatter":{"title":"Nginx의 Reverse Proxy 모니터링"}}},{"node":{"id":"877e8495-8028-5b68-8f55-a1c186b09f72","fields":{"slug":"/Django-모델에서-GraphQL-스키마-자동-생성/"},"frontmatter":{"title":"Django 모델에서 GraphQL 스키마 자동 생성"}}},{"node":{"id":"543e7c6d-4b87-5ff3-92ad-ff851d86ee8b","fields":{"slug":"/DataLoader의-적용/"},"frontmatter":{"title":"DataLoader의 적용"}}},{"node":{"id":"66a11a51-172b-502d-8746-39ce9aaf0028","fields":{"slug":"/분산된-모놀리스를-위한-관리자-페이지-시스템-설계-제안/"},"frontmatter":{"title":"분산된 모놀리스를 위한 관리자 페이지 시스템 설계 제안"}}},{"node":{"id":"f3ecc3d6-83df-5a75-91cc-ef3e294b3e16","fields":{"slug":"/Django와-MySQL에서-DB-Sleep으로-인한-Hang-문제-해결-방안/"},"frontmatter":{"title":"Django와 MySQL에서 DB Sleep으로 인한 Hang 문제 해결 방안"}}},{"node":{"id":"25a2c746-4abd-5665-b779-d7cd5026cded","fields":{"slug":"/Cloudflare-Workers-꾸미기/"},"frontmatter":{"title":"Cloudflare Workers 꾸미기"}}},{"node":{"id":"527edba3-65f4-59c1-b5f6-797bd4537b93","fields":{"slug":"/새로운-아키텍쳐의-선택/"},"frontmatter":{"title":"새로운 아키텍쳐의 선택"}}},{"node":{"id":"c8f0ea2c-1d83-534c-ad21-31df4417fc05","fields":{"slug":"/Vercel-Functions-CPU-사용량-줄이는-법/"},"frontmatter":{"title":"Vercel Functions CPU 사용량 줄이는 법"}}},{"node":{"id":"43c84be8-0a5f-5d1d-8ca8-33d63ff6b360","fields":{"slug":"/Vercel의-캐싱-구조-이해하기/"},"frontmatter":{"title":"Vercel의 캐싱 구조 이해하기"}}},{"node":{"id":"b92cfdd0-85c4-555d-a324-9b9c9b0f3724","fields":{"slug":"/Oracle-Cloud-ARM-인스턴스-생성-완전-가이드/"},"frontmatter":{"title":"Oracle Cloud ARM 인스턴스 생성 완전 가이드"}}}]},"previous":{"fields":{"slug":"/Cloudflare-Workers-꾸미기/"},"frontmatter":{"title":"Cloudflare Workers 꾸미기"}},"next":{"fields":{"slug":"/Vercel-Functions-CPU-사용량-줄이는-법/"},"frontmatter":{"title":"Vercel Functions CPU 사용량 줄이는 법"}}},"pageContext":{"id":"527edba3-65f4-59c1-b5f6-797bd4537b93","series":null,"previousPostId":"25a2c746-4abd-5665-b779-d7cd5026cded","nextPostId":"c8f0ea2c-1d83-534c-ad21-31df4417fc05"}},"staticQueryHashes":[],"slicesMap":{}}