{"componentChunkName":"component---src-templates-post-jsx","path":"/Sqlalchemy-비동기-엔진에서의-Postgresql-Pooler/","result":{"data":{"site":{"siteMetadata":{"title":"SharkniA"}},"markdownRemark":{"id":"e0b43964-5998-5379-becc-614d8c62f076","excerpt":"결론 supabase 기준, Sqlalchemy의 비동기 엔진에서 Postgresql pooler (supavisor)에 오류 없이 연결하기 위해서는  을 다음과 같이 구성해주면 된다.  statementcachesize, preparedstatementcache_size를 둘 다 모두 0으로 줘야 한다. 그리고 왜 발생하는지 모르겠는 간헐적인 오류(캐싱…","html":"<h2>결론</h2>\n<p>supabase 기준, Sqlalchemy의 비동기 엔진에서 Postgresql pooler (supavisor)에 오류 없이 연결하기 위해서는 <code class=\"language-text\">create_async_engine</code> 을 다음과 같이 구성해주면 된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> uuid <span class=\"token keyword\">import</span> uuid4\n<span class=\"token keyword\">from</span> asyncpg <span class=\"token keyword\">import</span> Connection\n\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>생략<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CConnection</span><span class=\"token punctuation\">(</span>Connection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">_get_unique_id</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        캐싱을 만들 시에 캐싱 아이디가 중복으로 생성되어서 오류가 발생하는 경우가 있다.\n        statement_cache_size를 0으로 해도 일단 캐싱을 만들고 오류를 낸다.\n        따라서 캐싱을 사용하지 않을 것이므로, 아예 중복되지 않게 UUID로 생성해버린다.\n        \"\"\"</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string-interpolation\"><span class=\"token string\">f'__asyncpg_</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>prefix<span class=\"token punctuation\">}</span></span><span class=\"token string\">_</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>uuid4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">__'</span></span>\n\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>생략<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\nDATABASE_URL <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"postgresql+asyncpg://postgres.[Project ID]:[Password]@aws-0-[Region].pooler.supabase.com:6543/postgres?prepared_statement_cache_size=0\"</span></span>\n    _db_connection <span class=\"token operator\">=</span> create_async_engine<span class=\"token punctuation\">(</span>\n        DATABASE_URL<span class=\"token punctuation\">,</span>\n        connect_args<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"statement_cache_size\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">'connection_class'</span><span class=\"token punctuation\">:</span> CConnection<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span></code></pre></div>\n<p>statement<em>cache</em>size, prepared<em>statement</em>cache_size를 둘 다 모두 0으로 줘야 한다.</p>\n<p>그리고 왜 발생하는지 모르겠는 간헐적인 오류(캐싱 ID를 중복되게 생성하려고 시도함)를 해결하기 위해 Connection 클래스를 상속받아 <em>get</em>unique<em>id 메소드를 오버라이딩 해주고, 해당 클래스를 connection</em>class로 사용하도록 했다. 이렇게 하면 id 중복 생성 오류를 방지할 수 있다. </p>\n<p>일반적인 글이라면 결론이 서두에 나온다면 너무나 시시하겠지만 기술 블로그이니 괜찮다. </p>\n<h2>문제 해결에 관한 글</h2>\n<h3>발단</h3>\n<p>supabase에서 메일이 왔다. </p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/754811dd5daabc41fab8df2eb32a001e/af70e/image1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 128.82352941176472%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAADAElEQVR42p1V23LiMAzN/38SD52h0z7yAJT7fdMkTkLuIeGu1ZETCrPp7lJmNJZtRT46OjaGaZo0mUxos9mITadTGo/HZFkWrddr6vV6sg9/sVjQfD6X+WAwoOFwKN9cr1eqfwYCWq0Wvb29UbvdppeXF7HX11d6f3+nTqcjhyBuNpsRACBZt9uVcblcPia0bVsQfXx8UL/fp9FoRKvVSoKBbr/f0zM/418BOP3evlu7Jcx3Ozqfz38ENQX/F8Lj6SQJYSf2Yfdrl8uFmmJOlX+/jtGI44Qs26FtEFIYxRSEIfsBRbyOeZKmpFyPIvaxFoSRxEZxTP42oJDncZKwH1KW5WTsioI/jOhwODTy1+Q3c12VjC4CBVAhMU6Jk1TQYD1JM0qSVHyNJhVE2MeY8j5QH49HnRBl2UpJWa7n02q9oS7LZzqb05DlNGAZTViHn5Yt+5ajyGQfNGFu89zzt+KDRyNlRFjAaUColMtBjnyQ8BpORhXn80XKRpO0Xb/mPNZKMfI8Jz/YCsllWRI4LTkB5IRESAh+i6KU8SBzPoT9stzLGpDdZONwuYPhmO+kKd1zXFcQO1yKw2iV61elOTIX4xibR9AAHxwWDASHGyAZnAChBHIiJFCeTlQnUZ4njchy3TSMaZbJiEZiD6ily1hESXXJxb6UklFSwWvYw7wu7bvrKCVDDigR5YpQIy1cXa4n5YjxGtDXlMCwjzgP3beVFra+KepWHoLQYfgYkcR2wJtHm18mmZ+W3pPkntCFOTQKCgwgQkJwVAcLEuU9CDvNtLjBFcRc8we5gZJbl8vqpoAjbCAIfsIfHCr1P/Xa4GPcFm2aL/j6wgfCJ64lKAFv/lYbZONXj4iLi8GjJAQiBKBUvDQwXDtoc7Fc0XDE/y/8qjc9EE3dNqCdLNvdShVeUq03UAG+4IucIB/2cT3xnDWWDA7vSU6q16QWsKyzHOTAfCeHoNs+l/mj/5Snm4ImQHufliOI7l+SR6PK/v5/w10upFtoiu5oyHyVP0b4G9LzywBICL9oAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image1' title='' src='/static/754811dd5daabc41fab8df2eb32a001e/ca1dc/image1.png' srcset='/static/754811dd5daabc41fab8df2eb32a001e/e7570/image1.png 170w,\n/static/754811dd5daabc41fab8df2eb32a001e/f46e7/image1.png 340w,\n/static/754811dd5daabc41fab8df2eb32a001e/ca1dc/image1.png 680w,\n/static/754811dd5daabc41fab8df2eb32a001e/02d09/image1.png 1020w,\n/static/754811dd5daabc41fab8df2eb32a001e/af70e/image1.png 1184w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n여태 본 기억이 없었는데, Final reminder라도 되어있는걸 보니 이미 여러번 고지했던 모양이다. </p>\n<p>읽어보니 Pgbouncer 지원이 종료된다는 내용이다. 지원이 종료되는건 알고 있었는데, 아예 Connection string을 죽여버리는 모양이다. 잔인하다는 생각이 들었지만 어차피 우리는 Pooler는 진작에 포기했으므로 상관이 없었다. </p>\n<p>문제는 다음이었는데, DB Direct access에 대한 IPv4 주소 지원도 끝난다니 이건 좀 문제의 소지가 있었다. </p>\n<p>마침 어제 지난번 DB 세팅에 대한 회고를 끝내서 다행이었다. </p>\n<h3>전개</h3>\n<p>선택지는 두가지이다. Supavisor 도입, 네트워크가 IPv6를 지원하도록 설정하고 Direct 연결 방법을 계속해서 사용. </p>\n<p>개인적으로 </p>\n<ul>\n<li>네트워크 설정에 상대적으로 약함</li>\n<li>WebRTC를 하던 때의 기억 때문에 IPv6에 안좋은 감정이 있음 </li>\n<li>현재 백엔드의 네트워크 설정을 직접 진행하지 않았었음 </li>\n<li>혼자 출근한 백엔드는 나 혼자임</li>\n<li>Pooler와 씨름을 한 기억이 최근이고, 회고는 더더욱 최근임</li>\n</ul>\n<p>의 이유로 Supavisor 도입에 대해 다른 백엔드가 출근하기 전 잠깐 살펴보기로 했다.</p>\n<p>그런데 왠걸? 직접 설치부터 해야 하나라고 막연히 생각을 했었는데(supabase의 공식 문서에는 아직 supavisor에 대한 내용이 적어도 찾기 쉬운 곳에 있지는 않다. ) 그렇지 않았다. </p>\n<p><a href=\"https://github.com/orgs/supabase/discussions/17817\">https://github.com/orgs/supabase/discussions/17817</a></p>\n<p>해당 링크를 보아하니 이미 꽤 지원이 진행된 상태였는지, connection string만 바꾸면 간단하게 Pgbouncer가 아니라 Supavisor를 사용하여 연결할 수 있다고 적혀 있었다. </p>\n<p>그래서 해당 링크를 참조해 Connection string은 약간 수정을 해야 했지만, 어쨌든 Supavisor 연결에 간단하게 성공해버렸다. </p>\n<h3>위기</h3>\n<p>곧장 과거 겪었던 것과 같은 문제가 발생했다. Sqlalchemy 입장에서는 Pgbouncer와 Supavisor를 따로 구분하지 못하는지 Transaction 또는 Session 풀 모드에서는 캐싱이 지원되지 않는다는 에러 문구가 발생했다. </p>\n<p>여기서 잠깐, 포기하고 얌전히 IPv6 설정을 보러 갈까 했는데, 아직 다른 백엔드가 아무도 출근하지 않았다. </p>\n<p>일단 Pool mode를 바꿔야 다음 단계의 설정을 진행할 수 있었는데, Pgbouncer의 Pool mode는 supabase 콘솔에서 세팅을 지원하지만 supavisor는 어떻게 바꿔야 할지 의문이었다. </p>\n<p>해당 의문은 말도 못하게 간단하게 풀렸다. 콘솔에 들어가보니 어느새 쥐도 새도 모르게 Pgbouncer 관련 섹션이 supavisor 관련 섹션으로 바뀌어있었다. </p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/7c5279045f32fb30cbeb9d1c39351ce2/98f2e/image2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 38.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAoUlEQVR42pWQbQ6EIAxEuQogn6Lc/3Q1rwmGqOvu/ngBtDOd1vTeZd93iTGKc06898p8/xU0Jucsy7LcftAghCDWWn1/4zRE+NRp2zYhfa1VKaXcWNdV4U4NWkMKuJqmlIT0Q3ydAviGlhM0IcVPKTGbk42kJGqtnclGUzxYj/m0fAoRzUacmLGO0WwkRKOGT+PCXPjGGJsmusO3wn9gIgwPE/TlErXrnBgAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image2' title='' src='/static/7c5279045f32fb30cbeb9d1c39351ce2/ca1dc/image2.png' srcset='/static/7c5279045f32fb30cbeb9d1c39351ce2/e7570/image2.png 170w,\n/static/7c5279045f32fb30cbeb9d1c39351ce2/f46e7/image2.png 340w,\n/static/7c5279045f32fb30cbeb9d1c39351ce2/ca1dc/image2.png 680w,\n/static/7c5279045f32fb30cbeb9d1c39351ce2/02d09/image2.png 1020w,\n/static/7c5279045f32fb30cbeb9d1c39351ce2/9d567/image2.png 1360w,\n/static/7c5279045f32fb30cbeb9d1c39351ce2/98f2e/image2.png 2012w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n위 이슈에서 설명된 supavisor 관련 connection string은 <code class=\"language-text\">user</code> 로 시작하는 부분이 옳지 않아서 수정이 필요했는데, 콘솔의 pgbouncer 관련 연결 connection string 에는 제대로 적혀있었다. 아무래도 메일에 적어보낸 이슈이지만 따로 수정을 하지는 않은 모양이다.. </p>\n<p>아무튼간 pool mode를 변경 후 테스트를 할 수 있었다. </p>\n<h3>절정1</h3>\n<p>Pool mode를 바꿨다고 해서 바로 연결이 가능하지는 않다. 서버 인스턴스를 실행하면 짜잔! 성공적인 DB 연결 대신 다음과 같은 문구를 볼 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"plaintext\"><pre class=\"language-plaintext\"><code class=\"language-plaintext\">sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) &lt;class 'asyncpg.exceptions.InvalidSQLStatementNameError'>: prepared statement \"__asyncpg_stmt_b__\" does not exist\nHINT:  \nNOTE: pgbouncer with pool_mode set to \"transaction\" or\n\"statement\" does not support prepared statements properly.\nYou have two options:\n* if you are using pgbouncer for connection pooling to a\n  single server, switch to the connection pool functionality\n  provided by asyncpg, it is a much better option for this\n  purpose;\n* if you have no option of avoiding the use of pgbouncer,\n  then you can set statement_cache_size to 0 when creating\n  the asyncpg connection object.</code></pre></div>\n<p>Sqlalchemy를 사용중이기 때문에 첫번째 방법은 자연스럽게 더 고려할것도 없이 기각이며, statement<em>cache</em>size를 0으로 수정하는 것이 현재 내 인프라에서 선택할 수 있는 방법이었다.</p>\n<p><a href=\"https://docs.sqlalchemy.org/en/20/dialects/postgresql.html\">https://docs.sqlalchemy.org/en/20/dialects/postgresql.html</a></p>\n<p>지난번 기나긴 고생 이후 공식 문서를 항상 참조하는 습관을 들이게 됐다. 아주 긍정적인 방향이라고 생각한다. </p>\n<p>공식 문서를 참조하면,</p>\n<div class=\"gatsby-highlight\" data-language=\"plaintext\"><pre class=\"language-plaintext\"><code class=\"language-plaintext\">engine = create_async_engine(\"postgresql+asyncpg://user:pass@hostname/dbname?prepared_statement_cache_size=0\")</code></pre></div>\n<p>의 방식으로 statement<em>cache</em>size를 0으로 설정할 수 있는 것을 알 수 있다. </p>\n<p>이 설정을 해준 후, 다시 서버 인스턴스를 실행하면 짜잔! DB 연결이 아주 잘 된다. 쿼리도 잘 날리고, 결과도 잘 받아온다.</p>\n<p>이 와중에 Cache 생성 시에 같은 인덱스로 중복 생성되어서 오류가 발생하기도 했다. 그래서 SqlAlchemy의 Connection 클래스를 상속받아 캐시의 아이디를 생성하는 메소드를 수정해주었다. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> asyncpg <span class=\"token keyword\">import</span> Connection\n<span class=\"token keyword\">from</span> uuid <span class=\"token keyword\">import</span> uuid4\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CConnection</span><span class=\"token punctuation\">(</span>Connection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">_get_unique_id</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        캐싱을 만들 시에 캐싱 아이디가 중복으로 생성되어서 오류가 발생하는 경우가 있다.\n        statement_cache_size를 0으로 해도 일단 캐싱을 만들고 오류를 낸다.\n        따라서 캐싱을 사용하지 않을 것이므로, 아예 중복되지 않게 UUID로 생성해버린다.\n        \"\"\"</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string-interpolation\"><span class=\"token string\">f'__asyncpg_</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>prefix<span class=\"token punctuation\">}</span></span><span class=\"token string\">_</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>uuid4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">__'</span></span></code></pre></div>\n<p>이후 DB 커넥션을 만들 때에 해당 클래스를 기본 Connection 클래스 대신 사용하도록 설정해주면 된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">DATABASE_URL <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"postgresql+asyncpg://postgres.[Project ID]:[Password]@aws-0-[Region].pooler.supabase.com:6543/postgres?prepared_statement_cache_size=0\"</span></span>\n    _db_connection <span class=\"token operator\">=</span> create_async_engine<span class=\"token punctuation\">(</span>\n        DATABASE_URL<span class=\"token punctuation\">,</span>\n        connect_args<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n            <span class=\"token string\">'connection_class'</span><span class=\"token punctuation\">:</span> CConnection<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span></code></pre></div>\n<p>여기까지 작업을 해줘서 오류를 해결하고 같은 쿼리를 연속으로 날리면? </p>\n<p>짜잔! 다음과 같은 오류를 볼 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"plaintext\"><pre class=\"language-plaintext\"><code class=\"language-plaintext\">sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) &lt;class 'asyncpg.exceptions.InvalidSQLStatementNameError'>: prepared statement \"__asyncpg_stmt_9462b5fe-88dc-46f5-98fb-57981ea56de0__\" does not exist\nHINT:  \nNOTE: pgbouncer with pool_mode set to \"transaction\" or\n\"statement\" does not support prepared statements properly.\nYou have two options:\n* if you are using pgbouncer for connection pooling to a\n  single server, switch to the connection pool functionality\n  provided by asyncpg, it is a much better option for this\n  purpose;\n* if you have no option of avoiding the use of pgbouncer,\n  then you can set statement_cache_size to 0 when creating\n  the asyncpg connection object.</code></pre></div>\n<p>그렇다, 오류는 반복된다. </p>\n<h3>절정2</h3>\n<p>이미 여기까지 시간을 꽤 쓴 상태였기 때문에 조금만 더 무언가를 해보기로 했다. </p>\n<p>캐시 사용을 아무리 꺼도, 도대체가 캐시를 계속 만들고 거기서 오류를 내는 이 상황. </p>\n<p>다행히 비슷한 오류를 겪는 사람들을 깃허브 이슈에서 찾을 수 있었다. </p>\n<p>이미 나의 신뢰를 많이 잃어버린 챗지피티에게 이 문제를 상담하면 <code class=\"language-text\">statement_cache_size</code> 옵션을 0으로 설정해서 connect_args에 넣으라고 한다. PgBouncer로 붙이려고 애써봤었을 때에 해당 옵션을 넣어도 아무런 변화가 없이 그대로 오류가 발생했었고, 공식문서에는 존재하지 않는 옵션이어서 이번에는 무시하고 넘어갔었다. </p>\n<p>근데 충격적이게도 한가지 옵션을 썼을 땐 되지 않고 두 옵션을 동시에 사용하면 된다고 한다.. 이게 무슨 일일까? 나는 왜 두 옵션을 동시에 쓸 생각을 못했을까?(이 생각을 어떻게 하나요?)</p>\n<p>최종적으로 DB Connection String을 다음과 같이 설정해주었다. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> uuid <span class=\"token keyword\">import</span> uuid4\n<span class=\"token keyword\">from</span> asyncpg <span class=\"token keyword\">import</span> Connection\n\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>생략<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CConnection</span><span class=\"token punctuation\">(</span>Connection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">_get_unique_id</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        캐싱을 만들 시에 캐싱 아이디가 중복으로 생성되어서 오류가 발생하는 경우가 있다.\n        statement_cache_size를 0으로 해도 일단 캐싱을 만들고 오류를 낸다.\n        따라서 캐싱을 사용하지 않을 것이므로, 아예 중복되지 않게 UUID로 생성해버린다.\n        \"\"\"</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string-interpolation\"><span class=\"token string\">f'__asyncpg_</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>prefix<span class=\"token punctuation\">}</span></span><span class=\"token string\">_</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>uuid4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">__'</span></span>\n\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>생략<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\nDATABASE_URL <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"postgresql+asyncpg://postgres.[Project ID]:[Password]@aws-0-[Region].pooler.supabase.com:6543/postgres?prepared_statement_cache_size=0\"</span></span>\n    _db_connection <span class=\"token operator\">=</span> create_async_engine<span class=\"token punctuation\">(</span>\n        DATABASE_URL<span class=\"token punctuation\">,</span>\n        connect_args<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"statement_cache_size\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">'connection_class'</span><span class=\"token punctuation\">:</span> CConnection<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span></code></pre></div>\n<h3>결말 &#x26; 에필로그</h3>\n<p>지난번 기나긴 고생과 삽질을 통해서 챗지피티에 대한 신뢰를 덜고 공식문서를 신뢰해야 한다는 사실을 깨달았다. </p>\n<p>그리고 이번 짧은(반나절 정도) 삽질을 통해서 공식문서도 100% 정답은 아니라는 사실을 깨달았다. (나는 무엇을 믿어야 할까?)</p>\n<p>생각해보면, Database url 에다가 옵션을 넣는다고 해서 내부적으로 뭔가 변경되는 것일리가 없다. 결국 엔진을 만들 때에 옵션값을 넣어줘야 내부적으로 뭔가 알고 다른 작동을 하지 않을까? 이 생각을 막바지에 와서 떠올렸다. </p>\n<p>항상 시야를 넓게 하고, 의심하면서 만들어야 한다는 것을 다시 한 번 깨달았다. 남들이 시키는대로 해서는 되는것이 없는 것이다. </p>\n<p>별개로, 내가 잘못을 한 것인지 뭔지 Sqlalchemy도 FastAPI도 Postgresql도 모두 유명한 것들인데 어째서 이렇게까지 불완전하게 작동하는지 의문이 든다. 역사가 길진 않지만 그래도 수년의 시간은 지난 것들인데, 가장 기본적인 부분이 이렇게 불안정할지는 예상을 못했다. FastAPI의 메모리 누수 문제도 뒤늦게 알게 되었는데, 메모리 누수 문제에 이어서 비동기 엔진에서의 DB Pooler 연결에 이렇게 문제가 있을 줄 알았다면 FastAPI와 SqlAlchemy를 절대 선택하지 않았을 것 같다. </p>\n<p>고찰, 의심, 경험.. 등등이 중요하다고 다시 한 번 느꼈다. </p>","frontmatter":{"title":"Sqlalchemy 비동기 엔진에서의 Postgresql Pooler","date":"January 09, 2024","update":"February 02, 2024","tags":["DataBase","SqlAlchemy","Python","Work"],"series":null},"fields":{"slug":"/Sqlalchemy-비동기-엔진에서의-Postgresql-Pooler/","readingTime":{"minutes":13.72}}},"seriesList":{"edges":[{"node":{"id":"b1fa34d8-79a6-5920-b77c-fbf3bc57100b","fields":{"slug":"/화상상담을-위한-Janus-구성/"},"frontmatter":{"title":"화상상담을 위한 Janus 구성"}}},{"node":{"id":"36ed6446-4d80-5d51-87fe-7cbb02582980","fields":{"slug":"/JavaScript의-특징-브라우저-동작-원리/"},"frontmatter":{"title":"JavaScript의 특징, 브라우저 동작 원리"}}},{"node":{"id":"1890a1d7-34c1-53bd-a8bd-9bdfd39e91c3","fields":{"slug":"/JavaScript-기본-문법/"},"frontmatter":{"title":"JavaScript 기본 문법"}}},{"node":{"id":"61ba989b-e166-5573-a895-1f71aa176358","fields":{"slug":"/JavaScript의-변수/"},"frontmatter":{"title":"JavaScript의 변수"}}},{"node":{"id":"09afa1c5-5d39-532c-8dbb-5ba9e4af5b42","fields":{"slug":"/JavaScript의-타입-변환과-단축-평가/"},"frontmatter":{"title":"JavaScript의 타입 변환과 단축 평가"}}},{"node":{"id":"a81f1c25-10c3-52c4-8594-54806409ea15","fields":{"slug":"/JavaScript-클로저/"},"frontmatter":{"title":"JavaScript 클로저"}}},{"node":{"id":"6f1a58a9-6d27-5238-a531-618fc2d38f6a","fields":{"slug":"/NestJS-소개/"},"frontmatter":{"title":"NestJS 소개"}}},{"node":{"id":"6a1bda4f-ebe2-5b4f-980e-0484f92834f9","fields":{"slug":"/MORETHAN-LOG-설치/"},"frontmatter":{"title":"MORETHAN-LOG 설치"}}},{"node":{"id":"b1b9709f-6909-592c-b003-7ff67d3ca0fe","fields":{"slug":"/DB-튜닝-경험/"},"frontmatter":{"title":"DB 튜닝 경험"}}},{"node":{"id":"192dff3e-aa73-5307-a245-65393ab4e1d9","fields":{"slug":"/RDB관계형-데이터베이스-RDBMS/"},"frontmatter":{"title":"RDB(관계형 데이터베이스) + RDBMS"}}},{"node":{"id":"7ac316a8-f6ea-52cc-a790-b5be80f2bec7","fields":{"slug":"/var와-letconst/"},"frontmatter":{"title":"var와 let,const"}}},{"node":{"id":"e86672d9-847c-55f9-a249-42b4d896508f","fields":{"slug":"/MORETHAN-LOG-수정/"},"frontmatter":{"title":"MORETHAN-LOG 수정"}}},{"node":{"id":"6a5ef575-d133-5b56-b0b6-4db4af7aa70d","fields":{"slug":"/NestJS-설치/"},"frontmatter":{"title":"NestJS 설치"}}},{"node":{"id":"c9c69060-c0a8-5657-b744-46feb11aa3bd","fields":{"slug":"/NestJS의-디렉토리-구조/"},"frontmatter":{"title":"NestJS의 디렉토리 구조"}}},{"node":{"id":"6c0e93ce-fab2-5cd8-b369-8c7e35114bd4","fields":{"slug":"/웹-사이트-프로젝트-vs-웹-응용-프로그램-프로젝트/"},"frontmatter":{"title":"웹 사이트 프로젝트 vs 웹 응용 프로그램 프로젝트"}}},{"node":{"id":"0747e4e2-4d9c-5f2e-9ad4-db4690dc2756","fields":{"slug":"/무료-웹-호스팅-비교/"},"frontmatter":{"title":"무료 웹 호스팅 비교"}}},{"node":{"id":"e6017a82-883c-5533-b084-e4d128fba3f5","fields":{"slug":"/Nuget-패키지-dll-추출/"},"frontmatter":{"title":"Nuget 패키지 dll 추출"}}},{"node":{"id":"73f61a9c-4b13-5f3c-b288-9f971499e1c9","fields":{"slug":"/print와-pprint/"},"frontmatter":{"title":"print와 pprint"}}},{"node":{"id":"42d9a8c0-c330-548e-a36c-c8b97811df23","fields":{"slug":"/정규화와-역정규화/"},"frontmatter":{"title":"정규화와 역정규화"}}},{"node":{"id":"8bcc825c-89ec-552c-9144-ac6b2afced1e","fields":{"slug":"/트래픽-튜닝/"},"frontmatter":{"title":"트래픽 튜닝"}}},{"node":{"id":"dec52422-f02f-5520-bfe2-d277ddc7a455","fields":{"slug":"/PRG-패턴-PostRedirectGet/"},"frontmatter":{"title":"PRG 패턴 (Post/Redirect/Get)"}}},{"node":{"id":"ef3f3ed5-f90e-552f-8c1a-f24d1eeb0573","fields":{"slug":"/Python-venv-Windows/"},"frontmatter":{"title":"Python venv (Windows)"}}},{"node":{"id":"1f906753-4b2c-58e9-8b1d-65dbacd5a5ed","fields":{"slug":"/npx/"},"frontmatter":{"title":"npx"}}},{"node":{"id":"90f8d06a-0a5c-5fa2-bcb7-7ac1b4fccbdc","fields":{"slug":"/Branch/"},"frontmatter":{"title":"Branch"}}},{"node":{"id":"3e072448-1152-518b-89a4-0154bf7ed441","fields":{"slug":"/DataTable-클래스/"},"frontmatter":{"title":"DataTable 클래스"}}},{"node":{"id":"825a1946-8a6a-559a-9e11-93447cdedcdf","fields":{"slug":"/gitignore/"},"frontmatter":{"title":"gitignore"}}},{"node":{"id":"4e96b425-fd44-57b0-a26c-205a2db9f3f9","fields":{"slug":"/Typescript-시작하기/"},"frontmatter":{"title":"Typescript 시작하기"}}},{"node":{"id":"ee0abcf0-eb6f-569e-a2df-26ef807ffd53","fields":{"slug":"/네이밍-규칙naming-conventions/"},"frontmatter":{"title":"네이밍 규칙(naming conventions)"}}},{"node":{"id":"c65d18a5-967b-591b-a184-2f380d3f7847","fields":{"slug":"/Factory-Pattern/"},"frontmatter":{"title":"Factory Pattern"}}},{"node":{"id":"b3e00fd2-84a2-5bbc-8976-a76d7948ba15","fields":{"slug":"/AWS-API-Gateway/"},"frontmatter":{"title":"AWS API Gateway"}}},{"node":{"id":"c1d28daf-f0b4-521c-926c-88c14a61a609","fields":{"slug":"/ColdStart/"},"frontmatter":{"title":"ColdStart"}}},{"node":{"id":"45a48b17-f235-5fcf-90c4-f186e96b788e","fields":{"slug":"/Serverless/"},"frontmatter":{"title":"Serverless"}}},{"node":{"id":"59b56ebf-8c53-5362-82a7-3deb113c9308","fields":{"slug":"/Dynamo-DB/"},"frontmatter":{"title":"Dynamo DB"}}},{"node":{"id":"b1e5d38b-5dfb-5406-a693-d18281ac16f8","fields":{"slug":"/NoSQL/"},"frontmatter":{"title":"NoSQL"}}},{"node":{"id":"97236b20-03d7-59be-b021-0cf4f12ba08f","fields":{"slug":"/REST/"},"frontmatter":{"title":"REST"}}},{"node":{"id":"67555ff4-c43d-50d6-91fc-7db62ae5324a","fields":{"slug":"/TypeError-non-default-argument-content-follows-default-argument/"},"frontmatter":{"title":"TypeError: non-default argument 'content' follows default argument"}}},{"node":{"id":"247e0d6c-cb1f-523b-a365-12fbdf26de54","fields":{"slug":"/브랜치-관리-전략/"},"frontmatter":{"title":"브랜치 관리 전략"}}},{"node":{"id":"8fc059ee-a057-5299-9416-e5fe9a21f3b5","fields":{"slug":"/__post_init__/"},"frontmatter":{"title":"__post_init__"}}},{"node":{"id":"facbb85b-b3b0-54f1-b2ac-5593cedf9d02","fields":{"slug":"/dataclass/"},"frontmatter":{"title":"dataclass"}}},{"node":{"id":"fd68eada-5e64-5d6e-ad3e-e7cccc28c242","fields":{"slug":"/Unit-Test단위-테스트/"},"frontmatter":{"title":"Unit Test(단위 테스트)"}}},{"node":{"id":"f517cf21-d25d-5ad1-90b2-7cd04bdc1de5","fields":{"slug":"/FastAPI와-DDD/"},"frontmatter":{"title":"FastAPI와 DDD"}}},{"node":{"id":"c76d3263-2674-5711-9753-c7b1884886a2","fields":{"slug":"/vercel-배포-자동화/"},"frontmatter":{"title":"vercel 배포 자동화"}}},{"node":{"id":"643a5e74-e453-5eaf-be99-4fe90007fc0d","fields":{"slug":"/AWS-ECSElastic-Container-Service/"},"frontmatter":{"title":"AWS ECS(Elastic Container Service)"}}},{"node":{"id":"295a3a5e-5f68-53dd-a096-99c650a09f85","fields":{"slug":"/Blue-Green-Deploy-전략/"},"frontmatter":{"title":"Blue Green Deploy 전략"}}},{"node":{"id":"ef099c50-5b09-5374-b773-1646367f1a07","fields":{"slug":"/CloudFront/"},"frontmatter":{"title":"CloudFront"}}},{"node":{"id":"f2c13448-7669-5227-8e74-c0db79f8efa6","fields":{"slug":"/Poetry/"},"frontmatter":{"title":"Poetry"}}},{"node":{"id":"327528cd-aa5a-5ecb-9d02-1747c311b92a","fields":{"slug":"/DynamoDB의-동시성-제어Concurrency-Control/"},"frontmatter":{"title":"DynamoDB의 동시성 제어(Concurrency Control)"}}},{"node":{"id":"c61f89ee-7345-5822-a5bb-1ee417382592","fields":{"slug":"/FastAPI/"},"frontmatter":{"title":"FastAPI"}}},{"node":{"id":"6fde18dc-7c77-5d99-8142-13ade8537ae3","fields":{"slug":"/Pydantic-모델/"},"frontmatter":{"title":"Pydantic 모델"}}},{"node":{"id":"9b37002b-b912-5345-b81b-46951cc4a970","fields":{"slug":"/생성기generate-패턴/"},"frontmatter":{"title":"생성기(generate) 패턴"}}},{"node":{"id":"f97d2d57-9678-56e0-a700-2bd7ef00aca3","fields":{"slug":"/FastAPI의-데코레이터/"},"frontmatter":{"title":"FastAPI의 데코레이터"}}},{"node":{"id":"483a498b-b542-5587-989a-52dab4c1214c","fields":{"slug":"/FastAPI에서-데코레이터와-Dependency/"},"frontmatter":{"title":"FastAPI에서 데코레이터와 Dependency"}}},{"node":{"id":"80de20ad-d374-517c-ac92-d2877e4c06a8","fields":{"slug":"/FastAPI와-asyncio/"},"frontmatter":{"title":"FastAPI와 asyncio"}}},{"node":{"id":"87a218c9-82b0-5f05-90fa-a0d9da888853","fields":{"slug":"/aiohttp/"},"frontmatter":{"title":"aiohttp"}}},{"node":{"id":"222a8a91-8da9-500a-9074-4dd115cbe21f","fields":{"slug":"/단축어로-SLACK-프로필-변경하기/"},"frontmatter":{"title":"단축어로 SLACK 프로필 변경하기"}}},{"node":{"id":"75fcb75f-0a52-533f-a038-0a8460398f25","fields":{"slug":"/PynamoDB와-boto3-PynamoDB의-커넥션/"},"frontmatter":{"title":"PynamoDB와 boto3, PynamoDB의 커넥션"}}},{"node":{"id":"f15732ca-1b29-5230-aa8f-d32fd8ce5769","fields":{"slug":"/FastAPI에서-Postgresql의-커넥션-관리/"},"frontmatter":{"title":"FastAPI에서 Postgresql의 커넥션 관리"}}},{"node":{"id":"e0b43964-5998-5379-becc-614d8c62f076","fields":{"slug":"/Sqlalchemy-비동기-엔진에서의-Postgresql-Pooler/"},"frontmatter":{"title":"Sqlalchemy 비동기 엔진에서의 Postgresql Pooler"}}},{"node":{"id":"ef31575e-f174-58f7-84b7-832d38e952f9","fields":{"slug":"/FastAPI의-Pagenation/"},"frontmatter":{"title":"FastAPI의 Pagenation"}}},{"node":{"id":"c661de9c-fcb1-5bc6-b987-28d7cd303acb","fields":{"slug":"/SqlAlchemy의-QueuePool/"},"frontmatter":{"title":"SqlAlchemy의 QueuePool"}}},{"node":{"id":"7591133a-cdeb-5c9a-ab49-4ca7c8f3dea7","fields":{"slug":"/Pydantic-Model의-응용/"},"frontmatter":{"title":"Pydantic Model의 응용"}}},{"node":{"id":"c2c531ea-1018-5ad8-87b3-c1c027e8f2ee","fields":{"slug":"/우분투-용량-관리/"},"frontmatter":{"title":"우분투 용량 관리"}}},{"node":{"id":"cf792859-1afc-5118-bf50-0752527a6569","fields":{"slug":"/Union-Type/"},"frontmatter":{"title":"Union Type"}}},{"node":{"id":"ee1bfa9e-9eeb-52a2-a33a-88916dcc9119","fields":{"slug":"/트랜잭션-격리-수준Transaction-Isolation-Level/"},"frontmatter":{"title":"트랜잭션 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"ccff0278-8778-54c6-a28a-ffad6d97612d","fields":{"slug":"/Sqlalchemy에서의-트랜잭션-격리-수준-구현/"},"frontmatter":{"title":"Sqlalchemy에서의 트랜잭션 격리 수준 구현"}}},{"node":{"id":"8221080c-9128-57cc-b79e-c8a9e7959a90","fields":{"slug":"/동시성-제어문제-해결/"},"frontmatter":{"title":"동시성 제어문제 해결"}}},{"node":{"id":"a7292f80-7079-5082-9645-3def2d6750b8","fields":{"slug":"/PostgreSQL-Advisory-Locks-트랜잭션-레벨에서-구현/"},"frontmatter":{"title":"PostgreSQL Advisory Locks 트랜잭션 레벨에서 구현"}}},{"node":{"id":"acd438b5-e05c-5772-9da1-3ea3a67cefe0","fields":{"slug":"/Sqlalchemy의-func/"},"frontmatter":{"title":"Sqlalchemy의 func"}}},{"node":{"id":"4e23a734-8707-55b2-824e-d120641e8f1a","fields":{"slug":"/vscode-quick-Suggestions/"},"frontmatter":{"title":"vscode-quick Suggestions"}}},{"node":{"id":"1f589451-3bb6-501a-a892-6492654e760c","fields":{"slug":"/Typescript의-열거형/"},"frontmatter":{"title":"Typescript의 열거형"}}},{"node":{"id":"72e50b04-cb8a-55a6-b4ac-636d3dce4b78","fields":{"slug":"/Github-Actions-Workflow-수동으로-실행하기/"},"frontmatter":{"title":"Github Actions Workflow 수동으로 실행하기"}}},{"node":{"id":"a5babc02-b843-5c39-85e7-1b34cce43cdd","fields":{"slug":"/Github-Action-Output/"},"frontmatter":{"title":"Github Action Output"}}},{"node":{"id":"8b1f5d89-c5ae-52b6-b3c7-19a8d6afda7a","fields":{"slug":"/Github-Actions/"},"frontmatter":{"title":"Github Actions"}}},{"node":{"id":"b81485d3-7cab-52c0-adf9-f489724dc88f","fields":{"slug":"/Github-Actions-Job---needs/"},"frontmatter":{"title":"Github Actions Job - needs"}}},{"node":{"id":"2b53a4ed-50b1-5166-bde5-00f56edc9436","fields":{"slug":"/Typescript의-Testcode-맛보기/"},"frontmatter":{"title":"Typescript의 Testcode 맛보기"}}},{"node":{"id":"dbdceb4a-2ed6-5dbc-aa20-7dc961d63f54","fields":{"slug":"/시맨틱-버전-관리/"},"frontmatter":{"title":"시맨틱 버전 관리"}}},{"node":{"id":"6e6deb6d-e36d-5d2f-b11a-55fbc674c2ea","fields":{"slug":"/SQLAlchemy-create_all-메소드로-데이터베이스-테이블-자동-생성하기/"},"frontmatter":{"title":"SQLAlchemy create_all() 메소드로 데이터베이스 테이블 자동 생성하기"}}},{"node":{"id":"2de5adbd-b426-5f30-8811-ebd7fc04ff66","fields":{"slug":"/위치-기반-검색-기능의-구현/"},"frontmatter":{"title":"위치 기반 검색 기능의 구현"}}},{"node":{"id":"dd65c1da-59ff-5d58-a092-3ecc81bdb4fd","fields":{"slug":"/Sqlalchemy의-index/"},"frontmatter":{"title":"Sqlalchemy의 index"}}},{"node":{"id":"50b9db01-3888-5f30-80bc-b2d8ffd25486","fields":{"slug":"/인앱결제에서-백엔드는-무엇을-준비해야-할까/"},"frontmatter":{"title":"인앱결제에서 백엔드는 무엇을 준비해야 할까?"}}},{"node":{"id":"bb95007b-56db-5930-a9b8-4c09e2e118c4","fields":{"slug":"/식별-관계와-비식별-관계-그리고-CASCADE-옵션의-이해/"},"frontmatter":{"title":"식별 관계와 비식별 관계, 그리고 CASCADE 옵션의 이해"}}},{"node":{"id":"f76f95c7-1554-5431-a30b-7d03c93ac41c","fields":{"slug":"/arc-browser/"},"frontmatter":{"title":"arc browser"}}},{"node":{"id":"ae4611cf-ac19-58f9-be47-e8452f25a2df","fields":{"slug":"/Apple-Silicon과-pyenv/"},"frontmatter":{"title":"Apple Silicon과 pyenv"}}},{"node":{"id":"fe32f546-1476-5dc1-99f4-355cd81fba19","fields":{"slug":"/FastAPI-프로젝트의-시작/"},"frontmatter":{"title":"FastAPI 프로젝트의 시작"}}}]},"previous":{"fields":{"slug":"/FastAPI에서-Postgresql의-커넥션-관리/"},"frontmatter":{"title":"FastAPI에서 Postgresql의 커넥션 관리"}},"next":{"fields":{"slug":"/FastAPI의-Pagenation/"},"frontmatter":{"title":"FastAPI의 Pagenation"}}},"pageContext":{"id":"e0b43964-5998-5379-becc-614d8c62f076","series":null,"previousPostId":"f15732ca-1b29-5230-aa8f-d32fd8ce5769","nextPostId":"ef31575e-f174-58f7-84b7-832d38e952f9"}},"staticQueryHashes":[],"slicesMap":{}}