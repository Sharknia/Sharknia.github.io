{"componentChunkName":"component---src-templates-post-jsx","path":"/분산된-모놀리스를-위한-관리자-페이지-시스템-설계-제안/","result":{"data":{"site":{"siteMetadata":{"title":"SharkniA"}},"markdownRemark":{"id":"66a11a51-172b-502d-8746-39ce9aaf0028","excerpt":"서론 9개의 GraphQL 엔드포인트와 하나의 거대한 문제 7년차 백엔드 개발자로서 다양한 시스템의 아키텍처를 설계하고 개선하는 경험을 해왔습니다. 그중에서도 현재 마주한 통합 어드민 시스템은 기술적으로 가장 흥미로우면서도 복잡한 도전 과제였습니다. 시스템의 첫인상은 '현대적인 기술의 집합체'였습니다. Django 3.2, GraphQL, 마이크로서비스 …","html":"<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/87ce301acb2339fbc1acac1546e80c47/e8464/image1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 66.47058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACsUlEQVR42mPgUHPnUPcAIk4g0vBkUXZlVXbl0vRklnFgVXDiVHNnV3FlU3EDkcounGogBhBxqLoBEQNEJ0Qzi4qbnEWwrEUQg6hNXHaphU8Cg4wDr4YHh5obv5bnjNlT9+9ZvWjxLGE9HzZlV6BBDFA71T24tbwY5Jx843LyK2uFNVxDU/IljPyBts2ZP33u/Olihr5bNi3es3350f1r5cyDmBWdgY4CanZnV3VlUXRikXdgV3RkkHbQNvR8VBjo4ejPqOwuqON18vD6E4fWSxj5bd20ZOWKOYf2rlKyDGZSAGtmV3XjNw5R9s/TCCmRdk0TMwlKzSkOsXU3dQqramlVtQk7uHfNueObgc5euGjGof3r5y1awKvpy6oE8j8Du7KLd9XkxLnbwiatiZ+91SOrLjwpl13Lh1XFVdUmRNTAJzgpNyaziFXZhVnJTdnMLT7KwdrVGRgKoAAD+sqntKts2dbixZvKl2/V9c9mEDQ/sGlKWn7hnBltRRWlDc1V/T21DJKOMoauW/ttHiwzPzfLzNDOmUHBHaTZt7wndfLS6I7ZWTNXGYbkMcraOYUmq9mHm3pEadiHGnrGmnrGMCs48+n58Ol4C4cVSCaVcanDbA6sngC0OWf26rLl2wxC8xll7NhUPNnVvdiUgZHkxabmxarsDvQdj0GghFuqfHKVUm4Tj74/O9DPrErOKq5JvmXdAZV9rjnNIkZBQOOAQcij68drEMhrEMCjH8BrGATSrOXl3DEtet22wFlLJexjgMoYgF5nlndkkLFjApLStmxKzsA45zOP4jUK4TUN5zUO5TUJAyKgI4EJC5gExWyj+Az9QYlMw5MBKAqMMS5gOoGQ4HTHCUpz7uDE4w5BHGqgxAtMUcC0BXQwpyaIzQBJpQQQ0CwNcBLWACEQG5gj1NwBeuvL+jV4qw8AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image1' title='' src='/static/87ce301acb2339fbc1acac1546e80c47/ca1dc/image1.png' srcset='/static/87ce301acb2339fbc1acac1546e80c47/e7570/image1.png 170w,\n/static/87ce301acb2339fbc1acac1546e80c47/f46e7/image1.png 340w,\n/static/87ce301acb2339fbc1acac1546e80c47/ca1dc/image1.png 680w,\n/static/87ce301acb2339fbc1acac1546e80c47/02d09/image1.png 1020w,\n/static/87ce301acb2339fbc1acac1546e80c47/9d567/image1.png 1360w,\n/static/87ce301acb2339fbc1acac1546e80c47/e8464/image1.png 1536w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>서론</h2>\n<h4>9개의 GraphQL 엔드포인트와 하나의 거대한 문제</h4>\n<p>7년차 백엔드 개발자로서 다양한 시스템의 아키텍처를 설계하고 개선하는 경험을 해왔습니다. 그중에서도 현재 마주한 통합 어드민 시스템은 기술적으로 가장 흥미로우면서도 복잡한 도전 과제였습니다. 시스템의 첫인상은 '현대적인 기술의 집합체'였습니다. Django 3.2, GraphQL, 마이크로서비스 아키텍처(MSA) 등 최신 기술 스택이 적용되어 있었기 때문입니다. 하지만 자세히 들여다본 시스템의 실체는, 현대적인 이름표를 단 '분산된 모놀리스(Distributed Monolith)'에 가까웠습니다.</p>\n<p>시스템은 총 9개의 마이크로서비스로 구성되어 있었고, 각 서비스는 독립적인 GraphQL 엔드포인트를 외부에 노출하고 있었습니다. 이는 프론트엔드 개발에 심각한 병목을 유발했습니다. 예를 들어, '계약 상세 조회' 화면 하나를 렌더링하기 위해 프론트엔드는 계약 정보를 얻기 위해 A 서버에, 계약자의 계좌 정보를 얻기 위해 B 서버에, 해당 계약의 정산 내역을 확인하기 위해 C 서버에 각각 API를 호출해야 했습니다. 이렇게 여러 엔드포인트에서 가져온 데이터를 조합하고, 비즈니스 로직에 맞춰 가공하는 책임이 온전히 프론트엔드에 전가되어 있었습니다.</p>\n<p>설상가상으로 통합 어드민 서버는 각 서비스의 데이터베이스를 직접 읽어오는 구조를 가지고 있었습니다. 서비스 간의 결합도는 기술적으로 허용 가능한 수준을 넘어섰고, 프론트엔드 팀의 리소스 부족이라는 현실적인 제약과 맞물려 이 복잡한 시스템은 사실상 유지보수가 불가능한 기술 부채의 집합체가 되어가고 있었습니다.</p>\n<p>게다가 미완성인 시스템에 대해 사내에서는 끊임없이 해당 시스템에 대한 고도화를 요구해왔습니다. 필요성은 인지를 하면서도 니즈를 맞춰주기에는 도저히 불가능한 상황이었습니다. </p>\n<p>이 글은 이 총체적 난국 속에서 어떻게 문제의 본질을 체계적으로 분석하고, 현실적인 제약과 기술적인 이상 사이에서 최적의 해답을 찾아 아키텍처를 개선해야 할지를 설계하는 과정의 기록입니다.</p>\n<h2>문제 분석: 현상(What)이 아닌 본질(Why)에 집중하다</h2>\n<p>복잡한 시스템의 개선 작업을 시작할 때 가장 경계해야 할 것은, \"GraphQL이 문제다\" 또는 \"프론트엔드 구현이 복잡하다\"와 같이 눈에 보이는 현상에만 매몰되는 것입니다. 대신, \"왜 이런 구조가 탄생했으며, 이 구조가 야기하는 가장 근본적인 문제는 무엇인가?\"라는 본질적인 'Why'에 집중했습니다.</p>\n<p>체계적인 분석 끝에, 제가 정의한 핵심 문제는 다음과 같았습니다.</p>\n<ul>\n<li>잘못된 책임 분배: 데이터의 조합, 가공, 연산은 본질적으로 백엔드가 수행해야 할 책임입니다. 하지만 현재 구조는 이 책임을 프론트엔드로 떠넘기고 있었습니다. 이는 프론트엔드 코드의 비대화, 백엔드 로직의 중복 구현, 그리고 클라이언트 성능 저하라는 다각적인 문제로 이어졌습니다.</li>\n<li>깨진 캡슐화: 게이트웨이가 MSA의 DB를 직접 조회하는 것은, 각 서비스가 자신의 데이터에 대한 주권을 가지고 API를 통해서만 외부에 상태를 노출해야 한다는 MSA의 제1원칙을 위배하는 심각한 안티패턴입니다. </li>\n<li>유지보수의 비효율성: 하위 MSA의 스키마 변경이 발생하면, 게이트웨이에 존재하는 수많은 GraphQL 관련 코드를 모두 수동으로 찾아 수정해야 했습니다. 이러한 비효율적인 동기화 프로세스는 인적 오류(Human Error)의 가능성을 높였고, 프론트엔드 리소스의 부재라는 현실과 맞물려 시스템 개선을 불가능하게 만드는 가장 큰 장애물이었습니다.</li>\n</ul>\n<p>결론적으로, 이 시스템이 가진 진짜 문제는 특정 기술 스택의 단점이 아니라, '아키텍처 설계 원칙의 근본적인 실패' 에 있었습니다.</p>\n<h2>해결 방법 모색: 현실적 제약 속에서 최적의 경로 찾기</h2>\n<p>문제의 근원을 파악한 뒤, 실질적인 해결책을 모색하기 시작했습니다. 처음에는 이상적인 아키텍처들을 먼저 구상했습니다.</p>\n<ul>\n<li>아이디어 1: GraphQL Federation 도입: Apollo Federation과 같은 기술을 도입하여 9개의 분산된 스키마를 논리적인 하나의 통합 스키마(Super-graph)로 묶는 방식입니다. 이는 GraphQL의 장점을 극대화할 수 있는 정석적인 해결책입니다.</li>\n<li>아이디어 2: gRPC로 내부 통신 전환: MSA 간의 내부 통신을 고성능의 바이너리 프로토콜인 gRPC로 전환하여 성능을 최적화하고, Protobuf를 통해 명확한 API 계약을 강제하는 방식입니다.</li>\n</ul>\n<p>하지만 두 아이디어 모두 \"모든 하위 MSA의 코드를 수정하고, 각 서버에 대해 추가적인 개발 공수를 요구한다\"는 치명적인 현실적 제약을 가지고 있었습니다. 현재의 리소스 상황을 고려했을 때, 전면적인 개편은 불가능했습니다. 또한, MSA중 일부 서버는 Django 1.11등 지나치게 오래된 레거시 코드로 이루어져 있어 더더욱 요구되는 개발 공수가 컸습니다.</p>\n<p>이때부터 저의 고민은 '가장 이상적인 방법은 무엇인가?'에서 '지금 우리가 가진 자원으로, 가장 큰 고통을 유발하는 문제를 해결할 수 있는 현실적인 방법은 무엇인가?' 로 전환되었습니다. 따라서 저는 가장 문제가 복잡하고 성능에 영향을 미치는 조회(Read) 기능에 집중하기로 했습니다.</p>\n<p>그래서 내린 첫 번째 전략적 결론은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    \"CUD(생성/수정/삭제)는 현행 방식을 유지하고, 복잡한 조회(Read) 기능부터 점진적으로 개선하자.\"</code></pre></div>\n<p>이 결정에 따라, 기존 GraphQL 엔드포인트들은 레거시 시스템으로 유지하되, 추가되는 페이지에 대해서는 새로운 조회 기능을 위한 REST API를 신설하는 방향으로 가닥을 잡았습니다.</p>\n<h2>기술 스택 선정: N+1과 분산 Join이라는 두 가지 난관을 넘어서</h2>\n<p>REST API 기반의 BFF 게이트웨이를 구축하기로 결정하자, 곧바로 두 가지 거대한 기술적 난관에 부딪혔습니다. 이 문제들을 어떻게 해결할 것인지가 이번 프로젝트의 성패를 가르는 핵심이었습니다.\\</p>\n<h3>난관</h3>\n<h4><strong>1: N+1 문제</strong></h4>\n<p>하나의 리스트 화면을 조회하기 위해 여러 MSA를 순차적으로 호출하면, 아이템 개수(N)만큼 추가적인 네트워크 왕복이 발생합니다. 예를 들어 20개의 계약 리스트를 가져오고, 각 계약의 담당자 이름을 얻기 위해 20번의 추가 API 호출이 발생하는 상황입니다. 이는 과거 GraphQL 환경에서 <a href=\"https://sharknia.github.io/DataLoader%EC%9D%98-%EC%A0%81%EC%9A%A9\">DataLoader</a>가 해결해주던 문제였습니다.</p>\n<h4><strong>2: 분산 데이터에 대한 필터링 및 정렬</strong></h4>\n<p>A 서버의 데이터와 B 서버의 데이터를 조합하여 화면에 보여주는 것은 가능합니다. 하지만 B 서버에만 존재하는 '담당자 이름'으로 전체 계약 리스트를 검색하거나, '계약 금액'으로 정렬하는 기능은 어떻게 구현해야 할까요? 이는 단순한 API 호출로는 해결이 불가능한, 매우 어려운 문제입니다.</p>\n<h3><strong>단기 전략: DataLoader 패턴의 적용</strong></h3>\n<p>N+1 문제를 해결하기 위해, REST 환경에서도 GraphQL의 DataLoader와 동일한 원리의 패턴을 적용하기로 했습니다.</p>\n<ol>\n<li>먼저 주가 되는 데이터 리스트를 조회합니다.</li>\n<li>조회된 리스트에서 추가 정보가 필요한 ID들을 모두 수집합니다.</li>\n<li>수집된 ID 목록을 단일 파라미터로 하여, 하위 MSA에 배치(Batch) API를 단 한 번 호출합니다.</li>\n<li>가져온 추가 정보들을 Key-Value 형태의 맵(Map)으로 변환한 뒤, 메모리 상에서 원본 리스트와 조합합니다.\n이 방식은 하위 MSA에 'ID 목록으로 데이터를 조회하는 기능'만 추가하면 되므로, 가장 현실적인 초기 해결책이었습니다. 하지만 이 방식으로는 '분산 데이터에 대한 필터링/정렬' 문제는 해결할 수 없다는 명확한 한계를 인지하고 다음 단계의 전략을 준비해야 했습니다.</li>\n</ol>\n<h3><strong>장기 전략: Elasticsearch</strong></h3>\n<p>분산 데이터 Join 문제를 해결할 방법을 찾던 중, 문득 우리가 이미 로그 분석을 위해 사용하고 있던 Elasticsearch가 떠올랐습니다. Elasticsearch의 본질은 비정규화된(Denormalized) 문서에 대한 빠른 검색과 집계 기능입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    \"RDBMS에서 불가능한 조회 시점(Read-Time)의 분산 Join을, 데이터 저장 시점(Write-Time)에 미리 Join된 통합 문서를 Elasticsearch에 만들어두는 방식으로 해결할 수 있지 않을까?\"</code></pre></div>\n<p>이 아이디어가 문제 해결의 실마리였습니다. 각 MSA에서 데이터가 변경될 때마다, 이 데이터를 조합하여 Elasticsearch의 '통합 검색용 인덱스'에 저장해두는 것입니다. 그러면 게이트웨이는 어떤 복잡한 필터링/정렬 요청이 오더라도, 모든 정보가 미리 준비된 Elasticsearch에 단 한 번의 풍부한 쿼리(Rich Query)를 보내는 것으로 문제를 해결할 수 있습니다.</p>\n<p>데이터 동기화 방식으로는 Kafka나 RabbitMQ 같은 메세지 큐가 정답이겠지만, 새로운 메시징 인프라 도입의 부담을 줄이기 위해 기존에 사용하던 Jenkins 기반의 배치 서버(<code class=\"language-text\">Synchronizer</code>)를 활용한 '주기적인 배치 동기화' 를 초기 방식으로 제안했습니다. 이 방식은 실시간성은 다소 떨어지지만, 새로운 인프라 도입 없이 가장 빠르게 구현할 수 있는 매우 현실적인 선택이었습니다. 또한 이 서버는 유저를 위한 서버가 아니라 내부 관리자를 위한 서버이므로 리스크가 덜 한 점도 고려했습니다. </p>\n<p>하지만 더불어 내부 관리자를 위한 페이지이므로, ElasticSearch를 위한 데이터 저장에 드는 물리적인 비용, 개발 공수, 데이터 싱크를 위한 유지보수 포인트의 증가등도 도입전에 추가적으로 고려되어야 할 것입니다. </p>\n<h2>4. 최종 설계안: 현실과 타협하고 미래를 준비하는 아키텍처</h2>\n<p>기술적 고민과 트레이드오프를 거쳐, 다음과 같은 최종 설계안이 완성되었습니다.</p>\n<ol>\n<li>목표: 프론트엔드의 데이터 가공 부담을 '0'으로 만드는 BFF용 REST API 게이트웨이 구축</li>\n<li>범위: 복잡한 '조회' 기능에 집중하고, CUD는 현행 방식을 유지</li>\n<li>단기 전략: <code class=\"language-text\">DataLoader 패턴</code>을 적용하여 N+1 성능 문제 해결</li>\n<li>\n<p>장기 전략: <code class=\"language-text\">Elasticsearch</code>를 도입하여 분산 데이터의 복합적인 필터링/정렬 문제 해결</p>\n<ul>\n<li>데이터 동기화: 기존 배치 서버(<code class=\"language-text\">Synchronizer</code>)를 활용한 주기적 동기화로 시작, 장기적으로 Kafka 기반의 이벤트 드리븐 방식으로의 전환을 고려</li>\n</ul>\n</li>\n<li>아키텍처: View - Service - Infrastructure로 역할을 명확히 나눈 레이어드 아키텍처를 채택하여 테스트 용이성과 유지보수성 확보</li>\n</ol>\n<p>이 설계는 모든 문제를 해결하는 완벽한 정답지는 아닙니다. 하지만 현재 우리가 가진 문제, 리소스, 기술 스택을 모두 고려했을 때, '오늘 당장 실행할 수 있는 최선의 방안' 이자 '미래의 기술적 확장을 가로막지 않는 유연함' 을 모두 담고 있다고 확신합니다.</p>\n<h2>에필로그: 경험으로 얻은 교훈</h2>\n<p>저는 스스로를 '정석'보다는 경험을 통해 배우는 실전형 개발자에 가깝다고 생각합니다. 공식적인 용어보다는 저만의 언어로 문제를 정의하고, 이론보다는 몸으로 부딪히며 해결책을 찾아온 시간이 많았기 때문입니다.</p>\n<p>하지만 이번 프로젝트를 통해 다시 한번 깨달은 것은, 가장 중요한 것은 특정 용어나 정해진 정석이 아니라 '문제의 본질을 꿰뚫는 집요함' 과 '현실의 제약 속에서 최적의 길을 찾아내는 실용주의적 태도' 라는 점입니다. 기술은 결국 문제를 해결하기 위한 도구이며, 그 도구를 가장 적재적소에 사용하는 지혜는 치열한 경험 속에서 나온다고 믿습니다.</p>\n<p>이 글이 저와 비슷한 환경에서 복잡한 시스템의 기술 부채와 싸우고 있는 다른 개발자분들에게 작은 용기와 문제 해결의 영감이 되기를 바랍니다.</p>","frontmatter":{"title":"분산된 모놀리스를 위한 관리자 페이지 시스템 설계 제안","date":"June 17, 2025","update":"June 18, 2025","tags":["아키텍쳐","리팩토링","Django","MSA"],"series":null},"fields":{"slug":"/분산된-모놀리스를-위한-관리자-페이지-시스템-설계-제안/","readingTime":{"minutes":18.25}}},"seriesList":{"edges":[{"node":{"id":"b1fa34d8-79a6-5920-b77c-fbf3bc57100b","fields":{"slug":"/화상상담을-위한-Janus-구성/"},"frontmatter":{"title":"화상상담을 위한 Janus 구성"}}},{"node":{"id":"36ed6446-4d80-5d51-87fe-7cbb02582980","fields":{"slug":"/JavaScript의-특징-브라우저-동작-원리/"},"frontmatter":{"title":"JavaScript의 특징, 브라우저 동작 원리"}}},{"node":{"id":"1890a1d7-34c1-53bd-a8bd-9bdfd39e91c3","fields":{"slug":"/JavaScript-기본-문법/"},"frontmatter":{"title":"JavaScript 기본 문법"}}},{"node":{"id":"61ba989b-e166-5573-a895-1f71aa176358","fields":{"slug":"/JavaScript의-변수/"},"frontmatter":{"title":"JavaScript의 변수"}}},{"node":{"id":"09afa1c5-5d39-532c-8dbb-5ba9e4af5b42","fields":{"slug":"/JavaScript의-타입-변환과-단축-평가/"},"frontmatter":{"title":"JavaScript의 타입 변환과 단축 평가"}}},{"node":{"id":"a81f1c25-10c3-52c4-8594-54806409ea15","fields":{"slug":"/JavaScript-클로저/"},"frontmatter":{"title":"JavaScript 클로저"}}},{"node":{"id":"6f1a58a9-6d27-5238-a531-618fc2d38f6a","fields":{"slug":"/NestJS-소개/"},"frontmatter":{"title":"NestJS 소개"}}},{"node":{"id":"192dff3e-aa73-5307-a245-65393ab4e1d9","fields":{"slug":"/RDB관계형-데이터베이스-RDBMS/"},"frontmatter":{"title":"RDB(관계형 데이터베이스) + RDBMS"}}},{"node":{"id":"b1b9709f-6909-592c-b003-7ff67d3ca0fe","fields":{"slug":"/DB-튜닝-경험/"},"frontmatter":{"title":"DB 튜닝 경험"}}},{"node":{"id":"6a1bda4f-ebe2-5b4f-980e-0484f92834f9","fields":{"slug":"/MORETHAN-LOG-설치/"},"frontmatter":{"title":"MORETHAN-LOG 설치"}}},{"node":{"id":"7ac316a8-f6ea-52cc-a790-b5be80f2bec7","fields":{"slug":"/var와-letconst/"},"frontmatter":{"title":"var와 let,const"}}},{"node":{"id":"e86672d9-847c-55f9-a249-42b4d896508f","fields":{"slug":"/MORETHAN-LOG-수정/"},"frontmatter":{"title":"MORETHAN-LOG 수정"}}},{"node":{"id":"6a5ef575-d133-5b56-b0b6-4db4af7aa70d","fields":{"slug":"/NestJS-설치/"},"frontmatter":{"title":"NestJS 설치"}}},{"node":{"id":"c9c69060-c0a8-5657-b744-46feb11aa3bd","fields":{"slug":"/NestJS의-디렉토리-구조/"},"frontmatter":{"title":"NestJS의 디렉토리 구조"}}},{"node":{"id":"6c0e93ce-fab2-5cd8-b369-8c7e35114bd4","fields":{"slug":"/웹-사이트-프로젝트-vs-웹-응용-프로그램-프로젝트/"},"frontmatter":{"title":"웹 사이트 프로젝트 vs 웹 응용 프로그램 프로젝트"}}},{"node":{"id":"e6017a82-883c-5533-b084-e4d128fba3f5","fields":{"slug":"/Nuget-패키지-dll-추출/"},"frontmatter":{"title":"Nuget 패키지 dll 추출"}}},{"node":{"id":"0747e4e2-4d9c-5f2e-9ad4-db4690dc2756","fields":{"slug":"/무료-웹-호스팅-비교/"},"frontmatter":{"title":"무료 웹 호스팅 비교"}}},{"node":{"id":"73f61a9c-4b13-5f3c-b288-9f971499e1c9","fields":{"slug":"/print와-pprint/"},"frontmatter":{"title":"print와 pprint"}}},{"node":{"id":"dec52422-f02f-5520-bfe2-d277ddc7a455","fields":{"slug":"/PRG-패턴-PostRedirectGet/"},"frontmatter":{"title":"PRG 패턴 (Post/Redirect/Get)"}}},{"node":{"id":"ef3f3ed5-f90e-552f-8c1a-f24d1eeb0573","fields":{"slug":"/Python-venv-Windows/"},"frontmatter":{"title":"Python venv (Windows)"}}},{"node":{"id":"42d9a8c0-c330-548e-a36c-c8b97811df23","fields":{"slug":"/정규화와-역정규화/"},"frontmatter":{"title":"정규화와 역정규화"}}},{"node":{"id":"8bcc825c-89ec-552c-9144-ac6b2afced1e","fields":{"slug":"/트래픽-튜닝/"},"frontmatter":{"title":"트래픽 튜닝"}}},{"node":{"id":"1f906753-4b2c-58e9-8b1d-65dbacd5a5ed","fields":{"slug":"/npx/"},"frontmatter":{"title":"npx"}}},{"node":{"id":"90f8d06a-0a5c-5fa2-bcb7-7ac1b4fccbdc","fields":{"slug":"/Branch/"},"frontmatter":{"title":"Branch"}}},{"node":{"id":"3e072448-1152-518b-89a4-0154bf7ed441","fields":{"slug":"/DataTable-클래스/"},"frontmatter":{"title":"DataTable 클래스"}}},{"node":{"id":"825a1946-8a6a-559a-9e11-93447cdedcdf","fields":{"slug":"/gitignore/"},"frontmatter":{"title":"gitignore"}}},{"node":{"id":"4e96b425-fd44-57b0-a26c-205a2db9f3f9","fields":{"slug":"/Typescript-시작하기/"},"frontmatter":{"title":"Typescript 시작하기"}}},{"node":{"id":"c65d18a5-967b-591b-a184-2f380d3f7847","fields":{"slug":"/Factory-Pattern/"},"frontmatter":{"title":"Factory Pattern"}}},{"node":{"id":"ee0abcf0-eb6f-569e-a2df-26ef807ffd53","fields":{"slug":"/네이밍-규칙naming-conventions/"},"frontmatter":{"title":"네이밍 규칙(naming conventions)"}}},{"node":{"id":"45a48b17-f235-5fcf-90c4-f186e96b788e","fields":{"slug":"/Serverless/"},"frontmatter":{"title":"Serverless"}}},{"node":{"id":"b3e00fd2-84a2-5bbc-8976-a76d7948ba15","fields":{"slug":"/AWS-API-Gateway/"},"frontmatter":{"title":"AWS API Gateway"}}},{"node":{"id":"c1d28daf-f0b4-521c-926c-88c14a61a609","fields":{"slug":"/ColdStart/"},"frontmatter":{"title":"ColdStart"}}},{"node":{"id":"97236b20-03d7-59be-b021-0cf4f12ba08f","fields":{"slug":"/REST/"},"frontmatter":{"title":"REST"}}},{"node":{"id":"59b56ebf-8c53-5362-82a7-3deb113c9308","fields":{"slug":"/Dynamo-DB/"},"frontmatter":{"title":"Dynamo DB"}}},{"node":{"id":"b1e5d38b-5dfb-5406-a693-d18281ac16f8","fields":{"slug":"/NoSQL/"},"frontmatter":{"title":"NoSQL"}}},{"node":{"id":"67555ff4-c43d-50d6-91fc-7db62ae5324a","fields":{"slug":"/TypeError-non-default-argument-content-follows-default-argument/"},"frontmatter":{"title":"TypeError: non-default argument 'content' follows default argument"}}},{"node":{"id":"247e0d6c-cb1f-523b-a365-12fbdf26de54","fields":{"slug":"/브랜치-관리-전략/"},"frontmatter":{"title":"브랜치 관리 전략"}}},{"node":{"id":"8fc059ee-a057-5299-9416-e5fe9a21f3b5","fields":{"slug":"/__post_init__/"},"frontmatter":{"title":"__post_init__"}}},{"node":{"id":"facbb85b-b3b0-54f1-b2ac-5593cedf9d02","fields":{"slug":"/dataclass/"},"frontmatter":{"title":"dataclass"}}},{"node":{"id":"fd68eada-5e64-5d6e-ad3e-e7cccc28c242","fields":{"slug":"/Unit-Test단위-테스트/"},"frontmatter":{"title":"Unit Test(단위 테스트)"}}},{"node":{"id":"f517cf21-d25d-5ad1-90b2-7cd04bdc1de5","fields":{"slug":"/FastAPI와-DDD/"},"frontmatter":{"title":"FastAPI와 DDD"}}},{"node":{"id":"c76d3263-2674-5711-9753-c7b1884886a2","fields":{"slug":"/vercel-배포-자동화/"},"frontmatter":{"title":"vercel 배포 자동화"}}},{"node":{"id":"643a5e74-e453-5eaf-be99-4fe90007fc0d","fields":{"slug":"/AWS-ECSElastic-Container-Service/"},"frontmatter":{"title":"AWS ECS(Elastic Container Service)"}}},{"node":{"id":"295a3a5e-5f68-53dd-a096-99c650a09f85","fields":{"slug":"/Blue-Green-Deploy-전략/"},"frontmatter":{"title":"Blue Green Deploy 전략"}}},{"node":{"id":"ef099c50-5b09-5374-b773-1646367f1a07","fields":{"slug":"/CloudFront/"},"frontmatter":{"title":"CloudFront"}}},{"node":{"id":"f2c13448-7669-5227-8e74-c0db79f8efa6","fields":{"slug":"/Poetry/"},"frontmatter":{"title":"Poetry"}}},{"node":{"id":"327528cd-aa5a-5ecb-9d02-1747c311b92a","fields":{"slug":"/DynamoDB의-동시성-제어Concurrency-Control/"},"frontmatter":{"title":"DynamoDB의 동시성 제어(Concurrency Control)"}}},{"node":{"id":"6fde18dc-7c77-5d99-8142-13ade8537ae3","fields":{"slug":"/Pydantic-모델/"},"frontmatter":{"title":"Pydantic 모델"}}},{"node":{"id":"c61f89ee-7345-5822-a5bb-1ee417382592","fields":{"slug":"/FastAPI/"},"frontmatter":{"title":"FastAPI"}}},{"node":{"id":"f97d2d57-9678-56e0-a700-2bd7ef00aca3","fields":{"slug":"/FastAPI의-데코레이터/"},"frontmatter":{"title":"FastAPI의 데코레이터"}}},{"node":{"id":"9b37002b-b912-5345-b81b-46951cc4a970","fields":{"slug":"/생성기generate-패턴/"},"frontmatter":{"title":"생성기(generate) 패턴"}}},{"node":{"id":"483a498b-b542-5587-989a-52dab4c1214c","fields":{"slug":"/FastAPI에서-데코레이터와-Dependency/"},"frontmatter":{"title":"FastAPI에서 데코레이터와 Dependency"}}},{"node":{"id":"80de20ad-d374-517c-ac92-d2877e4c06a8","fields":{"slug":"/FastAPI와-asyncio/"},"frontmatter":{"title":"FastAPI와 asyncio"}}},{"node":{"id":"87a218c9-82b0-5f05-90fa-a0d9da888853","fields":{"slug":"/aiohttp/"},"frontmatter":{"title":"aiohttp"}}},{"node":{"id":"222a8a91-8da9-500a-9074-4dd115cbe21f","fields":{"slug":"/단축어로-SLACK-프로필-변경하기/"},"frontmatter":{"title":"단축어로 SLACK 프로필 변경하기"}}},{"node":{"id":"75fcb75f-0a52-533f-a038-0a8460398f25","fields":{"slug":"/PynamoDB와-boto3-PynamoDB의-커넥션/"},"frontmatter":{"title":"PynamoDB와 boto3, PynamoDB의 커넥션"}}},{"node":{"id":"f15732ca-1b29-5230-aa8f-d32fd8ce5769","fields":{"slug":"/FastAPI에서-Postgresql의-커넥션-관리/"},"frontmatter":{"title":"FastAPI에서 Postgresql의 커넥션 관리"}}},{"node":{"id":"e0b43964-5998-5379-becc-614d8c62f076","fields":{"slug":"/Sqlalchemy-비동기-엔진에서의-Postgresql-Pooler/"},"frontmatter":{"title":"Sqlalchemy 비동기 엔진에서의 Postgresql Pooler"}}},{"node":{"id":"ef31575e-f174-58f7-84b7-832d38e952f9","fields":{"slug":"/FastAPI의-Pagenation/"},"frontmatter":{"title":"FastAPI의 Pagenation"}}},{"node":{"id":"c661de9c-fcb1-5bc6-b987-28d7cd303acb","fields":{"slug":"/SqlAlchemy의-QueuePool/"},"frontmatter":{"title":"SqlAlchemy의 QueuePool"}}},{"node":{"id":"7591133a-cdeb-5c9a-ab49-4ca7c8f3dea7","fields":{"slug":"/Pydantic-Model의-응용/"},"frontmatter":{"title":"Pydantic Model의 응용"}}},{"node":{"id":"cf792859-1afc-5118-bf50-0752527a6569","fields":{"slug":"/Union-Type/"},"frontmatter":{"title":"Union Type"}}},{"node":{"id":"c2c531ea-1018-5ad8-87b3-c1c027e8f2ee","fields":{"slug":"/우분투-용량-관리/"},"frontmatter":{"title":"우분투 용량 관리"}}},{"node":{"id":"ccff0278-8778-54c6-a28a-ffad6d97612d","fields":{"slug":"/Sqlalchemy에서의-트랜잭션-격리-수준-구현/"},"frontmatter":{"title":"Sqlalchemy에서의 트랜잭션 격리 수준 구현"}}},{"node":{"id":"ee1bfa9e-9eeb-52a2-a33a-88916dcc9119","fields":{"slug":"/트랜잭션-격리-수준Transaction-Isolation-Level/"},"frontmatter":{"title":"트랜잭션 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"a7292f80-7079-5082-9645-3def2d6750b8","fields":{"slug":"/PostgreSQL-Advisory-Locks-트랜잭션-레벨에서-구현/"},"frontmatter":{"title":"PostgreSQL Advisory Locks 트랜잭션 레벨에서 구현"}}},{"node":{"id":"acd438b5-e05c-5772-9da1-3ea3a67cefe0","fields":{"slug":"/Sqlalchemy의-func/"},"frontmatter":{"title":"Sqlalchemy의 func"}}},{"node":{"id":"8221080c-9128-57cc-b79e-c8a9e7959a90","fields":{"slug":"/동시성-제어문제-해결/"},"frontmatter":{"title":"동시성 제어문제 해결"}}},{"node":{"id":"4e23a734-8707-55b2-824e-d120641e8f1a","fields":{"slug":"/vscode-quick-Suggestions/"},"frontmatter":{"title":"vscode-quick Suggestions"}}},{"node":{"id":"1f589451-3bb6-501a-a892-6492654e760c","fields":{"slug":"/Typescript의-열거형/"},"frontmatter":{"title":"Typescript의 열거형"}}},{"node":{"id":"a5babc02-b843-5c39-85e7-1b34cce43cdd","fields":{"slug":"/Github-Action-Output/"},"frontmatter":{"title":"Github Action Output"}}},{"node":{"id":"8b1f5d89-c5ae-52b6-b3c7-19a8d6afda7a","fields":{"slug":"/Github-Actions/"},"frontmatter":{"title":"Github Actions"}}},{"node":{"id":"b81485d3-7cab-52c0-adf9-f489724dc88f","fields":{"slug":"/Github-Actions-Job---needs/"},"frontmatter":{"title":"Github Actions Job - needs"}}},{"node":{"id":"72e50b04-cb8a-55a6-b4ac-636d3dce4b78","fields":{"slug":"/Github-Actions-Workflow-수동으로-실행하기/"},"frontmatter":{"title":"Github Actions Workflow 수동으로 실행하기"}}},{"node":{"id":"2b53a4ed-50b1-5166-bde5-00f56edc9436","fields":{"slug":"/Typescript의-Testcode-맛보기/"},"frontmatter":{"title":"Typescript의 Testcode 맛보기"}}},{"node":{"id":"dbdceb4a-2ed6-5dbc-aa20-7dc961d63f54","fields":{"slug":"/시맨틱-버전-관리/"},"frontmatter":{"title":"시맨틱 버전 관리"}}},{"node":{"id":"6e6deb6d-e36d-5d2f-b11a-55fbc674c2ea","fields":{"slug":"/SQLAlchemy-create_all-메소드로-데이터베이스-테이블-자동-생성하기/"},"frontmatter":{"title":"SQLAlchemy create_all() 메소드로 데이터베이스 테이블 자동 생성하기"}}},{"node":{"id":"dd65c1da-59ff-5d58-a092-3ecc81bdb4fd","fields":{"slug":"/Sqlalchemy의-index/"},"frontmatter":{"title":"Sqlalchemy의 index"}}},{"node":{"id":"2de5adbd-b426-5f30-8811-ebd7fc04ff66","fields":{"slug":"/위치-기반-검색-기능의-구현/"},"frontmatter":{"title":"위치 기반 검색 기능의 구현"}}},{"node":{"id":"50b9db01-3888-5f30-80bc-b2d8ffd25486","fields":{"slug":"/인앱결제에서-백엔드는-무엇을-준비해야-할까/"},"frontmatter":{"title":"인앱결제에서 백엔드는 무엇을 준비해야 할까?"}}},{"node":{"id":"bb95007b-56db-5930-a9b8-4c09e2e118c4","fields":{"slug":"/식별-관계와-비식별-관계-그리고-CASCADE-옵션의-이해/"},"frontmatter":{"title":"식별 관계와 비식별 관계, 그리고 CASCADE 옵션의 이해"}}},{"node":{"id":"f76f95c7-1554-5431-a30b-7d03c93ac41c","fields":{"slug":"/arc-browser/"},"frontmatter":{"title":"arc browser"}}},{"node":{"id":"ae4611cf-ac19-58f9-be47-e8452f25a2df","fields":{"slug":"/Apple-Silicon과-pyenv/"},"frontmatter":{"title":"Apple Silicon과 pyenv"}}},{"node":{"id":"fe32f546-1476-5dc1-99f4-355cd81fba19","fields":{"slug":"/FastAPI-프로젝트의-시작/"},"frontmatter":{"title":"FastAPI 프로젝트의 시작"}}},{"node":{"id":"7edd7ada-7dda-553b-b007-2e7eacdc0c25","fields":{"slug":"/Geocoder와-Reverse-Geocoder/"},"frontmatter":{"title":"Geocoder와 Reverse Geocoder"}}},{"node":{"id":"ef7e194d-396d-5189-87b2-9905aa8edea4","fields":{"slug":"/Postgresql의-JSON과-JSONB/"},"frontmatter":{"title":"Postgresql의 JSON과 JSONB"}}},{"node":{"id":"ad9ce5f7-33b5-5f19-9087-52c928903f92","fields":{"slug":"/SQLModel에서-unique_constraints-설정하기/"},"frontmatter":{"title":"SQLModel에서 unique_constraints 설정하기"}}},{"node":{"id":"fbd5faae-ec78-5d51-ac80-d809dc5137d2","fields":{"slug":"/Supabase-Local-Dev-환경-꾸미기/"},"frontmatter":{"title":"Supabase Local Dev 환경 꾸미기"}}},{"node":{"id":"939d0130-e4ea-5ae4-a169-be69c0f404f9","fields":{"slug":"/Supabase와-Row-Level-Security-RLS/"},"frontmatter":{"title":"Supabase와 Row-Level Security (RLS) "}}},{"node":{"id":"6c085c2e-fa7b-5dcc-a26f-df91cf9354ea","fields":{"slug":"/Supabase-Local-개발-환경-꾸미기---DB-세팅/"},"frontmatter":{"title":"Supabase Local 개발 환경 꾸미기 - DB 세팅"}}},{"node":{"id":"f1f51fb0-adac-5433-9a00-912141ff3182","fields":{"slug":"/Supabase-CLI-db-migration-이력-초기화하기/"},"frontmatter":{"title":"Supabase CLI db migration 이력 초기화하기"}}},{"node":{"id":"2a0b1ae0-7af6-5ce1-90ad-57af39dc2085","fields":{"slug":"/Supabase-EdgeFunction---Deno-개발환경-꾸미기/"},"frontmatter":{"title":"Supabase EdgeFunction  - Deno 개발환경 꾸미기"}}},{"node":{"id":"bbfd7494-2deb-5de4-88dd-5ffbdd240cf6","fields":{"slug":"/Postgresql-Function-Trigger-생성-쿼리문-확인하기/"},"frontmatter":{"title":"Postgresql Function, Trigger 생성 쿼리문 확인하기"}}},{"node":{"id":"e2d90afb-f1f2-5e1f-aab6-820a0d5cf41c","fields":{"slug":"/postgresql의-pg_jsonschema/"},"frontmatter":{"title":"postgresql의 pg_jsonschema"}}},{"node":{"id":"a692b906-efe4-5b06-a108-de1a09926ea9","fields":{"slug":"/Postgresql에서-ENUM-타입에서-값-삭제하기/"},"frontmatter":{"title":"Postgresql에서 ENUM 타입에서 값 삭제하기"}}},{"node":{"id":"d48736cc-957e-53f5-9f48-aac53d5598e4","fields":{"slug":"/PostgreSQL에서-테이블-로우를-JSON으로-변환하기/"},"frontmatter":{"title":"PostgreSQL에서 테이블 로우를 JSON으로 변환하기"}}},{"node":{"id":"02ae12df-41b7-5333-a060-ecc60974fbab","fields":{"slug":"/RLS에-대한-궁금증-모음/"},"frontmatter":{"title":"RLS에 대한 궁금증 모음"}}},{"node":{"id":"78c2562a-631b-572d-8dee-132c9ff9b074","fields":{"slug":"/Deno에서-URL의-쿼리-스트링Query-String-다루기/"},"frontmatter":{"title":" Deno에서 URL의 쿼리 스트링(Query String) 다루기"}}},{"node":{"id":"bab930ba-913e-596b-a917-bdd124dd36db","fields":{"slug":"/Supabase에서-뷰에도-RLS-적용하기/"},"frontmatter":{"title":"Supabase에서 뷰에도 RLS 적용하기"}}},{"node":{"id":"8c276d68-536a-5e9d-a09f-c0055c239046","fields":{"slug":"/supabase-custom-claims를-활용한-관리자-권한-관리/"},"frontmatter":{"title":"supabase-custom-claims를 활용한 관리자 권한 관리"}}},{"node":{"id":"d6698c34-32be-55f0-94d2-50b66aef1073","fields":{"slug":"/Supabase를-위한-Bitbucket-Pipelines-CICD-워크플로우-구축하기/"},"frontmatter":{"title":"Supabase를 위한 Bitbucket Pipelines CI/CD 워크플로우 구축하기"}}},{"node":{"id":"bc763a45-0f35-5420-9eed-9e6387ff48ee","fields":{"slug":"/Pyenv-local-실행을-했는데-파이썬-버전이-바뀌지-않는다/"},"frontmatter":{"title":"Pyenv local 실행을 했는데 파이썬 버전이 바뀌지 않는다"}}},{"node":{"id":"60b158b5-de2c-56a7-a158-53f3648b2889","fields":{"slug":"/Django-설치/"},"frontmatter":{"title":"Django 설치"}}},{"node":{"id":"711d4b8d-3afb-59f8-a47e-efe8b52f1665","fields":{"slug":"/docker-compose를-활용한-postgresql과-django-커넥션-만들기/"},"frontmatter":{"title":"docker-compose를 활용한 postgresql과 django 커넥션 만들기"}}},{"node":{"id":"3c997249-c541-501d-9479-558a653fc409","fields":{"slug":"/Nextjs-소개와-설치-간단-예제/"},"frontmatter":{"title":"Next.js 소개와 설치, 간단 예제"}}},{"node":{"id":"e04ee4b2-2742-5601-a3f7-147ad7074bc1","fields":{"slug":"/ngrok-로컬-서버를-쉽게-공개하는-도구/"},"frontmatter":{"title":"ngrok: 로컬 서버를 쉽게 공개하는 도구"}}},{"node":{"id":"286a5830-d62e-5ddd-99e9-d237161a5838","fields":{"slug":"/Django-Discord-소셜-회원가입-및-로그인-구현/"},"frontmatter":{"title":"Django Discord 소셜 회원가입 및 로그인 구현"}}},{"node":{"id":"e2facd8b-fe1b-5d7e-8134-327a36c58230","fields":{"slug":"/Nextjs-Supabase-회원가입-구현/"},"frontmatter":{"title":"Next.js + Supabase 회원가입 구현"}}},{"node":{"id":"987a5340-8662-50df-85c0-6b7c3732d791","fields":{"slug":"/Django-프로젝트에-Swagger-설정하기/"},"frontmatter":{"title":"Django 프로젝트에 Swagger 설정하기"}}},{"node":{"id":"989746e1-cdef-5498-8c00-2087bbb27bd7","fields":{"slug":"/Django-Rest-Framework에서-JWT를-이용한-사용자-인증-구현/"},"frontmatter":{"title":"Django Rest Framework에서 JWT를 이용한 사용자 인증 구현"}}},{"node":{"id":"11691347-100c-5676-9729-f22ce8a43272","fields":{"slug":"/Django의-Serializers/"},"frontmatter":{"title":"Django의 Serializers"}}},{"node":{"id":"910235bb-5188-5a17-a705-a552a6684e7d","fields":{"slug":"/Go-입문/"},"frontmatter":{"title":"Go 입문"}}},{"node":{"id":"a1ef6dd3-d896-5758-8f72-9e378dcab0f3","fields":{"slug":"/Go를-활용한-OAuth-20-구현/"},"frontmatter":{"title":"Go를 활용한 OAuth 2.0 구현"}}},{"node":{"id":"55e2a5f0-e2c2-5f20-9bc1-e6f52142b1ab","fields":{"slug":"/Django의-사용자-인증-시스템-커스터마이징/"},"frontmatter":{"title":"Django의 사용자 인증 시스템 커스터마이징"}}},{"node":{"id":"27fc9be6-e48b-52a8-bf6d-c0c664700209","fields":{"slug":"/DRF의-API-View/"},"frontmatter":{"title":"DRF의 API View"}}},{"node":{"id":"19273a3e-a109-5cb0-a53a-102a2c1f1f74","fields":{"slug":"/AWS-활용-테스트-서버-구현-1/"},"frontmatter":{"title":"AWS 활용 테스트 서버 구현 (1)"}}},{"node":{"id":"b443bdc5-d571-57ac-a75f-e433dc12f651","fields":{"slug":"/AWS에서-EC2-인스턴스-생성-및-Visual-Studio-Code로-원격-연결하기/"},"frontmatter":{"title":"AWS에서 EC2 인스턴스 생성 및 Visual Studio Code로 원격 연결하기"}}},{"node":{"id":"88f3a1cc-7ec0-50be-a43d-d969e27c4529","fields":{"slug":"/Django-REST-Framework에서-가상-필드-추가하기/"},"frontmatter":{"title":"Django REST Framework에서 가상 필드 추가하기"}}},{"node":{"id":"ae529d5f-12b2-59f1-89bc-e832cde40652","fields":{"slug":"/Mock과-Stub-Fixture/"},"frontmatter":{"title":"Mock과 Stub, Fixture"}}},{"node":{"id":"388f1fc6-4ef9-5391-ad7c-03a8e88d99e3","fields":{"slug":"/Install-Tailwind-CSS-with-Nextjs/"},"frontmatter":{"title":"Install Tailwind CSS with Next.js"}}},{"node":{"id":"dbba3bc0-4c3c-5d9d-87fa-c9c9650907df","fields":{"slug":"/Ubuntu-DLNA-서버-설정/"},"frontmatter":{"title":"Ubuntu DLNA 서버 설정"}}},{"node":{"id":"626fd5b3-36c4-5633-8916-46f9aeba4756","fields":{"slug":"/GitHub-Container-Registry-vs-Docker-Hub/"},"frontmatter":{"title":"GitHub Container Registry vs Docker Hub"}}},{"node":{"id":"a0117df3-8740-55e0-b9e9-d14f35c4e2a9","fields":{"slug":"/N1-문제/"},"frontmatter":{"title":"N+1 문제"}}},{"node":{"id":"e925ca86-1d32-5737-b469-6b04e049b5be","fields":{"slug":"/N1-문제의-해결방법/"},"frontmatter":{"title":"N+1 문제의 해결방법"}}},{"node":{"id":"7caa9886-de89-5549-a331-43a790e9be9d","fields":{"slug":"/Django의-관리자-페이지-만들기/"},"frontmatter":{"title":"Django의 관리자 페이지 만들기"}}},{"node":{"id":"4a03fdbb-525f-5955-a2f4-d2e3f37dab34","fields":{"slug":"/Django의-startapp/"},"frontmatter":{"title":"Django의 startapp"}}},{"node":{"id":"d02a3ccb-149b-5f4e-b724-2a5c694d9dd6","fields":{"slug":"/SD-카드-기반-디스크-오류-및-해결-과정/"},"frontmatter":{"title":"SD 카드 기반 디스크 오류 및 해결 과정"}}},{"node":{"id":"bd6bfd1a-0643-5893-b4fe-19074e66dee3","fields":{"slug":"/Docker에서-Python-환경-변수-관리/"},"frontmatter":{"title":"Docker에서 Python 환경 변수 관리"}}},{"node":{"id":"0baf5600-7bc6-5104-b434-352d0e8cf8fb","fields":{"slug":"/Python-Mocking시-patch-경로-문제-해결하기/"},"frontmatter":{"title":"Python Mocking시 patch 경로 문제 해결하기"}}},{"node":{"id":"ac8d2058-f151-5c32-bb36-494173ac916f","fields":{"slug":"/FastAPI의-의존성-주입Dependency-Injection/"},"frontmatter":{"title":"FastAPI의 의존성 주입(Dependency Injection)"}}},{"node":{"id":"7e134f83-d0a3-5e87-82cd-6877e6ba4567","fields":{"slug":"/FastAPI-의존성-주입의-심화-활용법과-주의점/"},"frontmatter":{"title":"FastAPI 의존성 주입의 심화 활용법과 주의점"}}},{"node":{"id":"06b9e98d-7766-587f-b48e-423e69c5a214","fields":{"slug":"/Typescript의-얇은-복사-vs-깊은-복사/"},"frontmatter":{"title":"Typescript의 얇은 복사 vs 깊은 복사"}}},{"node":{"id":"2dfdf2e4-9e64-596a-a6d6-cb81c682ef09","fields":{"slug":"/React-Native-설치/"},"frontmatter":{"title":"React Native 설치"}}},{"node":{"id":"dc2fdc41-a035-5dbc-aa8b-36c493e556cf","fields":{"slug":"/React-Native의-프로젝트-구조와-화면-이동-구현하기/"},"frontmatter":{"title":"React Native의 프로젝트 구조와 화면 이동 구현하기"}}},{"node":{"id":"f071c474-d82d-5dcf-9c08-0d117c0786d8","fields":{"slug":"/React-Native-Navigation과-Paper-기본부터-사용하기/"},"frontmatter":{"title":"React Native Navigation과 Paper: 기본부터 사용하기"}}},{"node":{"id":"41e18e50-7046-569a-a173-6aadc4b70426","fields":{"slug":"/GraphQL과-Django/"},"frontmatter":{"title":"GraphQL과 Django"}}},{"node":{"id":"d333dddb-d654-5b39-9705-92748c1d858d","fields":{"slug":"/우리-팀에-맞는-API-Gateway-선택하기/"},"frontmatter":{"title":"우리 팀에 맞는 API Gateway 선택하기"}}},{"node":{"id":"bfc8ced1-57c5-55e6-a278-bc62fbe28916","fields":{"slug":"/Elastic-APM/"},"frontmatter":{"title":"Elastic APM"}}},{"node":{"id":"7049857b-fde0-5f51-8131-43655deb98ca","fields":{"slug":"/GraphQL과-Django-2/"},"frontmatter":{"title":"GraphQL과 Django 2"}}},{"node":{"id":"f6783709-6fe0-53ce-9d40-6d4c45ff4b7e","fields":{"slug":"/Deepseek-R1-로컬-설치/"},"frontmatter":{"title":"Deepseek R1 로컬 설치"}}},{"node":{"id":"8f11b5a0-d13f-5def-b485-8b9313ecb0f6","fields":{"slug":"/uv-간단-소개-및-적용/"},"frontmatter":{"title":"uv 간단 소개 및 적용"}}},{"node":{"id":"54bf091e-628d-5868-8990-1db21a44ef7c","fields":{"slug":"/Nginx를-활용한-Reverse-Proxy-구현1/"},"frontmatter":{"title":"Nginx를 활용한 Reverse Proxy 구현(1)"}}},{"node":{"id":"2db7be05-a913-5e8f-a010-3d3d5dfc0cc0","fields":{"slug":"/Nginx를-활용한-Reverse-Proxy-구현2/"},"frontmatter":{"title":"Nginx를 활용한 Reverse Proxy 구현(2)"}}},{"node":{"id":"e6010f44-06a4-5a70-880c-a5eb66228f99","fields":{"slug":"/poetry를-활용해-안정적으로-package-업데이트하기/"},"frontmatter":{"title":"poetry를 활용해 안정적으로 package 업데이트하기"}}},{"node":{"id":"e87675f2-5775-56e9-a865-a738372a3cbf","fields":{"slug":"/React-Native에서-커스텀-폰트-추가하여-사용하기/"},"frontmatter":{"title":"React Native에서 커스텀 폰트 추가하여 사용하기"}}},{"node":{"id":"a75adc3f-5c1a-5915-b3b4-6161d21150fd","fields":{"slug":"/Ruff/"},"frontmatter":{"title":"Ruff"}}},{"node":{"id":"43249e85-0fc9-55b4-89ce-7a09bad9ed89","fields":{"slug":"/LDAP/"},"frontmatter":{"title":"LDAP"}}},{"node":{"id":"b3908629-2878-58ff-9d75-3eaa9afe939a","fields":{"slug":"/Nginx의-Reverse-Proxy-모니터링/"},"frontmatter":{"title":"Nginx의 Reverse Proxy 모니터링"}}},{"node":{"id":"877e8495-8028-5b68-8f55-a1c186b09f72","fields":{"slug":"/Django-모델에서-GraphQL-스키마-자동-생성/"},"frontmatter":{"title":"Django 모델에서 GraphQL 스키마 자동 생성"}}},{"node":{"id":"543e7c6d-4b87-5ff3-92ad-ff851d86ee8b","fields":{"slug":"/DataLoader의-적용/"},"frontmatter":{"title":"DataLoader의 적용"}}},{"node":{"id":"66a11a51-172b-502d-8746-39ce9aaf0028","fields":{"slug":"/분산된-모놀리스를-위한-관리자-페이지-시스템-설계-제안/"},"frontmatter":{"title":"분산된 모놀리스를 위한 관리자 페이지 시스템 설계 제안"}}},{"node":{"id":"f3ecc3d6-83df-5a75-91cc-ef3e294b3e16","fields":{"slug":"/Django와-MySQL에서-DB-Sleep으로-인한-Hang-문제-해결-방안/"},"frontmatter":{"title":"Django와 MySQL에서 DB Sleep으로 인한 Hang 문제 해결 방안"}}}]},"previous":{"fields":{"slug":"/DataLoader의-적용/"},"frontmatter":{"title":"DataLoader의 적용"}},"next":{"fields":{"slug":"/Django와-MySQL에서-DB-Sleep으로-인한-Hang-문제-해결-방안/"},"frontmatter":{"title":"Django와 MySQL에서 DB Sleep으로 인한 Hang 문제 해결 방안"}}},"pageContext":{"id":"66a11a51-172b-502d-8746-39ce9aaf0028","series":null,"previousPostId":"543e7c6d-4b87-5ff3-92ad-ff851d86ee8b","nextPostId":"f3ecc3d6-83df-5a75-91cc-ef3e294b3e16"}},"staticQueryHashes":[],"slicesMap":{}}